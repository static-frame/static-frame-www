[![Logo](../_static/sf-logo-web_icon-small.png)](../index.html)

Quick Start

* [static-frame](../readme.html)
* [License](../license.html)

Introduction

* [About StaticFrame](../intro.html)
* [Media](../intro.html#media)
* [What is New in StaticFrame](../new.html)
* [Contributing](../contributing.html)

Articles

* [Improving Code Quality with Array and DataFrame Type Hints](../articles/guard.html)
* [Type-Hinting DataFrames for Static Analysis and Runtime Validation](../articles/ftyping.html)
* [Faster DataFrame Serialization](../articles/serialize.html)
* [The Performance Advantage of No-Copy DataFrame Operations](../articles/no_copy.html)
* [Memoizing DataFrame Functions: Using Hashable DataFrames and Message Digests to Optimize Repeated Calculations](../articles/hash.html)
* [Using Higher-Order Containers to Efficiently Process 7,163 (or More) DataFrames](../articles/uhoc.html)
* [One Fill Value Is Not Enough: Preserving Columnar Types When Reindexing DataFrames](../articles/fill_value.html)
* [Ten Reasons to Use StaticFrame Instead of Pandas](../articles/upgrade.html)
* [Boring Indices & Where to Find Them: The Auto-Incremented Integer Index in StaticFrame](../articles/aiii.html)

API Overview

* [Overview: Series](../api_overview/series.html)
* [Overview: SeriesHE](../api_overview/series_he.html)
* [Overview: Frame](../api_overview/frame.html)
* [Overview: FrameGO](../api_overview/frame_go.html)
* [Overview: FrameHE](../api_overview/frame_he.html)
* [Overview: Bus](../api_overview/bus.html)
* [Overview: Batch](../api_overview/batch.html)
* [Overview: Yarn](../api_overview/yarn.html)
* [Overview: Quilt](../api_overview/quilt.html)
* [Overview: Index](../api_overview/index.html)
* [Overview: IndexGO](../api_overview/index_go.html)
* [Overview: IndexHierarchy](../api_overview/index_hierarchy.html)
* [Overview: IndexHierarchyGO](../api_overview/index_hierarchy_go.html)
* [Overview: IndexYear](../api_overview/index_year.html)
* [Overview: IndexYearGO](../api_overview/index_year_go.html)
* [Overview: IndexYearMonth](../api_overview/index_year_month.html)
* [Overview: IndexYearMonthGO](../api_overview/index_year_month_go.html)
* [Overview: IndexDate](../api_overview/index_date.html)
* [Overview: IndexDateGO](../api_overview/index_date_go.html)
* [Overview: IndexMinute](../api_overview/index_minute.html)
* [Overview: IndexMinuteGO](../api_overview/index_minute_go.html)
* [Overview: IndexHour](../api_overview/index_hour.html)
* [Overview: IndexHourGO](../api_overview/index_hour_go.html)
* [Overview: IndexSecond](../api_overview/index_second.html)
* [Overview: IndexSecondGO](../api_overview/index_second_go.html)
* [Overview: IndexMillisecond](../api_overview/index_millisecond.html)
* [Overview: IndexMillisecondGO](../api_overview/index_millisecond_go.html)
* [Overview: IndexMicrosecond](../api_overview/index_microsecond.html)
* [Overview: IndexMicrosecondGO](../api_overview/index_microsecond_go.html)
* [Overview: IndexNanosecond](../api_overview/index_nanosecond.html)
* [Overview: IndexNanosecondGO](../api_overview/index_nanosecond_go.html)
* [Overview: HLoc](../api_overview/hloc.html)
* [Overview: ILoc](../api_overview/iloc.html)
* [Overview: TypeClinic](../api_overview/type_clinic.html)
* [Overview: CallGuard](../api_overview/call_guard.html)
* [Overview: ClinicResult](../api_overview/clinic_result.html)
* [Overview: Require](../api_overview/require.html)
* [Overview: WWW](../api_overview/www.html)
* [Overview: FillValueAuto](../api_overview/fill_value_auto.html)
* [Overview: DisplayActive](../api_overview/display_active.html)
* [Overview: DisplayConfig](../api_overview/display_config.html)
* [Overview: StoreConfig](../api_overview/store_config.html)
* [Overview: StoreFilter](../api_overview/store_filter.html)
* [Overview: IndexAutoFactory](../api_overview/index_auto_factory.html)
* [Overview: IndexDefaultConstructorFactory](../api_overview/index_default_constructor_factory.html)
* [Overview: IndexAutoConstructorFactory](../api_overview/index_auto_constructor_factory.html)
* [Overview: NPZ](../api_overview/npz.html)
* [Overview: NPY](../api_overview/npy.html)
* [Overview: MemoryDisplay](../api_overview/memory_display.html)
* [Overview: Platform](../api_overview/platform.html)

API Detail

* [Detail: Series](series.html)
* [Detail: SeriesHE](series_he.html)
* [Detail: Frame](frame.html)
* [Detail: FrameGO](frame_go.html)
* [Detail: FrameHE](frame_he.html)
* [Detail: Bus](bus.html)
* [Detail: Batch](batch.html)
* [Detail: Yarn](yarn.html)
* [Detail: Quilt](quilt.html)
* [Detail: Index](index.html)
* [Detail: IndexGO](index_go.html)
* [Detail: IndexHierarchy](index_hierarchy.html)
* [Detail: IndexHierarchyGO](index_hierarchy_go.html)
* [Detail: IndexYear](index_year.html)
* [Detail: IndexYearGO](index_year_go.html)
* [Detail: IndexYearMonth](index_year_month.html)
* [Detail: IndexYearMonthGO](index_year_month_go.html)
* [Detail: IndexDate](index_date.html)
* [Detail: IndexDateGO](index_date_go.html)
* [Detail: IndexMinute](index_minute.html)
* [Detail: IndexMinuteGO](index_minute_go.html)
* [Detail: IndexHour](index_hour.html)
* [Detail: IndexHourGO](index_hour_go.html)
* [Detail: IndexSecond](index_second.html)
* [Detail: IndexSecondGO](index_second_go.html)
* [Detail: IndexMillisecond](index_millisecond.html)
* [Detail: IndexMillisecondGO](index_millisecond_go.html)
* [Detail: IndexMicrosecond](index_microsecond.html)
* [Detail: IndexMicrosecondGO](index_microsecond_go.html)
* [Detail: IndexNanosecond](index_nanosecond.html)
* [Detail: IndexNanosecondGO](index_nanosecond_go.html)
* [Detail: HLoc](hloc.html)
* [Detail: ILoc](iloc.html)
* [Detail: TypeClinic](type_clinic.html)
* [Detail: CallGuard](call_guard.html)
* [Detail: ClinicResult](clinic_result.html)
* [Detail: Require](require.html)
* [Detail: WWW](www.html)
* [Detail: FillValueAuto](fill_value_auto.html)
* [Detail: DisplayActive](display_active.html)
* [Detail: DisplayConfig](display_config.html)
* [Detail: StoreConfig](store_config.html)
* [Detail: StoreFilter](store_filter.html)
* [Detail: IndexAutoFactory](index_auto_factory.html)
* [Detail: IndexDefaultConstructorFactory](index_default_constructor_factory.html)
* [Detail: IndexAutoConstructorFactory](index_auto_constructor_factory.html)
* [Detail: NPZ](npz.html)
* [Detail: NPY](npy.html)
* [Detail: MemoryDisplay](memory_display.html)
* [Detail: Platform](platform.html)

[StaticFrame](../index.html)

* Detail: Series: Method
* [View page source](../_sources/api_detail/series-method.rst.txt)

[Previous](series-attribute.html "Detail: Series: Attribute")
[Next](series-dictionary_like.html "Detail: Series: Dictionary-Like")

---

# Detail: Series: Method[](#detail-series-method "Link to this heading")

[Overview: Series: Method](../api_overview/series-method.html#api-overview-series-method)

Series.\_\_array\_\_(*dtype=None*)[](#static_frame.Series.__array__ "Link to this definition")
:   Support the \_\_array\_\_ interface, returning an array of values.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> s.__array__()
    [10  2  8]

    ```

Series.\_\_array\_ufunc\_\_(*ufunc*, *method*, *\*args*, *\*\*kwargs*)[](#static_frame.Series.__array_ufunc__ "Link to this definition")
:   Support for NumPy elements or arrays on the left hand of binary operators.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> np.array((0, 1, 0)) * s
    <Series>
    <Index>
    a        0
    b        2
    c        0
    <<U1>    <int64>

    ```

Series.\_\_bool\_\_()[](#static_frame.Series.__bool__ "Link to this definition")
:   Raises ValueError to prohibit ambiguous use of truthy evaluation.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> bool(s)
    ErrorNotTruthy('The truth value of a container is ambiguous. For a truthy indicator of non-empty status, use the `size` attribute.')

    ```

Series.\_\_deepcopy\_\_(*memo*)[[source]](../_modules/static_frame/core/series.html#Series.__deepcopy__)[](#static_frame.Series.__deepcopy__ "Link to this definition")
:   ```
    >>> import copy
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> copy.deepcopy(s)
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>

    ```

Series.\_\_len\_\_()[[source]](../_modules/static_frame/core/series.html#Series.__len__)[](#static_frame.Series.__len__ "Link to this definition")
:   Length of values.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> len(s)
    3

    ```

Series.\_\_round\_\_(*decimals=0*, */*)[[source]](../_modules/static_frame/core/series.html#Series.__round__)[](#static_frame.Series.__round__ "Link to this definition")
:   Return a Series rounded to the given decimals. Negative decimals round to the left of the decimal point.

    Parameters:
    :   **decimals** – number of decimals to round to.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((10.235, 2.124, 8.734), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        8.734
    <<U1>    <float64>
    >>> round(s, 1)
    <Series>
    <Index>
    a        10.2
    b        2.1
    c        8.7
    <<U1>    <float64>

    ```

Series.all(*\**, *axis=0*, *skipna=True*, *out=None*)[](#static_frame.Series.all "Link to this definition")
:   Logical `and` over values along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> s = sf.Series((False, False, True), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        False
    b        False
    c        True
    <<U1>    <bool>
    >>> s.all()
    False

    ```

Series.any(*\**, *axis=0*, *skipna=True*, *out=None*)[](#static_frame.Series.any "Link to this definition")
:   Logical `or` over values along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> s = sf.Series((False, False, True), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        False
    b        False
    c        True
    <<U1>    <bool>
    >>> s.any()
    True

    ```

Series.astype(*dtype*, */*)[[source]](../_modules/static_frame/core/series.html#Series.astype)[](#static_frame.Series.astype "Link to this definition")
:   Return a Series with type determined by dtype argument. Note that for Series, this is a simple function, whereas for `Frame`, this is an interface exposing both a callable and a getitem interface.

    Parameters:
    :   **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((11, 1, None), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        11
    b        1
    c        None
    <<U1>    <object>
    >>> s.astype(float)
    <Series>
    <Index>
    a        11.0
    b        1.0
    c        nan
    <<U1>    <float64>

    ```

Series.clip(*\**, *lower=None*, *upper=None*)[[source]](../_modules/static_frame/core/series.html#Series.clip)[](#static_frame.Series.clip "Link to this definition")
:   Apply a clip operation to this [`Series`](series-selector.html#Series "Series"). Note that clip operations can be applied to object types, but cannot be applied to non-numerical objects (e.g., strings, None)

    Parameters:
    :   * **lower** – value or `Series` to define the inclusive lower bound.
        * **upper** – value or `Series` to define the inclusive upper bound.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((10.235, 2.124, 8.734), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        8.734
    <<U1>    <float64>
    >>> s.clip(lower=2.5, upper=10.1)
    <Series>
    <Index>
    a        10.1
    b        2.5
    c        8.734
    <<U1>    <float64>

    ```

Series.corr(*other*, */*)[[source]](../_modules/static_frame/core/series.html#Series.corr)[](#static_frame.Series.corr "Link to this definition")
:   Return the index-aligned correlation to the supplied [`Series`](series-selector.html#Series "Series").

    Parameters:
    :   **other** – Series to be correlated with by selection on corresponding labels.

    ```
    >>> s1 = sf.Series((10.235, 2.124, 8.734), index=('a', 'b', 'c'))
    >>> s1
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        8.734
    <<U1>    <float64>
    >>> s2 = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s2
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> s1.corr(s2)
    0.9977051066985492

    ```

Series.count(*\**, *skipna=True*, *skipfalsy=False*, *unique=False*, *axis=0*)[[source]](../_modules/static_frame/core/series.html#Series.count)[](#static_frame.Series.count "Link to this definition")
:   Return the count of non-NA, non-falsy, and/or unique elements.

    Parameters:
    :   * **skipna** – skip NA (NaN, None) values.
        * **skipfalsy** – skip falsu values (0, ‘’, False, None, NaN)
        * **unique** – Count unique items after optionally applying `skipna` or `skipfalsy` removals.

    ```
    >>> s = sf.Series((8, 5, None, 8), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        8
    b        5
    c        None
    d        8
    <<U1>    <object>
    >>> s.count(skipna=True)
    3
    >>> s.count(unique=True)
    2

    ```

Series.cov(*other*, */*, *\**, *ddof=1*)[[source]](../_modules/static_frame/core/series.html#Series.cov)[](#static_frame.Series.cov "Link to this definition")
:   Return the index-aligned covariance to the supplied [`Series`](series-selector.html#Series "Series").

    Parameters:
    :   **ddof** – Delta degrees of freedom, defaults to 1.

    ```
    >>> s1 = sf.Series((10.235, 2.124, 8.734), index=('a', 'b', 'c'))
    >>> s1
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        8.734
    <<U1>    <float64>
    >>> s2 = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s2
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> s1.cov(s2)
    17.924999999999997

    ```

Series.cumprod(*\**, *axis=0*, *skipna=True*)[](#static_frame.Series.cumprod "Link to this definition")
:   Return the cumulative product over the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> s.cumprod()
    <Series>
    <Index>
    a        10
    b        20
    c        160
    <<U1>    <int64>

    ```

Series.cumsum(*\**, *axis=0*, *skipna=True*)[](#static_frame.Series.cumsum "Link to this definition")
:   Return the cumulative sum over the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> s.cumsum()
    <Series>
    <Index>
    a        10
    b        12
    c        20
    <<U1>    <int64>

    ```

Series.drop\_duplicated(*\**, *exclude\_first=False*, *exclude\_last=False*)[[source]](../_modules/static_frame/core/series.html#Series.drop_duplicated)[](#static_frame.Series.drop_duplicated "Link to this definition")
:   Return a Series with duplicated values removed.

    Parameters:
    :   * **exclude\_first** – Boolean to select if the first duplicated value is excluded.
        * **exclude\_last** – Boolean to select if the last duplicated value is excluded.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((8, 5, None, 8), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        8
    b        5
    c        None
    d        8
    <<U1>    <object>
    >>> s.drop_duplicated()
    <Series>
    <Index>
    b        5
    c        None
    <<U1>    <object>

    ```

Series.dropfalsy()[[source]](../_modules/static_frame/core/series.html#Series.dropfalsy)[](#static_frame.Series.dropfalsy "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series") after removing values of falsy.

    ```
    >>> s = sf.Series(('q', 'r', '', 's'), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        q
    b        r
    c
    d        s
    <<U1>    <<U1>
    >>> s.dropfalsy()
    <Series>
    <Index>
    a        q
    b        r
    d        s
    <<U1>    <<U1>

    ```

Series.dropna()[[source]](../_modules/static_frame/core/series.html#Series.dropna)[](#static_frame.Series.dropna "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series") after removing values of NaN or None.

    ```
    >>> s = sf.Series((8, 5, None, 8), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        8
    b        5
    c        None
    d        8
    <<U1>    <object>
    >>> s.dropna()
    <Series>
    <Index>
    a        8
    b        5
    d        8
    <<U1>    <object>

    ```

Series.duplicated(*\**, *exclude\_first=False*, *exclude\_last=False*)[[source]](../_modules/static_frame/core/series.html#Series.duplicated)[](#static_frame.Series.duplicated "Link to this definition")
:   Return a same-sized Boolean Series that shows True for all values that are duplicated.

    Parameters:
    :   * **exclude\_first** – Boolean to select if the first duplicated value is excluded.
        * **exclude\_last** – Boolean to select if the last duplicated value is excluded.

    Returns:
    :   `numpy.ndarray`

    ```
    >>> s = sf.Series((8, 5, None, 8), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        8
    b        5
    c        None
    d        8
    <<U1>    <object>
    >>> s.duplicated()
    <Series>
    <Index>
    a        True
    b        False
    c        False
    d        True
    <<U1>    <bool>

    ```

Series.equals(*other*, */*, *\**, *compare\_name=False*, *compare\_dtype=False*, *compare\_class=False*, *skipna=True*)[[source]](../_modules/static_frame/core/series.html#Series.equals)[](#static_frame.Series.equals "Link to this definition")
:   Return a `bool` from comparison to any other object.

    Parameters:
    :   * **compare\_name** – Include equality of the container’s name (and all composed containers) in the comparison.
        * **compare\_dtype** – Include equality of the container’s dtype (and all composed containers) in the comparison.
        * **compare\_class** – Include equality of the container’s class (and all composed containers) in the comparison.
        * **skipna** – If True, comparisons between missing values are equal.

    ```
    >>> s1 = sf.Series((10.235, 2.124, 8.734), index=('a', 'b', 'c'))
    >>> s1
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        8.734
    <<U1>    <float64>
    >>> s2 = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s2
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> s1.equals(s2)
    False

    ```

Series.fillfalsy(*value*, */*)[[source]](../_modules/static_frame/core/series.html#Series.fillfalsy)[](#static_frame.Series.fillfalsy "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series") after replacing falsy values with the supplied value. The `value` can be an element or [`Series`](series-selector.html#Series "Series").

    Parameters:
    :   **value** – Value to be used to replace missing values (NaN or None).

    ```
    >>> s = sf.Series(('q', 'r', '', 's'), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        q
    b        r
    c
    d        s
    <<U1>    <<U1>
    >>> s.fillfalsy('missing')
    <Series>
    <Index>
    a        q
    b        r
    c        missing
    d        s
    <<U1>    <<U7>

    ```

Series.fillfalsy\_backward(*limit=0*, */*)[[source]](../_modules/static_frame/core/series.html#Series.fillfalsy_backward)[](#static_frame.Series.fillfalsy_backward "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series") after feeding backward the last non-falsy observation across contiguous falsy values.

    Parameters:
    :   **limit** – Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit.

    ```
    >>> s = sf.Series(('', '', 'r', 's'), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a
    b
    c        r
    d        s
    <<U1>    <<U1>
    >>> s.fillfalsy_backward()
    <Series>
    <Index>
    a        r
    b        r
    c        r
    d        s
    <<U1>    <<U1>

    ```

Series.fillfalsy\_forward(*limit=0*, */*)[[source]](../_modules/static_frame/core/series.html#Series.fillfalsy_forward)[](#static_frame.Series.fillfalsy_forward "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series") after feeding forward the last non-falsy observation across contiguous falsy values.

    Parameters:
    :   **limit** – Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit.

    ```
    >>> s = sf.Series(('p', 'q', '', ''), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        p
    b        q
    c
    d
    <<U1>    <<U1>
    >>> s.fillfalsy_forward()
    <Series>
    <Index>
    a        p
    b        q
    c        q
    d        q
    <<U1>    <<U1>

    ```

Series.fillfalsy\_leading(*value*, */*)[[source]](../_modules/static_frame/core/series.html#Series.fillfalsy_leading)[](#static_frame.Series.fillfalsy_leading "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series") after filling leading (and only leading) falsy values with the supplied value.

    Parameters:
    :   **value** – Value to be used to replace missing values (NaN or None).

    ```
    >>> s = sf.Series(('', '', 'r', 's'), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a
    b
    c        r
    d        s
    <<U1>    <<U1>
    >>> s.fillfalsy_leading('missing')
    <Series>
    <Index>
    a        missing
    b        missing
    c        r
    d        s
    <<U1>    <<U7>

    ```

Series.fillfalsy\_trailing(*value*, */*)[[source]](../_modules/static_frame/core/series.html#Series.fillfalsy_trailing)[](#static_frame.Series.fillfalsy_trailing "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series") after filling trailing (and only trailing) falsy values with the supplied value.

    Parameters:
    :   **value** – Value to be used to replace missing values (NaN or None).

    ```
    >>> s = sf.Series(('p', 'q', '', ''), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        p
    b        q
    c
    d
    <<U1>    <<U1>
    >>> s.fillfalsy_trailing('missing')
    <Series>
    <Index>
    a        p
    b        q
    c        missing
    d        missing
    <<U1>    <<U7>

    ```

Series.fillna(*value*, */*)[[source]](../_modules/static_frame/core/series.html#Series.fillna)[](#static_frame.Series.fillna "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series") after replacing NA (NaN or None) with the supplied value. The `value` can be an element or [`Series`](series-selector.html#Series "Series").

    Parameters:
    :   **value** – Value to be used to replace missing values (NaN or None).

    ```
    >>> s = sf.Series((10.235, 2.124, np.nan, 8.734, np.nan), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        nan
    d        8.734
    e        nan
    <<U1>    <float64>
    >>> s.fillna(0.0)
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        0.0
    d        8.734
    e        0.0
    <<U1>    <float64>

    ```

Series.fillna\_backward(*limit=0*, */*)[[source]](../_modules/static_frame/core/series.html#Series.fillna_backward)[](#static_frame.Series.fillna_backward "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series") after feeding backward the last non-null (NaN or None) observation across contiguous nulls.

    Parameters:
    :   **limit** – Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit.

    ```
    >>> s = sf.Series((np.nan, np.nan, 10.235, 2.124, 8.734), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        nan
    b        nan
    c        10.235
    d        2.124
    e        8.734
    <<U1>    <float64>
    >>> s.fillna_backward()
    <Series>
    <Index>
    a        10.235
    b        10.235
    c        10.235
    d        2.124
    e        8.734
    <<U1>    <float64>

    ```

Series.fillna\_forward(*limit=0*, */*)[[source]](../_modules/static_frame/core/series.html#Series.fillna_forward)[](#static_frame.Series.fillna_forward "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series") after feeding forward the last non-null (NaN or None) observation across contiguous nulls.

    Parameters:
    :   **limit** – Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit.

    ```
    >>> s = sf.Series((10.235, 2.124, 8.734, np.nan, np.nan), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        8.734
    d        nan
    e        nan
    <<U1>    <float64>
    >>> s.fillna_forward()
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        8.734
    d        8.734
    e        8.734
    <<U1>    <float64>

    ```

Series.fillna\_leading(*value*, */*)[[source]](../_modules/static_frame/core/series.html#Series.fillna_leading)[](#static_frame.Series.fillna_leading "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series") after filling leading (and only leading) null (NaN or None) with the supplied value.

    Parameters:
    :   **value** – Value to be used to replace missing values (NaN or None).

    ```
    >>> s = sf.Series((np.nan, np.nan, 10.235, 2.124, 8.734), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        nan
    b        nan
    c        10.235
    d        2.124
    e        8.734
    <<U1>    <float64>
    >>> s.fillna_leading(0.0)
    <Series>
    <Index>
    a        0.0
    b        0.0
    c        10.235
    d        2.124
    e        8.734
    <<U1>    <float64>

    ```

Series.fillna\_trailing(*value*, */*)[[source]](../_modules/static_frame/core/series.html#Series.fillna_trailing)[](#static_frame.Series.fillna_trailing "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series") after filling trailing (and only trailing) null (NaN or None) with the supplied value.

    Parameters:
    :   **value** – Value to be used to replace missing values (NaN or None).

    ```
    >>> s = sf.Series((10.235, 2.124, 8.734, np.nan, np.nan), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        8.734
    d        nan
    e        nan
    <<U1>    <float64>
    >>> s.fillna_trailing(0.0)
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        8.734
    d        0.0
    e        0.0
    <<U1>    <float64>

    ```

Series.head(*count=5*, */*)[[source]](../_modules/static_frame/core/series.html#Series.head)[](#static_frame.Series.head "Link to this definition")
:   Return a [`Series`](series-selector.html#Series "Series") consisting only of the top elements as specified by `count`.

    Parameters:
    :   **count** – Number of elements to be returned from the top of the [`Series`](series-selector.html#Series "Series")

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((10.235, 2.124, np.nan, 8.734, np.nan), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        nan
    d        8.734
    e        nan
    <<U1>    <float64>
    >>> s.head(2)
    <Series>
    <Index>
    a        10.235
    b        2.124
    <<U1>    <float64>

    ```

Series.iloc\_max(*\**, *skipna=True*)[[source]](../_modules/static_frame/core/series.html#Series.iloc_max)[](#static_frame.Series.iloc_max "Link to this definition")
:   Return the integer index corresponding to the maximum value.

    Parameters:
    :   **skipna** – if True, NaN or None values will be ignored; if False, a found NaN will propagate.

    Returns:
    :   int

    ```
    >>> s = sf.Series((10.235, 2.124, np.nan, 8.734, np.nan), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        nan
    d        8.734
    e        nan
    <<U1>    <float64>
    >>> s.iloc_max()
    0

    ```

Series.iloc\_min(*\**, *skipna=True*)[[source]](../_modules/static_frame/core/series.html#Series.iloc_min)[](#static_frame.Series.iloc_min "Link to this definition")
:   Return the integer index corresponding to the minimum value found.

    Parameters:
    :   **skipna** – if True, NaN or None values will be ignored; if False, a found NaN will propagate.

    Returns:
    :   int

    ```
    >>> s = sf.Series((10.235, 2.124, np.nan, 8.734, np.nan), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        nan
    d        8.734
    e        nan
    <<U1>    <float64>
    >>> s.iloc_min()
    1

    ```

Series.iloc\_notfalsy\_first(*\**, *fill\_value=-1*)[[source]](../_modules/static_frame/core/series.html#Series.iloc_notfalsy_first)[](#static_frame.Series.iloc_notfalsy_first "Link to this definition")
:   Return the position corresponding to the first non-falsy (including nan) value found.

    Parameters:
    :   **{fill\_value}** –

    Returns:
    :   TLabel

    ```
    >>> s = sf.Series(('', '', 19, 34, None), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a
    b
    c        19
    d        34
    e        None
    <<U1>    <object>
    >>> s.iloc_notfalsy_first()
    2

    ```

Series.iloc\_notfalsy\_last(*\**, *fill\_value=-1*)[[source]](../_modules/static_frame/core/series.html#Series.iloc_notfalsy_last)[](#static_frame.Series.iloc_notfalsy_last "Link to this definition")
:   Return the position corresponding to the last non-falsy (including nan) value found.

    Parameters:
    :   **{fill\_value}** –

    Returns:
    :   TLabel

    ```
    >>> s = sf.Series(('', '', 19, 34, None), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a
    b
    c        19
    d        34
    e        None
    <<U1>    <object>
    >>> s.iloc_notfalsy_last()
    3

    ```

Series.iloc\_notna\_first(*\**, *fill\_value=-1*)[[source]](../_modules/static_frame/core/series.html#Series.iloc_notna_first)[](#static_frame.Series.iloc_notna_first "Link to this definition")
:   Return the position corresponding to the first not NA (None or nan) value found.

    Parameters:
    :   **{fill\_value}** –

    Returns:
    :   TLabel

    ```
    >>> s = sf.Series((np.nan, 2.124, 8.734, np.nan, np.nan), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        nan
    b        2.124
    c        8.734
    d        nan
    e        nan
    <<U1>    <float64>
    >>> s.iloc_notna_first()
    1

    ```

Series.iloc\_notna\_last(*\**, *fill\_value=-1*)[[source]](../_modules/static_frame/core/series.html#Series.iloc_notna_last)[](#static_frame.Series.iloc_notna_last "Link to this definition")
:   Return the position corresponding to the last not NA (None or nan) value found.

    Parameters:
    :   **{fill\_value}** –

    Returns:
    :   TLabel

    ```
    >>> s = sf.Series((np.nan, 2.124, 8.734, np.nan, np.nan), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        nan
    b        2.124
    c        8.734
    d        nan
    e        nan
    <<U1>    <float64>
    >>> s.iloc_notna_last()
    2

    ```

Series.iloc\_searchsorted(*values*, */*, *\**, *side\_left=True*)[[source]](../_modules/static_frame/core/series.html#Series.iloc_searchsorted)[](#static_frame.Series.iloc_searchsorted "Link to this definition")
:   Given a sorted [`Series`](series-selector.html#Series "Series"), return the iloc (integer) position(s) at which insertion in `values` would retain sort order.

    Parameters:
    :   * **values** – a single value, or iterable of values.
        * **side\_left** – If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side\_left==True will return that position, side\_left==Right will return the next position (or the length).

    ```
    >>> s = sf.Series((2, 8, 19, 34, 54), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        2
    b        8
    c        19
    d        34
    e        54
    <<U1>    <int64>
    >>> s.iloc_searchsorted(18)
    2

    ```

Series.insert\_after(*key*, *container*, */*)[[source]](../_modules/static_frame/core/series.html#Series.insert_after)[](#static_frame.Series.insert_after "Link to this definition")
:   Create a new [`Series`](series-selector.html#Series "Series") by inserting a [`Series`](series-selector.html#Series "Series") at the position after the label specified by `key`.

    Parameters:
    :   * **key** – Label after which the new container will be inserted.
        * **container** – Container to be inserted.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s1 = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s2 = sf.Series((4, 3, 12), index=('d', 'e', 'f'))
    >>> s1.insert_after('b', s2)
    <Series>
    <Index>
    a        10
    b        2
    d        4
    e        3
    f        12
    c        8
    <<U1>    <int64>

    ```

Series.insert\_before(*key*, *container*, */*)[[source]](../_modules/static_frame/core/series.html#Series.insert_before)[](#static_frame.Series.insert_before "Link to this definition")
:   Create a new [`Series`](series-selector.html#Series "Series") by inserting a [`Series`](series-selector.html#Series "Series") at the position before the label specified by `key`.

    Parameters:
    :   * **key** – Label before which the new container will be inserted.
        * **container** – Container to be inserted.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s1 = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s2 = sf.Series((4, 3, 12), index=('d', 'e', 'f'))
    >>> s1.insert_before('b', s2)
    <Series>
    <Index>
    a        10
    d        4
    e        3
    f        12
    b        2
    c        8
    <<U1>    <int64>

    ```

Series.isfalsy()[[source]](../_modules/static_frame/core/series.html#Series.isfalsy)[](#static_frame.Series.isfalsy "Link to this definition")
:   Return a same-indexed, Boolean [`Series`](series-selector.html#Series "Series") indicating which values are falsy.

    ```
    >>> s = sf.Series((2, '', 19, 0, None), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        2
    b
    c        19
    d        0
    e        None
    <<U1>    <object>
    >>> s.isfalsy()
    <Series>
    <Index>
    a        False
    b        True
    c        False
    d        True
    e        True
    <<U1>    <bool>

    ```

Series.isin(*other*, */*)[[source]](../_modules/static_frame/core/series.html#Series.isin)[](#static_frame.Series.isin "Link to this definition")
:   Return a same-sized Boolean Series that shows if the same-positioned element is in the iterable passed to the function.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((2, '', 19, 0, None), index=('a', 'b', 'c', 'd', 'e'))
    >>> s.isin((2, 19))
    <Series>
    <Index>
    a        True
    b        False
    c        True
    d        False
    e        False
    <<U1>    <bool>

    ```

Series.isna()[[source]](../_modules/static_frame/core/series.html#Series.isna)[](#static_frame.Series.isna "Link to this definition")
:   Return a same-indexed, Boolean [`Series`](series-selector.html#Series "Series") indicating which values are NaN or None.

    ```
    >>> s = sf.Series((10.235, 2.124, np.nan, 8.734, np.nan), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        nan
    d        8.734
    e        nan
    <<U1>    <float64>
    >>> s.isna()
    <Series>
    <Index>
    a        False
    b        False
    c        True
    d        False
    e        True
    <<U1>    <bool>

    ```

Series.loc\_max(*\**, *skipna=True*)[[source]](../_modules/static_frame/core/series.html#Series.loc_max)[](#static_frame.Series.loc_max "Link to this definition")
:   Return the label corresponding to the maximum value found.

    Parameters:
    :   **skipna** – if True, NaN or None values will be ignored; if False, a found NaN will propagate.

    Returns:
    :   TLabel

    ```
    >>> s = sf.Series((10.235, 2.124, np.nan, 8.734, np.nan), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        nan
    d        8.734
    e        nan
    <<U1>    <float64>
    >>> s.loc_max()
    a

    ```

Series.loc\_min(*\**, *skipna=True*)[[source]](../_modules/static_frame/core/series.html#Series.loc_min)[](#static_frame.Series.loc_min "Link to this definition")
:   Return the label corresponding to the minimum value found.

    Parameters:
    :   **skipna** – if True, NaN or None values will be ignored; if False, a found NaN will propagate.

    Returns:
    :   TLabel

    ```
    >>> s = sf.Series((10.235, 2.124, np.nan, 8.734, np.nan), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        nan
    d        8.734
    e        nan
    <<U1>    <float64>
    >>> s.loc_min()
    b

    ```

Series.loc\_notfalsy\_first(*\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/series.html#Series.loc_notfalsy_first)[](#static_frame.Series.loc_notfalsy_first "Link to this definition")
:   Return the label corresponding to the first non-falsy (including nan) value found.

    Parameters:
    :   **{fill\_value}** –

    Returns:
    :   TLabel

    ```
    >>> s = sf.Series(('', '', 19, 34, None), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a
    b
    c        19
    d        34
    e        None
    <<U1>    <object>
    >>> s.loc_notfalsy_first()
    c

    ```

Series.loc\_notfalsy\_last(*\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/series.html#Series.loc_notfalsy_last)[](#static_frame.Series.loc_notfalsy_last "Link to this definition")
:   Return the label corresponding to the last non-falsy (including nan) value found.

    Parameters:
    :   **{fill\_value}** –

    Returns:
    :   TLabel

    ```
    >>> s = sf.Series(('', '', 19, 34, None), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a
    b
    c        19
    d        34
    e        None
    <<U1>    <object>
    >>> s.loc_notfalsy_last()
    d

    ```

Series.loc\_notna\_first(*\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/series.html#Series.loc_notna_first)[](#static_frame.Series.loc_notna_first "Link to this definition")
:   Return the label corresponding to the first not NA (None or nan) value found.

    Parameters:
    :   **{fill\_value}** –

    Returns:
    :   TLabel

    ```
    >>> s = sf.Series((np.nan, 2.124, 8.734, np.nan, np.nan), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        nan
    b        2.124
    c        8.734
    d        nan
    e        nan
    <<U1>    <float64>
    >>> s.loc_notna_first()
    b

    ```

Series.loc\_notna\_last(*\**, *fill\_value=-1*)[[source]](../_modules/static_frame/core/series.html#Series.loc_notna_last)[](#static_frame.Series.loc_notna_last "Link to this definition")
:   Return the label corresponding to the last not NA (None or nan) value found.

    Parameters:
    :   **{fill\_value}** –

    Returns:
    :   TLabel

    ```
    >>> s = sf.Series((np.nan, 2.124, 8.734, np.nan, np.nan), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        nan
    b        2.124
    c        8.734
    d        nan
    e        nan
    <<U1>    <float64>
    >>> s.loc_notna_last()
    c

    ```

Series.loc\_searchsorted(*values*, */*, *\**, *side\_left=True*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/series.html#Series.loc_searchsorted)[](#static_frame.Series.loc_searchsorted "Link to this definition")
:   Given a sorted [`Series`](series-selector.html#Series "Series"), return the loc (label) position(s) at which insertion in `values` would retain sort order.

    Parameters:
    :   * **values** – a single value, or iterable of values.
        * **side\_left** – If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side\_left==True will return that position, side\_left==Right will return the next position (or the length).
        * **fill\_value** – A value to be used to fill the label beyond the last label.

    ```
    >>> s = sf.Series((2, 8, 19, 34, 54), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        2
    b        8
    c        19
    d        34
    e        54
    <<U1>    <int64>
    >>> s.loc_searchsorted(18)
    c

    ```

Series.max(*\**, *axis=0*, *skipna=True*, *out=None*)[](#static_frame.Series.max "Link to this definition")
:   Return the maximum along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> s.max()
    10

    ```

Series.mean(*\**, *axis=0*, *skipna=True*, *out=None*)[](#static_frame.Series.mean "Link to this definition")
:   Return the mean along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> s.mean()
    6.666666666666667

    ```

Series.median(*\**, *axis=0*, *skipna=True*, *out=None*)[](#static_frame.Series.median "Link to this definition")
:   Return the median along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> s.median()
    8.0

    ```

Series.min(*\**, *axis=0*, *skipna=True*, *out=None*)[](#static_frame.Series.min "Link to this definition")
:   Return the minimum along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> s.min()
    2

    ```

Series.notfalsy()[[source]](../_modules/static_frame/core/series.html#Series.notfalsy)[](#static_frame.Series.notfalsy "Link to this definition")
:   Return a same-indexed, Boolean [`Series`](series-selector.html#Series "Series") indicating which values are falsy.

    ```
    >>> s = sf.Series((2, '', 19, 0, None), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        2
    b
    c        19
    d        0
    e        None
    <<U1>    <object>
    >>> s.notfalsy()
    <Series>
    <Index>
    a        True
    b        False
    c        True
    d        False
    e        False
    <<U1>    <bool>

    ```

Series.notna()[[source]](../_modules/static_frame/core/series.html#Series.notna)[](#static_frame.Series.notna "Link to this definition")
:   Return a same-indexed, Boolean [`Series`](series-selector.html#Series "Series") indicating which values are NaN or None.

    ```
    >>> s = sf.Series((10.235, 2.124, np.nan, 8.734, np.nan), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        nan
    d        8.734
    e        nan
    <<U1>    <float64>
    >>> s.notna()
    <Series>
    <Index>
    a        True
    b        True
    c        False
    d        True
    e        False
    <<U1>    <bool>

    ```

Series.prod(*\**, *axis=0*, *skipna=True*, *allna=1*, *out=None*)[](#static_frame.Series.prod "Link to this definition")
:   Return the product along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> s.prod()
    160

    ```

Series.rank\_dense(*\**, *skipna=True*, *ascending=True*, *start=0*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/series.html#Series.rank_dense)[](#static_frame.Series.rank_dense "Link to this definition")
:   Rank values as compactly as possible, where ties get the same value, and ranks are contiguous (potentially non-unique) integers.

    Parameters:
    :   * **skipna** – If `True`, exclude NA values (NaN or None) from ranking, replacing those values with `fill_value`.
        * **ascending** – If `True`, the lowest ranks correspond to the lowest values. The default is `True`.
        * **start** – The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1.
        * **fill\_value** – A value to be used to fill NA values ignored in ranking when `skipna` is `True`. The default is `np.nan` but can be set to any value to force NA values to the “bottom” or “top” of a rank as needed.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((8, 5, 0, 8), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        8
    b        5
    c        0
    d        8
    <<U1>    <int64>
    >>> s.rank_dense()
    <Series>
    <Index>
    a        2
    b        1
    c        0
    d        2
    <<U1>    <int64>

    ```

Series.rank\_max(*\**, *skipna=True*, *ascending=True*, *start=0*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/series.html#Series.rank_max)[](#static_frame.Series.rank_max "Link to this definition")
:   Rank values where tied values are assigned the maximum ordinal rank; ranks are potentially non-contiguous and non-unique integers.

    Parameters:
    :   * **skipna** – If `True`, exclude NA values (NaN or None) from ranking, replacing those values with `fill_value`.
        * **ascending** – If `True`, the lowest ranks correspond to the lowest values. The default is `True`.
        * **start** – The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1.
        * **fill\_value** – A value to be used to fill NA values ignored in ranking when `skipna` is `True`. The default is `np.nan` but can be set to any value to force NA values to the “bottom” or “top” of a rank as needed.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((8, 5, 0, 8), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        8
    b        5
    c        0
    d        8
    <<U1>    <int64>
    >>> s.rank_max()
    <Series>
    <Index>
    a        3
    b        1
    c        0
    d        3
    <<U1>    <int64>

    ```

Series.rank\_mean(*\**, *skipna=True*, *ascending=True*, *start=0*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/series.html#Series.rank_mean)[](#static_frame.Series.rank_mean "Link to this definition")
:   Rank values where tied values are assigned the mean of the ordinal ranks; ranks are potentially non-contiguous and non-unique floats.

    Parameters:
    :   * **skipna** – If `True`, exclude NA values (NaN or None) from ranking, replacing those values with `fill_value`.
        * **ascending** – If `True`, the lowest ranks correspond to the lowest values. The default is `True`.
        * **start** – The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1.
        * **fill\_value** – A value to be used to fill NA values ignored in ranking when `skipna` is `True`. The default is `np.nan` but can be set to any value to force NA values to the “bottom” or “top” of a rank as needed.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((8, 5, 0, 8), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        8
    b        5
    c        0
    d        8
    <<U1>    <int64>
    >>> s.rank_mean()
    <Series>
    <Index>
    a        2.5
    b        1.0
    c        0.0
    d        2.5
    <<U1>    <float64>

    ```

Series.rank\_min(*\**, *skipna=True*, *ascending=True*, *start=0*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/series.html#Series.rank_min)[](#static_frame.Series.rank_min "Link to this definition")
:   Rank values where tied values are assigned the minimum ordinal rank; ranks are potentially non-contiguous and non-unique integers.

    Parameters:
    :   * **skipna** – If `True`, exclude NA values (NaN or None) from ranking, replacing those values with `fill_value`.
        * **ascending** – If `True`, the lowest ranks correspond to the lowest values. The default is `True`.
        * **start** – The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1.
        * **fill\_value** – A value to be used to fill NA values ignored in ranking when `skipna` is `True`. The default is `np.nan` but can be set to any value to force NA values to the “bottom” or “top” of a rank as needed.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((8, 5, 0, 8), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        8
    b        5
    c        0
    d        8
    <<U1>    <int64>
    >>> s.rank_min()
    <Series>
    <Index>
    a        2
    b        1
    c        0
    d        2
    <<U1>    <int64>

    ```

Series.rank\_ordinal(*\**, *skipna=True*, *ascending=True*, *start=0*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/series.html#Series.rank_ordinal)[](#static_frame.Series.rank_ordinal "Link to this definition")
:   Rank values distinctly, where ties get distinct values that maintain their ordering, and ranks are contiguous unique integers.

    Parameters:
    :   * **skipna** – If `True`, exclude NA values (NaN or None) from ranking, replacing those values with `fill_value`.
        * **ascending** – If `True`, the lowest ranks correspond to the lowest values. The default is `True`.
        * **start** – The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1.
        * **fill\_value** – A value to be used to fill NA values ignored in ranking when `skipna` is `True`. The default is `np.nan` but can be set to any value to force NA values to the “bottom” or “top” of a rank as needed.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((8, 5, 0, 8), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        8
    b        5
    c        0
    d        8
    <<U1>    <int64>
    >>> s.rank_ordinal()
    <Series>
    <Index>
    a        2
    b        1
    c        0
    d        3
    <<U1>    <int64>

    ```

Series.rehierarch(*depth\_map*, */*, *\**, *index\_constructors=None*)[[source]](../_modules/static_frame/core/series.html#Series.rehierarch)[](#static_frame.Series.rehierarch "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series") with new a hierarchy based on the supplied `depth_map`.

    ```
    >>> s = sf.Series((3, 2, 8, 7), index=sf.IndexHierarchy.from_product((1, 2), ('a', 'b')))
    >>> s
    <Series>
    <IndexHierarchy>
    1                a     3
    1                b     2
    2                a     8
    2                b     7
    <int64>          <<U1> <int64>
    >>> s.rehierarch((1, 0))
    <Series>
    <IndexHierarchy>
    a                1       3
    a                2       8
    b                1       2
    b                2       7
    <<U1>            <int64> <int64>

    ```

Series.reindex(*index*, *\**, *fill\_value=nan*, *own\_index=False*, *check\_equals=True*)[[source]](../_modules/static_frame/core/series.html#Series.reindex)[](#static_frame.Series.reindex "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series") with labels defined by the provided index. The size and ordering of the data is determined by the newly provided index, where data will continue to be aligned under labels found in both the new and the old index. Labels found only in the new index will be filled with `fill_value`.

    Parameters:
    :   * **index** – An iterable of unique, hashable values, or another `Index` or `IndexHierarchy`, to be used as the labels of the index.
        * **columns** – An iterable of unique, hashable values, or another `Index` or `IndexHierarchy`, to be used as the labels of the index.
        * **fill\_value** – A value to be used to fill space created by a new index that has values not found in the previous index.
        * **own\_index** – Flag the passed index as ownable by this [`static_frame.Series`](series.html#static_frame.Series "static_frame.Series"). Primarily used by internal clients.

    ```
    >>> s = sf.Series((8, 5, 0, 8), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        8
    b        5
    c        0
    d        8
    <<U1>    <int64>
    >>> s.reindex(('d', 'f', 'e', 'c'), fill_value=-1)
    <Series>
    <Index>
    d        8
    f        -1
    e        -1
    c        0
    <<U1>    <int64>

    ```

Series.relabel(*index*, *\**, *index\_constructor=None*)[[source]](../_modules/static_frame/core/series.html#Series.relabel)[](#static_frame.Series.relabel "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series") with transformed labels on the index. The size and ordering of the data is never changed in a relabeling operation. The resulting index must be unique.

    Parameters:
    :   **index** – One of the following types, used to create new index labels with the same size as the previous index. (a) A mapping (as a dictionary or `Series`), used to lookup and transform the labels in the previous index. Labels not found in the mapping will be reused. (b) A function, returning a hashable, that is applied to each label in the previous index. (c) The `IndexAutoFactory` type, to apply auto-incremented integer labels. (d) An `Index` initializer, i.e., either an iterable of hashables or an `Index` instance.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> s.relabel(('x', 'y', 'z'))
    <Series>
    <Index>
    x        10
    y        2
    z        8
    <<U1>    <int64>
    >>> s.relabel(dict(a='x', b='y'))
    <Series>
    <Index>
    x        10
    y        2
    c        8
    <<U1>    <int64>
    >>> s.relabel(lambda l: f'+{l.upper()}+')
    <Series>
    <Index>
    +A+      10
    +B+      2
    +C+      8
    <<U3>    <int64>

    ```

Series.relabel\_flat()[[source]](../_modules/static_frame/core/series.html#Series.relabel_flat)[](#static_frame.Series.relabel_flat "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series"), where an `IndexHierarchy` (if defined) is replaced with a flat, one-dimension index of tuples.

    ```
    >>> s = sf.Series((3, 2, 8, 7), index=sf.IndexHierarchy.from_product((1, 2), ('a', 'b')))
    >>> s
    <Series>
    <IndexHierarchy>
    1                a     3
    1                b     2
    2                a     8
    2                b     7
    <int64>          <<U1> <int64>
    >>> s.relabel_flat()
    <Series>
    <Index>
    (np.int64(1), np.str_('a')) 3
    (np.int64(1), np.str_('b')) 2
    (np.int64(2), np.str_('a')) 8
    (np.int64(2), np.str_('b')) 7
    <object>                    <int64>

    ```

Series.relabel\_level\_add(*level*, */*, *\**, *index\_constructor=None*)[[source]](../_modules/static_frame/core/series.html#Series.relabel_level_add)[](#static_frame.Series.relabel_level_add "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series"), adding a new root level to an existing `IndexHierarchy`, or creating an `IndexHierarchy` if one is not yet defined.

    Parameters:
    :   **level** – A hashable value to be used as a new root level, extending or creating an `IndexHierarchy`

    ```
    >>> s = sf.Series((3, 2, 8, 7), index=sf.IndexHierarchy.from_product((1, 2), ('a', 'b')))
    >>> s
    <Series>
    <IndexHierarchy>
    1                a     3
    1                b     2
    2                a     8
    2                b     7
    <int64>          <<U1> <int64>
    >>> s.relabel_level_add('x')
    <Series>
    <IndexHierarchy>
    x                1       a     3
    x                1       b     2
    x                2       a     8
    x                2       b     7
    <<U1>            <int64> <<U1> <int64>

    ```

Series.relabel\_level\_drop(*count=1*, */*)[[source]](../_modules/static_frame/core/series.html#Series.relabel_level_drop)[](#static_frame.Series.relabel_level_drop "Link to this definition")
:   Return a new [`Series`](series-selector.html#Series "Series"), dropping one or more levels from a either the root or the leaves of an `IndexHierarchy`. The resulting index must be unique.

    Parameters:
    :   **count** – A positive integer drops that many outer-most (root) levels; a negative integer drops that many inner-most (leaf)levels.

    ```
    >>> s = sf.Series((3, 2, 8, 7), index=sf.IndexHierarchy.from_product((1, 2), ('a', 'b')))
    >>> s
    <Series>
    <IndexHierarchy>
    1                a     3
    1                b     2
    2                a     8
    2                b     7
    <int64>          <<U1> <int64>
    >>> s.iloc[:2].relabel_level_drop(1)
    <Series>
    <Index>
    a        3
    b        2
    <<U1>    <int64>

    ```

Series.rename(*name=<object object>*, */*, *\**, *index=<object object>*)[[source]](../_modules/static_frame/core/series.html#Series.rename)[](#static_frame.Series.rename "Link to this definition")
:   Return a new Series with an updated name attribute.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'), name='x')
    >>> s
    <Series: x>
    <Index>
    a           10
    b           2
    c           8
    <<U1>       <int64>
    >>> s.rename('y')
    <Series: y>
    <Index>
    a           10
    b           2
    c           8
    <<U1>       <int64>

    ```

Series.roll(*shift*, */*, *\**, *include\_index=False*)[[source]](../_modules/static_frame/core/series.html#Series.roll)[](#static_frame.Series.roll "Link to this definition")
:   Return a Series with values rotated forward and wrapped around the index (with a positive shift) or backward and wrapped around the index (with a negative shift).

    Parameters:
    :   * **shift** – Positive or negative integer shift.
        * **include\_index** – Determine if the Index is shifted with the underlying data.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((2, 8, 19, 34, 54), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        2
    b        8
    c        19
    d        34
    e        54
    <<U1>    <int64>
    >>> s.roll(2)
    <Series>
    <Index>
    a        34
    b        54
    c        2
    d        8
    e        19
    <<U1>    <int64>

    ```

Series.sample(*count=1*, */*, *\**, *seed=None*)[[source]](../_modules/static_frame/core/series.html#Series.sample)[](#static_frame.Series.sample "Link to this definition")
:   Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container.

    Parameters:
    :   * **select.** (*Number* *of* *elements to*) –
        * **selection.** (*Initial state* *of* *random*) –

    ```
    >>> s = sf.Series((10.235, 2.124, np.nan, 8.734, np.nan), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        nan
    d        8.734
    e        nan
    <<U1>    <float64>
    >>> s.sample(2, seed=0)
    <Series>
    <Index>
    a        10.235
    c        nan
    <<U1>    <float64>

    ```

Series.shift(*shift*, */*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/series.html#Series.shift)[](#static_frame.Series.shift "Link to this definition")
:   Return a Series with values shifted forward on the index (with a positive shift) or backward on the index (with a negative shift).

    Parameters:
    :   * **shift** – Positive or negative integer shift.
        * **fill\_value** – Value to be used to fill data missing after the shift.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((2, 8, 19, 34, 54), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        2
    b        8
    c        19
    d        34
    e        54
    <<U1>    <int64>
    >>> s.shift(2)
    <Series>
    <Index>
    a        nan
    b        nan
    c        2.0
    d        8.0
    e        19.0
    <<U1>    <float64>

    ```

Series.sort\_index(*\**, *ascending=True*, *kind='mergesort'*, *key=None*)[[source]](../_modules/static_frame/core/series.html#Series.sort_index)[](#static_frame.Series.sort_index "Link to this definition")
:   Return a new Series ordered by the sorted Index.

    Parameters:
    :   * **\*** –
        * **ascendings** – Boolean, or iterable of Booleans; if `True`, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is `True`.
        * **kind** – Name of the sort algorithm as passed to NumPy.
        * **key** – A function that is used to pre-process the selected columns or rows and derive new values to sort by.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((8, 5, 0, 8), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        8
    b        5
    c        0
    d        8
    <<U1>    <int64>
    >>> s.sort_index()
    <Series>
    <Index>
    a        8
    b        5
    c        0
    d        8
    <<U1>    <int64>
    >>> s.sort_index(ascending=False)
    <Series>
    <Index>
    d        8
    c        0
    b        5
    a        8
    <<U1>    <int64>

    ```

Series.sort\_values(*\**, *ascending=True*, *kind='mergesort'*, *key=None*)[[source]](../_modules/static_frame/core/series.html#Series.sort_values)[](#static_frame.Series.sort_values "Link to this definition")
:   Return a new Series ordered by the sorted values.

    Parameters:
    :   * **\*** –
        * **ascending** – If True, sort in ascending order; if False, sort in descending order.
        * **kind** – Name of the sort algorithm as passed to NumPy.
        * **key** – A function that is used to pre-process the selected columns or rows and derive new values to sort by.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((8, 5, 0, 8), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        8
    b        5
    c        0
    d        8
    <<U1>    <int64>
    >>> s.sort_values()
    <Series>
    <Index>
    c        0
    b        5
    a        8
    d        8
    <<U1>    <int64>
    >>> s.sort_values(ascending=False)
    <Series>
    <Index>
    d        8
    a        8
    b        5
    c        0
    <<U1>    <int64>

    ```

Series.std(*\**, *axis=0*, *skipna=True*, *ddof=0*, *out=None*)[](#static_frame.Series.std "Link to this definition")
:   Return the standard deviaton along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> s.std()
    3.39934634239519

    ```

Series.sum(*\**, *axis=0*, *skipna=True*, *allna=0*, *out=None*)[](#static_frame.Series.sum "Link to this definition")
:   Sum values along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> s.sum()
    20

    ```

Series.tail(*count=5*, */*)[[source]](../_modules/static_frame/core/series.html#Series.tail)[](#static_frame.Series.tail "Link to this definition")
:   Return a [`Series`](series-selector.html#Series "Series") consisting only of the bottom elements as specified by `count`.
    :   s

    Parameters:
    :   **count** – Number of elements to be returned from the bottom of the [`Series`](series-selector.html#Series "Series")

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((10.235, 2.124, np.nan, 8.734, np.nan), index=('a', 'b', 'c', 'd', 'e'))
    >>> s
    <Series>
    <Index>
    a        10.235
    b        2.124
    c        nan
    d        8.734
    e        nan
    <<U1>    <float64>
    >>> s.tail(2)
    <Series>
    <Index>
    d        8.734
    e        nan
    <<U1>    <float64>

    ```

Series.transpose()[[source]](../_modules/static_frame/core/series.html#Series.transpose)[](#static_frame.Series.transpose "Link to this definition")
:   Transpose. For a 1D immutable container, this returns a reference to self.

    Returns:
    :   [`Series`](series-selector.html#Series "Series")

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> s.transpose()
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>

    ```

Series.unique()[[source]](../_modules/static_frame/core/series.html#Series.unique)[](#static_frame.Series.unique "Link to this definition")
:   Return a NumPy array of unique values.

    Returns:
    :   `numpy.ndarray`

    ```
    >>> s = sf.Series((8, 5, None, 8), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        8
    b        5
    c        None
    d        8
    <<U1>    <object>
    >>> s.unique()
    [8 5 None]

    ```

Series.unique\_enumerated(*\**, *retain\_order=False*, *func=None*)[[source]](../_modules/static_frame/core/series.html#Series.unique_enumerated)[](#static_frame.Series.unique_enumerated "Link to this definition")
:   Given a collection of values, return two NumPy arrays: the first provides index positions for lookup of observed values; the second provides those observed, unique, values. Sometimes called “factorize”.

    > Args:
    > :   retain\_order: Boolean. If True, observed order is retained. If False, order may be sorted or observed, depending on the dtype and values. Retaining order may decrease performance.
    >     func: A callable that takes an element and returns a Boolean if that element should be treated as missing, excluded from the unique value collection, and given a -1 indexer position. The NumPy function np.isnan or the StaticFrame sf.isna\_element are examples of suitable functions.

    ```
    >>> s = sf.Series((8, 5, None, 8), index=('a', 'b', 'c', 'd'))
    >>> s
    <Series>
    <Index>
    a        8
    b        5
    c        None
    d        8
    <<U1>    <object>
    >>> s.unique_enumerated()
    (array([0, 1, 2, 0]), array([8, 5, None], dtype=object))

    ```

Series.var(*\**, *axis=0*, *skipna=True*, *ddof=0*, *out=None*)[](#static_frame.Series.var "Link to this definition")
:   Return the variance along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'))
    >>> s
    <Series>
    <Index>
    a        10
    b        2
    c        8
    <<U1>    <int64>
    >>> s.var()
    11.555555555555557

    ```

[Series](series.html#api-detail-series): [Constructor](series-constructor.html#api-detail-series-constructor) | [Exporter](series-exporter.html#api-detail-series-exporter) | [Attribute](series-attribute.html#api-detail-series-attribute) | [Method](#api-detail-series-method) | [Dictionary-Like](series-dictionary_like.html#api-detail-series-dictionary-like) | [Display](series-display.html#api-detail-series-display) | [Assignment](series-assignment.html#api-detail-series-assignment) | [Selector](series-selector.html#api-detail-series-selector) | [Iterator](series-iterator.html#api-detail-series-iterator) | [Operator Binary](series-operator_binary.html#api-detail-series-operator-binary) | [Operator Unary](series-operator_unary.html#api-detail-series-operator-unary) | [Accessor Values](series-accessor_values.html#api-detail-series-accessor-values) | [Accessor Datetime](series-accessor_datetime.html#api-detail-series-accessor-datetime) | [Accessor String](series-accessor_string.html#api-detail-series-accessor-string) | [Accessor Fill Value](series-accessor_fill_value.html#api-detail-series-accessor-fill-value) | [Accessor Regular Expression](series-accessor_regular_expression.html#api-detail-series-accessor-regular-expression) | [Accessor Hashlib](series-accessor_hashlib.html#api-detail-series-accessor-hashlib) | [Accessor Type Clinic](series-accessor_type_clinic.html#api-detail-series-accessor-type-clinic) | Accessor Mapping

[Previous](series-attribute.html "Detail: Series: Attribute")
[Next](series-dictionary_like.html "Detail: Series: Dictionary-Like")

---

© Copyright 2025, Christopher Ariza.
Last updated on Apr 29, 2025.

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme)
provided by [Read the Docs](https://readthedocs.org).