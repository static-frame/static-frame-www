[![Logo](../_static/sf-logo-web_icon-small.png)](../index.md)

Quick Start

* [static-frame](../readme.md)
* [License](../license.md)

Introduction

* [About StaticFrame](../intro.md)
* [Media](../intro.md#media)
* [What is New in StaticFrame](../new.md)
* [Contributing](../contributing.md)

Articles

* [Improving Code Quality with Array and DataFrame Type Hints](../articles/guard.md)
* [Type-Hinting DataFrames for Static Analysis and Runtime Validation](../articles/ftyping.md)
* [Faster DataFrame Serialization](../articles/serialize.md)
* [The Performance Advantage of No-Copy DataFrame Operations](../articles/no_copy.md)
* [Memoizing DataFrame Functions: Using Hashable DataFrames and Message Digests to Optimize Repeated Calculations](../articles/hash.md)
* [Using Higher-Order Containers to Efficiently Process 7,163 (or More) DataFrames](../articles/uhoc.md)
* [One Fill Value Is Not Enough: Preserving Columnar Types When Reindexing DataFrames](../articles/fill_value.md)
* [Ten Reasons to Use StaticFrame Instead of Pandas](../articles/upgrade.md)
* [Boring Indices & Where to Find Them: The Auto-Incremented Integer Index in StaticFrame](../articles/aiii.md)

API Overview

* [Overview: Series](../api_overview/series.md)
* [Overview: SeriesHE](../api_overview/series_he.md)
* [Overview: Frame](../api_overview/frame.md)
* [Overview: FrameGO](../api_overview/frame_go.md)
* [Overview: FrameHE](../api_overview/frame_he.md)
* [Overview: Bus](../api_overview/bus.md)
* [Overview: Batch](../api_overview/batch.md)
* [Overview: Yarn](../api_overview/yarn.md)
* [Overview: Quilt](../api_overview/quilt.md)
* [Overview: Index](../api_overview/index.md)
* [Overview: IndexGO](../api_overview/index_go.md)
* [Overview: IndexHierarchy](../api_overview/index_hierarchy.md)
* [Overview: IndexHierarchyGO](../api_overview/index_hierarchy_go.md)
* [Overview: IndexYear](../api_overview/index_year.md)
* [Overview: IndexYearGO](../api_overview/index_year_go.md)
* [Overview: IndexYearMonth](../api_overview/index_year_month.md)
* [Overview: IndexYearMonthGO](../api_overview/index_year_month_go.md)
* [Overview: IndexDate](../api_overview/index_date.md)
* [Overview: IndexDateGO](../api_overview/index_date_go.md)
* [Overview: IndexMinute](../api_overview/index_minute.md)
* [Overview: IndexMinuteGO](../api_overview/index_minute_go.md)
* [Overview: IndexHour](../api_overview/index_hour.md)
* [Overview: IndexHourGO](../api_overview/index_hour_go.md)
* [Overview: IndexSecond](../api_overview/index_second.md)
* [Overview: IndexSecondGO](../api_overview/index_second_go.md)
* [Overview: IndexMillisecond](../api_overview/index_millisecond.md)
* [Overview: IndexMillisecondGO](../api_overview/index_millisecond_go.md)
* [Overview: IndexMicrosecond](../api_overview/index_microsecond.md)
* [Overview: IndexMicrosecondGO](../api_overview/index_microsecond_go.md)
* [Overview: IndexNanosecond](../api_overview/index_nanosecond.md)
* [Overview: IndexNanosecondGO](../api_overview/index_nanosecond_go.md)
* [Overview: HLoc](../api_overview/hloc.md)
* [Overview: ILoc](../api_overview/iloc.md)
* [Overview: TypeClinic](../api_overview/type_clinic.md)
* [Overview: CallGuard](../api_overview/call_guard.md)
* [Overview: ClinicResult](../api_overview/clinic_result.md)
* [Overview: Require](../api_overview/require.md)
* [Overview: WWW](../api_overview/www.md)
* [Overview: FillValueAuto](../api_overview/fill_value_auto.md)
* [Overview: DisplayActive](../api_overview/display_active.md)
* [Overview: DisplayConfig](../api_overview/display_config.md)
* [Overview: StoreConfig](../api_overview/store_config.md)
* [Overview: StoreFilter](../api_overview/store_filter.md)
* [Overview: IndexAutoFactory](../api_overview/index_auto_factory.md)
* [Overview: IndexDefaultConstructorFactory](../api_overview/index_default_constructor_factory.md)
* [Overview: IndexAutoConstructorFactory](../api_overview/index_auto_constructor_factory.md)
* [Overview: NPZ](../api_overview/npz.md)
* [Overview: NPY](../api_overview/npy.md)
* [Overview: MemoryDisplay](../api_overview/memory_display.md)
* [Overview: Platform](../api_overview/platform.md)

API Detail

* [Detail: Series](series.md)
* [Detail: SeriesHE](series_he.md)
* [Detail: Frame](frame.md)
* [Detail: FrameGO](frame_go.md)
* [Detail: FrameHE](frame_he.md)
* [Detail: Bus](bus.md)
* [Detail: Batch](batch.md)
* [Detail: Yarn](yarn.md)
* [Detail: Quilt](quilt.md)
* [Detail: Index](index.md)
* [Detail: IndexGO](index_go.md)
* [Detail: IndexHierarchy](index_hierarchy.md)
* [Detail: IndexHierarchyGO](index_hierarchy_go.md)
* [Detail: IndexYear](index_year.md)
* [Detail: IndexYearGO](index_year_go.md)
* [Detail: IndexYearMonth](index_year_month.md)
* [Detail: IndexYearMonthGO](index_year_month_go.md)
* [Detail: IndexDate](index_date.md)
* [Detail: IndexDateGO](index_date_go.md)
* [Detail: IndexMinute](index_minute.md)
* [Detail: IndexMinuteGO](index_minute_go.md)
* [Detail: IndexHour](index_hour.md)
* [Detail: IndexHourGO](index_hour_go.md)
* [Detail: IndexSecond](index_second.md)
* [Detail: IndexSecondGO](index_second_go.md)
* [Detail: IndexMillisecond](index_millisecond.md)
* [Detail: IndexMillisecondGO](index_millisecond_go.md)
* [Detail: IndexMicrosecond](index_microsecond.md)
* [Detail: IndexMicrosecondGO](index_microsecond_go.md)
* [Detail: IndexNanosecond](index_nanosecond.md)
* [Detail: IndexNanosecondGO](index_nanosecond_go.md)
* [Detail: HLoc](hloc.md)
* [Detail: ILoc](iloc.md)
* [Detail: TypeClinic](type_clinic.md)
* [Detail: CallGuard](call_guard.md)
* [Detail: ClinicResult](clinic_result.md)
* [Detail: Require](require.md)
* [Detail: WWW](www.md)
* [Detail: FillValueAuto](fill_value_auto.md)
* [Detail: DisplayActive](display_active.md)
* [Detail: DisplayConfig](display_config.md)
* [Detail: StoreConfig](store_config.md)
* [Detail: StoreFilter](store_filter.md)
* [Detail: IndexAutoFactory](index_auto_factory.md)
* [Detail: IndexDefaultConstructorFactory](index_default_constructor_factory.md)
* [Detail: IndexAutoConstructorFactory](index_auto_constructor_factory.md)
* [Detail: NPZ](npz.md)
* [Detail: NPY](npy.md)
* [Detail: MemoryDisplay](memory_display.md)
* [Detail: Platform](platform.md)

[StaticFrame](../index.md)

* Detail: FrameGO: Exporter
* [View page source](../_sources/api_detail/frame_go-exporter.rst.txt)

[Previous](frame_go-constructor.md "Detail: FrameGO: Constructor")
[Next](frame_go-attribute.md "Detail: FrameGO: Attribute")

---

# Detail: FrameGO: Exporter[](#detail-framego-exporter "Link to this heading")

[Overview: FrameGO: Exporter](../api_overview/frame_go-exporter.md#api-overview-framego-exporter)

FrameGO.to\_arrow(*\**, *include\_index=True*, *include\_index\_name=True*, *include\_columns=True*, *include\_columns\_name=False*)[](#static_frame.FrameGO.to_arrow "Link to this definition")
:   Return a `pyarrow.Table` from this [`Frame`](frame-selector.md#Frame "Frame").

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), ('qrs ', 'XYZ', '123', ' wX ')), columns=('a', 'b'), index=('p', 'q', 'r', 's'), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> f.to_arrow()
    pyarrow.Table
    __index0__: string
    a: int64
    b: string
    ----
    __index0__: [["p","q","r","s"]]
    a: [[10,2,8,3]]
    b: [["qrs ","XYZ","123"," wX "]]

    ```

FrameGO.to\_clipboard(*\**, *delimiter='\t'*, *include\_index=True*, *include\_index\_name=True*, *include\_columns=True*, *include\_columns\_name=False*, *encoding=None*, *line\_terminator='\n'*, *quote\_char='"'*, *quote\_double=True*, *escape\_char=None*, *quoting=0*, *store\_filter=<static\_frame.core.store\_filter.StoreFilter object>*)[](#static_frame.FrameGO.to_clipboard "Link to this definition")
:   Given a file path or file-like object, write the [`Frame`](frame-selector.md#Frame "Frame") as delimited text. The `delimiter` defaults to a tab.

    Parameters:
    :   * **path** (*A file*) –
        * **instance** (*PathLib*) –
        * **object.** (*or file-like*) –
        * **\*** –
        * **delimiter** – Character to be used for delimiterarating elements.
        * **include\_index** – If True, the index will be written.
        * **include\_index\_name** – If including columns, populate the row above the index with the index `name`. Cannot be True if `include_columns_name` is `True`.
        * **include\_columns** – If `True`, the columns will be written.
        * **include\_columns\_name** – If including index, populate the column to the left of the columns with the columns `name`. Cannot be True if `include_index_name` is True.
        * **encoding** – Encoding type to be used when opening the file.
        * **line\_terminator** – The string used to terminate lines.
        * **quote\_char** – A one-character string used to quote fields containing special characters, such as the `delimiter` or `quote_char`, or which contain new-line characters.
        * **quote\_double** – Controls how instances of quote\_char appearing inside a field should themselves be quoted. When `True`, the character is doubled. When `False`, the `escape_char` is used as a prefix to the `quote_char`. It defaults to True.
        * **escape\_char** – A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE\_NONE and the quotechar if quote\_double is False.
        * **quoting** – Controls when quotes should be generated. It can take on any of the QUOTE\_\* constants from the standard library csv module.
        * **store\_filter** – A [`StoreFilter`](store_filter.md#static_frame.StoreFilter "static_frame.StoreFilter") instance.

FrameGO.to\_csv(*fp*, */*, *\**, *include\_index=True*, *include\_index\_name=True*, *include\_columns=True*, *include\_columns\_name=False*, *encoding=None*, *line\_terminator='\n'*, *quoting=0*, *quote\_char='"'*, *quote\_double=True*, *escape\_char=None*, *store\_filter=<static\_frame.core.store\_filter.StoreFilter object>*)[](#static_frame.FrameGO.to_csv "Link to this definition")
:   Given a file path or file-like object, write the [`Frame`](frame-selector.md#Frame "Frame") as delimited text. The delimiter is set to a comma.

    Parameters:
    :   * **path** (*A file*) –
        * **instance** (*PathLib*) –
        * **object.** (*or file-like*) –
        * **\*** –
        * **include\_index** – If True, the index will be written.
        * **include\_index\_name** – If including columns, populate the row above the index with the index `name`. Cannot be True if `include_columns_name` is `True`.
        * **include\_columns** – If `True`, the columns will be written.
        * **include\_columns\_name** – If including index, populate the column to the left of the columns with the columns `name`. Cannot be True if `include_index_name` is True.
        * **encoding** – Encoding type to be used when opening the file.
        * **line\_terminator** – The string used to terminate lines.
        * **quote\_char** – A one-character string used to quote fields containing special characters, such as the `delimiter` or `quote_char`, or which contain new-line characters.
        * **quote\_double** – Controls how instances of quote\_char appearing inside a field should themselves be quoted. When `True`, the character is doubled. When `False`, the `escape_char` is used as a prefix to the `quote_char`. It defaults to True.
        * **escape\_char** – A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE\_NONE and the quotechar if quote\_double is False.
        * **quoting** – Controls when quotes should be generated. It can take on any of the QUOTE\_\* constants from the standard library csv module.
        * **store\_filter** – A [`StoreFilter`](store_filter.md#static_frame.StoreFilter "static_frame.StoreFilter") instance.

    ```
    >>> f1 = sf.FrameGO(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b       <<U1>
    <Index>
    p            0       1
    q            2       3
    r            4       5
    <<U1>        <int64> <int64>
    >>> f1.to_csv('/tmp/f.csv')
    >>> from pathlib import Path
    >>> Path('/tmp/f.csv').read_text()
    __index0__,a,b
    p,0,1
    q,2,3
    r,4,5

    ```

FrameGO.to\_delimited(*fp*, */*, *\**, *delimiter*, *include\_index=True*, *include\_index\_name=True*, *include\_columns=True*, *include\_columns\_name=False*, *encoding=None*, *line\_terminator='\n'*, *quote\_char='"'*, *quote\_double=True*, *escape\_char=None*, *quoting=0*, *store\_filter=<static\_frame.core.store\_filter.StoreFilter object>*)[](#static_frame.FrameGO.to_delimited "Link to this definition")
:   Given a file path or file-like object, write the [`Frame`](frame-selector.md#Frame "Frame") as delimited text. A `delimiter` character must be specified.

    Parameters:
    :   * **path** (*A file*) –
        * **instance** (*PathLib*) –
        * **object.** (*or file-like*) –
        * **\*** –
        * **delimiter** – Character to be used for delimiterarating elements.
        * **include\_index** – If True, the index will be written.
        * **include\_index\_name** – If including columns, populate the row above the index with the index `name`. Cannot be True if `include_columns_name` is `True`.
        * **include\_columns** – If `True`, the columns will be written.
        * **include\_columns\_name** – If including index, populate the column to the left of the columns with the columns `name`. Cannot be True if `include_index_name` is True.
        * **encoding** – Encoding type to be used when opening the file.
        * **line\_terminator** – The string used to terminate lines.
        * **quote\_char** – A one-character string used to quote fields containing special characters, such as the `delimiter` or `quote_char`, or which contain new-line characters.
        * **quote\_double** – Controls how instances of quote\_char appearing inside a field should themselves be quoted. When `True`, the character is doubled. When `False`, the `escape_char` is used as a prefix to the `quote_char`. It defaults to True.
        * **escape\_char** – A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE\_NONE and the quotechar if quote\_double is False.
        * **quoting** – Controls when quotes should be generated. It can take on any of the QUOTE\_\* constants from the standard library csv module.
        * **store\_filter** – A [`StoreFilter`](store_filter.md#static_frame.StoreFilter "static_frame.StoreFilter") instance.

    ```
    >>> f1 = sf.FrameGO(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b       <<U1>
    <Index>
    p            0       1
    q            2       3
    r            4       5
    <<U1>        <int64> <int64>
    >>> f1.to_delimited('/tmp/f.psv', delimiter='|')
    >>> from pathlib import Path
    >>> Path('/tmp/f.psv').read_text()
    __index0__|a|b
    p|0|1
    q|2|3
    r|4|5

    ```

FrameGO.to\_frame(*\**, *name=<object object>*)[](#static_frame.FrameGO.to_frame "Link to this definition")
:   Return `Frame` instance from this `Frame`. If this `Frame` is immutable the same instance will be returned.

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), ('qrs ', 'XYZ', '123', ' wX ')), columns=('a', 'b'), index=('p', 'q', 'r', 's'), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> f.to_frame()
    <Frame: x>
    <Index>    a       b     <<U1>
    <Index>
    p          10      qrs
    q          2       XYZ
    r          8       123
    s          3        wX
    <<U1>      <int64> <<U4>

    ```

FrameGO.to\_frame\_go(*\**, *name=<object object>*)[](#static_frame.FrameGO.to_frame_go "Link to this definition")
:   Return a `FrameGO` instance from this `Frame`.

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), ('qrs ', 'XYZ', '123', ' wX ')), columns=('a', 'b'), index=('p', 'q', 'r', 's'), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> f.to_frame_go()
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>

    ```

FrameGO.to\_frame\_he(*\**, *name=<object object>*)[](#static_frame.FrameGO.to_frame_he "Link to this definition")
:   Return a `FrameHE` instance from this `Frame`. If this `Frame` is immutable the same instance will be returned.

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), ('qrs ', 'XYZ', '123', ' wX ')), columns=('a', 'b'), index=('p', 'q', 'r', 's'), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> f.to_frame_he()
    <FrameHE: x>
    <Index>      a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>

    ```

FrameGO.to\_html(*config=None*, */*, *\**, *style\_config=<static\_frame.core.style\_config.StyleConfig object>*)[](#static_frame.FrameGO.to_html "Link to this definition")
:   Return an HTML table representation of this [`Frame`](frame-selector.md#Frame "Frame") using standard TABLE, TR, and TD tags. This is not a complete HTML page.

    Parameters:
    :   **config** – Optional [`DisplayConfig`](display_config.md#static_frame.DisplayConfig "static_frame.DisplayConfig") instance.

    Returns:
    :   `str`

FrameGO.to\_html\_datatables(*fp=None*, */*, *\**, *show=True*, *config=None*)[](#static_frame.FrameGO.to_html_datatables "Link to this definition")
:   Return a complete HTML representation of this [`Frame`](frame-selector.md#Frame "Frame") using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection.

    Parameters:
    :   * **fp** – optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file.
        * **show** – if True, the file will be opened with a webbrowser.
        * **config** – Optional [`DisplayConfig`](display_config.md#static_frame.DisplayConfig "static_frame.DisplayConfig") instance.

    Returns:
    :   `str`, absolute file path to the file written.

FrameGO.to\_json\_columns(*\**, *indent=None*)[](#static_frame.FrameGO.to_json_columns "Link to this definition")
:   Export a [`Frame`](frame-selector.md#Frame "Frame") as a JSON string constructed as follows: A JSON object keyed by column labels, where values are columns represented by an object mapping of index labels to values.

    Parameters:
    :   **indent** – If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> f.to_json_columns(indent=4)
    {
        "a": {
            "0": 10,
            "1": 2,
            "2": 8,
            "3": 3
        },
        "b": {
            "0": false,
            "1": true,
            "2": true,
            "3": false
        },
        "c": {
            "0": "1517-01-01",
            "1": "1517-04-01",
            "2": "1517-12-31",
            "3": "1517-06-30"
        }
    }

    ```

FrameGO.to\_json\_index(*\**, *indent=None*)[](#static_frame.FrameGO.to_json_index "Link to this definition")
:   Export a [`Frame`](frame-selector.md#Frame "Frame") as a JSON string constructed as follows: A JSON object keyed by index labels, where values are rows represented by an object mapping of column labels to values.

    Parameters:
    :   **indent** – If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> f.to_json_index(indent=4)
    {
        "0": {
            "a": 10,
            "b": false,
            "c": "1517-01-01"
        },
        "1": {
            "a": 2,
            "b": true,
            "c": "1517-04-01"
        },
        "2": {
            "a": 8,
            "b": true,
            "c": "1517-12-31"
        },
        "3": {
            "a": 3,
            "b": false,
            "c": "1517-06-30"
        }
    }

    ```

FrameGO.to\_json\_records(*\**, *indent=None*)[](#static_frame.FrameGO.to_json_records "Link to this definition")
:   Export a [`Frame`](frame-selector.md#Frame "Frame") as a JSON string constructed as follows: A JSON array of row objects, where column labels are repeated for each row, and no index labels are included.

    Parameters:
    :   **indent** – If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> f.to_json_records(indent=4)
    [
        {
            "a": 10,
            "b": false,
            "c": "1517-01-01"
        },
        {
            "a": 2,
            "b": true,
            "c": "1517-04-01"
        },
        {
            "a": 8,
            "b": true,
            "c": "1517-12-31"
        },
        {
            "a": 3,
            "b": false,
            "c": "1517-06-30"
        }
    ]

    ```

FrameGO.to\_json\_split(*\**, *indent=None*)[](#static_frame.FrameGO.to_json_split "Link to this definition")
:   Export a [`Frame`](frame-selector.md#Frame "Frame") as a JSON string constructed as follows: A JSON object with a key for “columns”, “index”, and “data”, where data is given as an array of arrays of row values.

    Parameters:
    :   **indent** – If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> f.to_json_split(indent=4)
    {
        "columns": [
            "a",
            "b",
            "c"
        ],
        "index": [
            0,
            1,
            2,
            3
        ],
        "data": [
            [
                10,
                false,
                "1517-01-01"
            ],
            [
                2,
                true,
                "1517-04-01"
            ],
            [
                8,
                true,
                "1517-12-31"
            ],
            [
                3,
                false,
                "1517-06-30"
            ]
        ]
    }

    ```

FrameGO.to\_json\_typed(*\**, *indent=None*)[](#static_frame.FrameGO.to_json_typed "Link to this definition")
:   Export a [`Frame`](frame-selector.md#Frame "Frame") as a JSON string constructed as follows: A JSON object with a key for “columns”, “index”, and “data”, where data is given as an array of arrays of column values; additionally, a key for “\_\_meta\_\_” defines an object with complete metadata and typing information.

    Parameters:
    :   **indent** – If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> f.to_json_typed(indent=4)
    {
        "columns": [
            "a",
            "b",
            "c"
        ],
        "index": null,
        "data": [
            [
                10,
                2,
                8,
                3
            ],
            [
                false,
                true,
                true,
                false
            ],
            [
                "1517-01-01",
                "1517-04-01",
                "1517-12-31",
                "1517-06-30"
            ]
        ],
        "__meta__": {
            "__names__": [
                "x",
                null,
                null
            ],
            "__dtypes__": [
                "=i8",
                "|b1",
                "=M8[D]"
            ],
            "__dtypes_index__": [
                "=i8"
            ],
            "__dtypes_columns__": [
                "=U1"
            ],
            "__types__": [
                "Index",
                "IndexGO"
            ],
            "__depths__": [
                3,
                1,
                1
            ]
        }
    }

    ```

FrameGO.to\_json\_values(*\**, *indent=None*)[](#static_frame.FrameGO.to_json_values "Link to this definition")
:   Export a [`Frame`](frame-selector.md#Frame "Frame") as a JSON string constructed as follows: A JSON array of arrays of row values; no index or columns labels are included.

    Parameters:
    :   **indent** – If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> f.to_json_values(indent=4)
    [
        [
            10,
            false,
            "1517-01-01"
        ],
        [
            2,
            true,
            "1517-04-01"
        ],
        [
            8,
            true,
            "1517-12-31"
        ],
        [
            3,
            false,
            "1517-06-30"
        ]
    ]

    ```

FrameGO.to\_latex(*config=None*, */*)[](#static_frame.FrameGO.to_latex "Link to this definition")
:   Display the Frame as a LaTeX formatted table.

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), ('qrs ', 'XYZ', '123', ' wX ')), columns=('a', 'b'), index=('p', 'q', 'r', 's'), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> f.to_latex()
    \begin{table}[ht]
    \centering
    \begin{tabular}{c c c}
    \hline\hline
       & a   & b    \\
    \hline
    p  & 10  & qrs  \\
    q  & 2   & XYZ  \\
    r  & 8   & 123  \\
    s  & 3   &  wX  \\
    \hline\end{tabular}
    \end{table}

    ```

FrameGO.to\_markdown(*config=None*, */*)[](#static_frame.FrameGO.to_markdown "Link to this definition")
:   Display the Frame as a Markdown formatted table.

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), ('qrs ', 'XYZ', '123', ' wX ')), columns=('a', 'b'), index=('p', 'q', 'r', 's'), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> f.to_markdown()
    |  |a  |b   |
    |--|---|----|
    |p |10 |qrs |
    |q |2  |XYZ |
    |r |8  |123 |
    |s |3  | wX |

    ```

FrameGO.to\_npy(*fp*, */*, *\**, *include\_index=True*, *include\_columns=True*, *consolidate\_blocks=False*)[](#static_frame.FrameGO.to_npy "Link to this definition")
:   Write a [`Frame`](frame-selector.md#Frame "Frame") as a directory of npy file.

    ```
    >>> f1 = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> f1.to_npy('/tmp/f.npy')
    >>> sf.Frame.from_npy('/tmp/f.npy')
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    0          10      False  1517-01-01
    1          2       True   1517-04-01
    2          8       True   1517-12-31
    3          3       False  1517-06-30
    <int64>    <int64> <bool> <datetime64[D]>
    >>> import shutil
    >>> shutil.rmtree('/tmp/f.npy')

    ```

FrameGO.to\_npz(*fp*, */*, *\**, *include\_index=True*, *include\_columns=True*, *consolidate\_blocks=False*)[](#static_frame.FrameGO.to_npz "Link to this definition")
:   Write a [`Frame`](frame-selector.md#Frame "Frame") as an npz file.

    ```
    >>> f1 = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> f1.to_npz('/tmp/f.npz')
    >>> sf.Frame.from_npz('/tmp/f.npz')
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    0          10      False  1517-01-01
    1          2       True   1517-04-01
    2          8       True   1517-12-31
    3          3       False  1517-06-30
    <int64>    <int64> <bool> <datetime64[D]>

    ```

FrameGO.to\_pairs(*\**, *axis=0*)[](#static_frame.FrameGO.to_pairs "Link to this definition")
:   Return a tuple of major axis key, minor axis key vlaue pairs, where major axis is determined by the axis argument. Note that the returned object is eagerly constructed; use an iterator interface for lazy iteration.

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), ('qrs ', 'XYZ', '123', ' wX ')), columns=('a', 'b'), index=('p', 'q', 'r', 's'), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> f.to_pairs()
    ((np.str_('a'), ((np.str_('p'), np.int64(10)), (np.str_('q'), np.int64(2)), (np.str_('r'), np.int64(8)), (np.str_('s'), np.int64(3)))), (np.str_('b'), ((np.str_('p'), np.str_('qrs ')), (np.str_('q'), np.str_('XYZ')), (np.str_('r'), np.str_('123')), (np.str_('s'), np.str_(' wX ')))))

    ```

FrameGO.to\_pandas()[](#static_frame.FrameGO.to_pandas "Link to this definition")
:   Return a Pandas DataFrame.

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), ('qrs ', 'XYZ', '123', ' wX ')), columns=('a', 'b'), index=('p', 'q', 'r', 's'), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> f.to_pandas()
        a     b
    p  10  qrs
    q   2   XYZ
    r   8   123
    s   3   wX

    ```

FrameGO.to\_parquet(*fp*, */*, *\**, *include\_index=True*, *include\_index\_name=True*, *include\_columns=True*, *include\_columns\_name=False*)[](#static_frame.FrameGO.to_parquet "Link to this definition")
:   Write an Arrow Parquet binary file.

    ```
    >>> f1 = sf.FrameGO(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b       <<U1>
    <Index>
    p            0       1
    q            2       3
    r            4       5
    <<U1>        <int64> <int64>
    >>> f1.to_parquet('/tmp/f.parquet')

    ```

FrameGO.to\_pickle(*fp*, */*, *\**, *protocol=None*)[](#static_frame.FrameGO.to_pickle "Link to this definition")
:   Write a [`Frame`](frame-selector.md#Frame "Frame") as a Python pickle.

    The pickle module is not secure. Only unpickle data you trust.

    Parameters:
    :   * **fp** – file path to write.
        * **protocol** – Pickle protocol to use.

    ```
    >>> f1 = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> f1.to_pickle('/tmp/f.pickle')
    >>> sf.Frame.from_pickle('/tmp/f.pickle')
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    0          10      False  1517-01-01
    1          2       True   1517-04-01
    2          8       True   1517-12-31
    3          3       False  1517-06-30
    <int64>    <int64> <bool> <datetime64[D]>

    ```

FrameGO.to\_rst(*config=None*, */*)[](#static_frame.FrameGO.to_rst "Link to this definition")
:   Display the Frame as an RST formatted table.

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), ('qrs ', 'XYZ', '123', ' wX ')), columns=('a', 'b'), index=('p', 'q', 'r', 's'), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> f.to_rst()
    +--+---+----+
    |  |a  |b   |
    +==+===+====+
    |p |10 |qrs |
    +--+---+----+
    |q |2  |XYZ |
    +--+---+----+
    |r |8  |123 |
    +--+---+----+
    |s |3  | wX |
    +--+---+----+

    ```

FrameGO.to\_series(*\**, *index\_constructor=<class 'static\_frame.core.index.Index'>*, *name=<object object>*)[](#static_frame.FrameGO.to_series "Link to this definition")
:   Return a `Series` representation of this `Frame`, where the index is extended with columns to from tuple labels for each element in the `Frame`.

    Parameters:
    :   **index\_constructor** – Index constructor of the tuples produced by combining index and columns into one label. Providing `IndexHierarchy.from_labels` will produce a hierarchical index.

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), ('qrs ', 'XYZ', '123', ' wX ')), columns=('a', 'b'), index=('p', 'q', 'r', 's'), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> f.to_series()
    <Series: x>
    <Index>
    (np.str_('p'), np.str_('a')) 10
    (np.str_('p'), np.str_('b')) qrs
    (np.str_('q'), np.str_('a')) 2
    (np.str_('q'), np.str_('b')) XYZ
    (np.str_('r'), np.str_('a')) 8
    (np.str_('r'), np.str_('b')) 123
    (np.str_('s'), np.str_('a')) 3
    (np.str_('s'), np.str_('b'))  wX
    <object>                     <object>

    ```

FrameGO.to\_sql(*connection*, */*, *\**, *label=<object object>*, *include\_index=True*, *schema=''*, *placeholder=''*, *dtype\_to\_type\_decl=None*)[](#static_frame.FrameGO.to_sql "Link to this definition")
:   Write Frame to the database provided by connection. Connections to SQLite, PostgreSQL, MySQL, and MariaDB are fully supported. The table name can be provided by label, otherwise Frame.name will be used. If the target table does not exist, it will be created using optimal mappings to NumPy dtypes. If the target table exists, records will be appended. Parameterized insert queries are always used. Records will never be deleted, nor tables dropped.

    If using SQLAlchemy, pass the underlying DBAPI connection object (via the sqlalchemy.engine.Connection.connection attribute) as the conection.

    Parameters:
    :   * **label** – Provide a name for the table; if not provided, Frame.name will be used if not None, else an exception will be raised.
        * **include\_index** – If True, the index will be included.
        * **schema** – If provided, this string will be used as a database schema label to prefix the table name in all SQL queries.
        * **placeholder** – String used as a placeholder in parameterized insert queries. Correct defaults are provided for SQLite, PostgreSQL, MySQL, and MariaDB.
        * **dtype\_to\_type\_decl** – Mapping from NumPy dtype to a string to be used in type declaration when creating tables. Sensible defaults are provided for SQLite, PostgreSQL, MySQL, and MariaDB.

    ```
    >>> import sqlite3
    >>> conn = sqlite3.connect(':memory')
    >>> f1 = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f1.to_sql(conn, include_index=False)
    >>> sf.Frame.from_sql("select * from x", connection=conn)
    <Frame>
    <Index> a       b       c          <<U1>
    <Index>
    0       10      0       1517-01-01
    1       2       1       1517-04-01
    2       8       1       1517-12-31
    3       3       0       1517-06-30
    <int64> <int64> <int64> <<U10>

    ```

FrameGO.to\_sqlite(*fp*, */*, *\**, *label=<object object>*, *include\_index=True*, *include\_columns=True*)[](#static_frame.FrameGO.to_sqlite "Link to this definition")
:   Write the Frame as single-table SQLite file.

    ```
    >>> f1 = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> f1.to_sqlite('/tmp/f.db')
    >>> import sqlite3
    >>> conn = sqlite3.connect('/tmp/f.db')
    >>> sf.Frame.from_sql("select * from x limit 2", connection=conn, index_depth=1)
    <Frame>
    <Index> a       b       c          <<U1>
    <Index>
    0       10      0       1517-01-01
    1       2       1       1517-04-01
    <int64> <int64> <int64> <<U10>

    ```

FrameGO.to\_tsv(*fp*, */*, *\**, *include\_index=True*, *include\_index\_name=True*, *include\_columns=True*, *include\_columns\_name=False*, *encoding=None*, *line\_terminator='\n'*, *quote\_char='"'*, *quote\_double=True*, *escape\_char=None*, *quoting=0*, *store\_filter=<static\_frame.core.store\_filter.StoreFilter object>*)[](#static_frame.FrameGO.to_tsv "Link to this definition")
:   Given a file path or file-like object, write the [`Frame`](frame-selector.md#Frame "Frame") as delimited text. The delimiter is set to a tab.

    Parameters:
    :   * **path** (*A file*) –
        * **instance** (*PathLib*) –
        * **object.** (*or file-like*) –
        * **\*** –
        * **include\_index** – If True, the index will be written.
        * **include\_index\_name** – If including columns, populate the row above the index with the index `name`. Cannot be True if `include_columns_name` is `True`.
        * **include\_columns** – If `True`, the columns will be written.
        * **include\_columns\_name** – If including index, populate the column to the left of the columns with the columns `name`. Cannot be True if `include_index_name` is True.
        * **encoding** – Encoding type to be used when opening the file.
        * **line\_terminator** – The string used to terminate lines.
        * **quote\_char** – A one-character string used to quote fields containing special characters, such as the `delimiter` or `quote_char`, or which contain new-line characters.
        * **quote\_double** – Controls how instances of quote\_char appearing inside a field should themselves be quoted. When `True`, the character is doubled. When `False`, the `escape_char` is used as a prefix to the `quote_char`. It defaults to True.
        * **escape\_char** – A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE\_NONE and the quotechar if quote\_double is False.
        * **quoting** – Controls when quotes should be generated. It can take on any of the QUOTE\_\* constants from the standard library csv module.
        * **store\_filter** – A [`StoreFilter`](store_filter.md#static_frame.StoreFilter "static_frame.StoreFilter") instance.

    ```
    >>> f1 = sf.FrameGO(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b       <<U1>
    <Index>
    p            0       1
    q            2       3
    r            4       5
    <<U1>        <int64> <int64>
    >>> f1.to_tsv('/tmp/f.tsv')
    >>> from pathlib import Path
    >>> Path('/tmp/f.tsv').read_text()
    __index0__	a	b
    p	0	1
    q	2	3
    r	4	5

    ```

FrameGO.to\_visidata()[](#static_frame.FrameGO.to_visidata "Link to this definition")
:   Open an interactive VisiData session.

FrameGO.to\_xarray()[](#static_frame.FrameGO.to_xarray "Link to this definition")
:   Return an xarray Dataset.

    In order to preserve columnar types, and following the precedent of Pandas, the [`Frame`](frame-selector.md#Frame "Frame"), with a 1D index, is translated as a Dataset of 1D arrays, where each DataArray is a 1D array. If the index is an [`IndexHierarchy`](index_hierarchy-selector.md#IndexHierarchy "IndexHierarchy"), each column is mapped into an ND array of shape equal to the unique values found at each depth of the index.

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), ('qrs ', 'XYZ', '123', ' wX ')), columns=('a', 'b'), index=('p', 'q', 'r', 's'), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> f.to_xarray()
    <xarray.Dataset> Size: 112B
    Dimensions:     (__index0__: 4)
    Coordinates:
      * __index0__  (__index0__) <U1 16B 'p' 'q' 'r' 's'
    Data variables:
        a           (__index0__) int64 32B 10 2 8 3
        b           (__index0__) <U4 64B 'qrs ' 'XYZ' '123' ' wX '

    ```

FrameGO.to\_xlsx(*fp*, */*, *\**, *label=<object object>*, *include\_index=True*, *include\_index\_name=True*, *include\_columns=True*, *include\_columns\_name=False*, *merge\_hierarchical\_labels=True*, *store\_filter=<static\_frame.core.store\_filter.StoreFilter object>*)[](#static_frame.FrameGO.to_xlsx "Link to this definition")
:   Write the Frame as single-sheet XLSX file.

    ```
    >>> f1 = sf.FrameGO(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b       <<U1>
    <Index>
    p            0       1
    q            2       3
    r            4       5
    <<U1>        <int64> <int64>
    >>> f1.to_xlsx('/tmp/f.xlsx')

    ```

[FrameGO](frame_go.md#api-detail-framego): [Constructor](frame_go-constructor.md#api-detail-framego-constructor) | [Exporter](#api-detail-framego-exporter) | [Attribute](frame_go-attribute.md#api-detail-framego-attribute) | [Method](frame_go-method.md#api-detail-framego-method) | [Dictionary-Like](frame_go-dictionary_like.md#api-detail-framego-dictionary-like) | [Display](frame_go-display.md#api-detail-framego-display) | [Assignment](frame_go-assignment.md#api-detail-framego-assignment) | [Selector](frame_go-selector.md#api-detail-framego-selector) | [Iterator](frame_go-iterator.md#api-detail-framego-iterator) | [Operator Binary](frame_go-operator_binary.md#api-detail-framego-operator-binary) | [Operator Unary](frame_go-operator_unary.md#api-detail-framego-operator-unary) | [Accessor Values](frame_go-accessor_values.md#api-detail-framego-accessor-values) | [Accessor Datetime](frame_go-accessor_datetime.md#api-detail-framego-accessor-datetime) | [Accessor String](frame_go-accessor_string.md#api-detail-framego-accessor-string) | [Accessor Transpose](frame_go-accessor_transpose.md#api-detail-framego-accessor-transpose) | [Accessor Fill Value](frame_go-accessor_fill_value.md#api-detail-framego-accessor-fill-value) | [Accessor Regular Expression](frame_go-accessor_regular_expression.md#api-detail-framego-accessor-regular-expression) | [Accessor Hashlib](frame_go-accessor_hashlib.md#api-detail-framego-accessor-hashlib) | [Accessor Type Clinic](frame_go-accessor_type_clinic.md#api-detail-framego-accessor-type-clinic) | [Accessor Reduce](frame_go-accessor_reduce.md#api-detail-framego-accessor-reduce)

[Previous](frame_go-constructor.md "Detail: FrameGO: Constructor")
[Next](frame_go-attribute.md "Detail: FrameGO: Attribute")

---

© Copyright 2025, Christopher Ariza.
Last updated on Apr 29, 2025.

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme)
provided by [Read the Docs](https://readthedocs.org).