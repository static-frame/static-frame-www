[![Logo](../_static/sf-logo-web_icon-small.png)](../index.md)

Quick Start

* [static-frame](../readme.md)
* [License](../license.md)

Introduction

* [About StaticFrame](../intro.md)
* [Media](../intro.md#media)
* [What is New in StaticFrame](../new.md)
* [Contributing](../contributing.md)

Articles

* [Improving Code Quality with Array and DataFrame Type Hints](../articles/guard.md)
* [Type-Hinting DataFrames for Static Analysis and Runtime Validation](../articles/ftyping.md)
* [Faster DataFrame Serialization](../articles/serialize.md)
* [The Performance Advantage of No-Copy DataFrame Operations](../articles/no_copy.md)
* [Memoizing DataFrame Functions: Using Hashable DataFrames and Message Digests to Optimize Repeated Calculations](../articles/hash.md)
* [Using Higher-Order Containers to Efficiently Process 7,163 (or More) DataFrames](../articles/uhoc.md)
* [One Fill Value Is Not Enough: Preserving Columnar Types When Reindexing DataFrames](../articles/fill_value.md)
* [Ten Reasons to Use StaticFrame Instead of Pandas](../articles/upgrade.md)
* [Boring Indices & Where to Find Them: The Auto-Incremented Integer Index in StaticFrame](../articles/aiii.md)

API Overview

* [Overview: Series](../api_overview/series.md)
* [Overview: SeriesHE](../api_overview/series_he.md)
* [Overview: Frame](../api_overview/frame.md)
* [Overview: FrameGO](../api_overview/frame_go.md)
* [Overview: FrameHE](../api_overview/frame_he.md)
* [Overview: Bus](../api_overview/bus.md)
* [Overview: Batch](../api_overview/batch.md)
* [Overview: Yarn](../api_overview/yarn.md)
* [Overview: Quilt](../api_overview/quilt.md)
* [Overview: Index](../api_overview/index.md)
* [Overview: IndexGO](../api_overview/index_go.md)
* [Overview: IndexHierarchy](../api_overview/index_hierarchy.md)
* [Overview: IndexHierarchyGO](../api_overview/index_hierarchy_go.md)
* [Overview: IndexYear](../api_overview/index_year.md)
* [Overview: IndexYearGO](../api_overview/index_year_go.md)
* [Overview: IndexYearMonth](../api_overview/index_year_month.md)
* [Overview: IndexYearMonthGO](../api_overview/index_year_month_go.md)
* [Overview: IndexDate](../api_overview/index_date.md)
* [Overview: IndexDateGO](../api_overview/index_date_go.md)
* [Overview: IndexMinute](../api_overview/index_minute.md)
* [Overview: IndexMinuteGO](../api_overview/index_minute_go.md)
* [Overview: IndexHour](../api_overview/index_hour.md)
* [Overview: IndexHourGO](../api_overview/index_hour_go.md)
* [Overview: IndexSecond](../api_overview/index_second.md)
* [Overview: IndexSecondGO](../api_overview/index_second_go.md)
* [Overview: IndexMillisecond](../api_overview/index_millisecond.md)
* [Overview: IndexMillisecondGO](../api_overview/index_millisecond_go.md)
* [Overview: IndexMicrosecond](../api_overview/index_microsecond.md)
* [Overview: IndexMicrosecondGO](../api_overview/index_microsecond_go.md)
* [Overview: IndexNanosecond](../api_overview/index_nanosecond.md)
* [Overview: IndexNanosecondGO](../api_overview/index_nanosecond_go.md)
* [Overview: HLoc](../api_overview/hloc.md)
* [Overview: ILoc](../api_overview/iloc.md)
* [Overview: TypeClinic](../api_overview/type_clinic.md)
* [Overview: CallGuard](../api_overview/call_guard.md)
* [Overview: ClinicResult](../api_overview/clinic_result.md)
* [Overview: Require](../api_overview/require.md)
* [Overview: WWW](../api_overview/www.md)
* [Overview: FillValueAuto](../api_overview/fill_value_auto.md)
* [Overview: DisplayActive](../api_overview/display_active.md)
* [Overview: DisplayConfig](../api_overview/display_config.md)
* [Overview: StoreConfig](../api_overview/store_config.md)
* [Overview: StoreFilter](../api_overview/store_filter.md)
* [Overview: IndexAutoFactory](../api_overview/index_auto_factory.md)
* [Overview: IndexDefaultConstructorFactory](../api_overview/index_default_constructor_factory.md)
* [Overview: IndexAutoConstructorFactory](../api_overview/index_auto_constructor_factory.md)
* [Overview: NPZ](../api_overview/npz.md)
* [Overview: NPY](../api_overview/npy.md)
* [Overview: MemoryDisplay](../api_overview/memory_display.md)
* [Overview: Platform](../api_overview/platform.md)

API Detail

* [Detail: Series](series.md)
* [Detail: SeriesHE](series_he.md)
* [Detail: Frame](frame.md)
* [Detail: FrameGO](frame_go.md)
* [Detail: FrameHE](frame_he.md)
* [Detail: Bus](bus.md)
* [Detail: Batch](batch.md)
* [Detail: Yarn](yarn.md)
* [Detail: Quilt](quilt.md)
* [Detail: Index](index.md)
* [Detail: IndexGO](index_go.md)
* [Detail: IndexHierarchy](index_hierarchy.md)
* [Detail: IndexHierarchyGO](index_hierarchy_go.md)
* [Detail: IndexYear](index_year.md)
* [Detail: IndexYearGO](index_year_go.md)
* [Detail: IndexYearMonth](index_year_month.md)
* [Detail: IndexYearMonthGO](index_year_month_go.md)
* [Detail: IndexDate](index_date.md)
* [Detail: IndexDateGO](index_date_go.md)
* [Detail: IndexMinute](index_minute.md)
* [Detail: IndexMinuteGO](index_minute_go.md)
* [Detail: IndexHour](index_hour.md)
* [Detail: IndexHourGO](index_hour_go.md)
* [Detail: IndexSecond](index_second.md)
* [Detail: IndexSecondGO](index_second_go.md)
* [Detail: IndexMillisecond](index_millisecond.md)
* [Detail: IndexMillisecondGO](index_millisecond_go.md)
* [Detail: IndexMicrosecond](index_microsecond.md)
* [Detail: IndexMicrosecondGO](index_microsecond_go.md)
* [Detail: IndexNanosecond](index_nanosecond.md)
* [Detail: IndexNanosecondGO](index_nanosecond_go.md)
* [Detail: HLoc](hloc.md)
* [Detail: ILoc](iloc.md)
* [Detail: TypeClinic](type_clinic.md)
* [Detail: CallGuard](call_guard.md)
* [Detail: ClinicResult](clinic_result.md)
* [Detail: Require](require.md)
* [Detail: WWW](www.md)
* [Detail: FillValueAuto](fill_value_auto.md)
* [Detail: DisplayActive](display_active.md)
* [Detail: DisplayConfig](display_config.md)
* [Detail: StoreConfig](store_config.md)
* [Detail: StoreFilter](store_filter.md)
* [Detail: IndexAutoFactory](index_auto_factory.md)
* [Detail: IndexDefaultConstructorFactory](index_default_constructor_factory.md)
* [Detail: IndexAutoConstructorFactory](index_auto_constructor_factory.md)
* [Detail: NPZ](npz.md)
* [Detail: NPY](npy.md)
* [Detail: MemoryDisplay](memory_display.md)
* [Detail: Platform](platform.md)

[StaticFrame](../index.md)

* Detail: FrameGO: Constructor
* [View page source](../_sources/api_detail/frame_go-constructor.rst.txt)

[Previous](frame-accessor_reduce.md "Detail: Frame: Accessor Reduce")
[Next](frame_go-exporter.md "Detail: FrameGO: Exporter")

---

# Detail: FrameGO: Constructor[](#detail-framego-constructor "Link to this heading")

[Overview: FrameGO: Constructor](../api_overview/frame_go-constructor.md#api-overview-framego-constructor)

FrameGO.\_\_init\_\_(*data=<object object>*, *\**, *index=None*, *columns=None*, *name=<object object>*, *index\_constructor=None*, *columns\_constructor=None*, *own\_data=False*, *own\_index=False*, *own\_columns=False*)[](#static_frame.FrameGO.__init__ "Link to this definition")
:   Initializer.

    Parameters:
    :   * **data** – Default Frame initialization requires typed data such as a NumPy array. All other initialization should use specialized constructors.
        * **index** – Optional index initializer. If provided in addition to data values, lengths must be compatible.
        * **columns** – Optional column initializer. If provided in addition to data values, lengths must be compatible.
        * **index\_constructor** –
        * **columns\_constructor** –
        * **own\_data** – Flag the data values as ownable by this [`static_frame.Frame`](frame.md#static_frame.Frame "static_frame.Frame"). Primarily used by internal clients.
        * **own\_index** – Flag the passed index as ownable by this [`static_frame.Frame`](frame.md#static_frame.Frame "static_frame.Frame"). Primarily used by internal clients.
        * **own\_columns** – Flag the passed columns as ownable by this [`static_frame.Frame`](frame.md#static_frame.Frame "static_frame.Frame"). Primarily used by internal clients.

    ```
    >>> sf.FrameGO(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    <FrameGO: x>
    <IndexGO>    a       b       <<U1>
    <Index>
    p            0       1
    q            2       3
    r            4       5
    <<U1>        <int64> <int64>

    ```

*classmethod* FrameGO.from\_arrow(*value*, *\**, *index\_depth=0*, *index\_name\_depth\_level=None*, *index\_constructors=None*, *columns\_depth=1*, *columns\_name\_depth\_level=None*, *columns\_constructors=None*, *dtypes=None*, *name=None*, *consolidate\_blocks=False*)[](#static_frame.FrameGO.from_arrow "Link to this definition")
:   Realize a `Frame` from an Arrow Table.

    Parameters:
    :   * **value** – A `pyarrow.Table` instance.
        * **index\_depth** – integer specification of how many columns to use in forming the index. A value of 0 will select none; a value greater than 1 will create an [`IndexHierarchy`](index_hierarchy-selector.md#IndexHierarchy "IndexHierarchy").
        * **columns\_depth** – integer specification of how many rows to use in forming the columns. A value of 0 will select none; a value greater than 1 will create an [`IndexHierarchy`](index_hierarchy-selector.md#IndexHierarchy "IndexHierarchy").
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f1 = sf.FrameGO(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b       <<U1>
    <Index>
    p            0       1
    q            2       3
    r            4       5
    <<U1>        <int64> <int64>
    >>> aw = f1.to_arrow()
    >>> aw
    pyarrow.Table
    __index0__: string
    a: int64
    b: int64
    ----
    __index0__: [["p","q","r"]]
    a: [[0,2,4]]
    b: [[1,3,5]]
    >>> sf.FrameGO.from_arrow(aw, index_depth=1)
    <FrameGO>
    <IndexGO> a       b       <<U1>
    <Index>
    p         0       1
    q         2       3
    r         4       5
    <object>  <int64> <int64>

    ```

*classmethod* FrameGO.from\_clipboard(*\**, *delimiter='\t'*, *index\_depth=0*, *index\_column\_first=0*, *index\_name\_depth\_level=None*, *index\_constructors=None*, *index\_continuation\_token=<object object>*, *columns\_depth=1*, *columns\_name\_depth\_level=None*, *columns\_constructors=None*, *columns\_continuation\_token=<object object>*, *columns\_select=None*, *skip\_header=0*, *skip\_footer=0*, *skip\_initial\_space=False*, *quoting=0*, *quote\_char='"'*, *quote\_double=True*, *escape\_char=None*, *thousands\_char=''*, *decimal\_char='.'*, *encoding=None*, *dtypes=None*, *name=None*, *consolidate\_blocks=False*, *store\_filter=None*)[](#static_frame.FrameGO.from_clipboard "Link to this definition")
:   Create a [`Frame`](frame-selector.md#Frame "Frame") from the contents of the clipboard (assuming a table is stored as delimited file).

    Returns:
    :   [`static_frame.Frame`](frame.md#static_frame.Frame "static_frame.Frame")

    ```
    >>> f1 = sf.FrameGO(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b       <<U1>
    <Index>
    p            0       1
    q            2       3
    r            4       5
    <<U1>        <int64> <int64>
    >>> f1.to_clipboard()
    >>> sf.FrameGO.from_clipboard(index_depth=1)
    <FrameGO>
    <IndexGO> a       b       <<U1>
    <Index>
    p         0       1
    q         2       3
    r         4       5
    <<U1>     <int64> <int64>

    ```

*classmethod* FrameGO.from\_concat(*frames*, *\**, *axis=0*, *union=True*, *index=None*, *columns=None*, *index\_constructor=None*, *columns\_constructor=None*, *name=None*, *fill\_value=nan*, *consolidate\_blocks=False*)[](#static_frame.FrameGO.from_concat "Link to this definition")
:   Concatenate multiple [`Frame`](frame-selector.md#Frame "Frame") or [`Series`](series-selector.md#Series "Series") into a new [`Frame`](frame-selector.md#Frame "Frame"). If index or columns are provided and appropriately sized, the resulting [`Frame`](frame-selector.md#Frame "Frame") will use those indices. If the axis along concatenation (index for axis 0, columns for axis 1) is unique after concatenation, it will be preserved; otherwise, a new index or an [`IndexAutoFactory`](index_auto_factory.md#static_frame.IndexAutoFactory "static_frame.IndexAutoFactory") must be supplied.

    Parameters:
    :   * **frames** – Iterable of Frames.
        * **axis** – Integer specifying 0 to concatenate supplied Frames vertically (aligning on columns), 1 to concatenate horizontally (aligning on rows).
        * **union** – If True, the union of the aligned indices is used; if False, the intersection is used.
        * **index** – Optionally specify a new index.
        * **columns** – Optionally specify new columns.
        * **index\_constructor** – Optionally apply a constructor to the derived or passed labels.
        * **columns\_constructor** – Optionally apply a constructor to the derived or passed labels.
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    Returns:
    :   [`static_frame.Frame`](frame.md#static_frame.Frame "static_frame.Frame")

    ```
    >>> f1 = sf.FrameGO(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b       <<U1>
    <Index>
    p            0       1
    q            2       3
    r            4       5
    <<U1>        <int64> <int64>
    >>> f2 = sf.FrameGO((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')
    >>> f2
    <FrameGO: y>
    <IndexGO>    c      d      <<U1>
    <Index>
    p            False  True
    q            False  True
    r            False  True
    <<U1>        <bool> <bool>
    >>> sf.FrameGO.from_concat((f1, f2), axis=1)
    <FrameGO>
    <IndexGO> a       b       c      d      <<U1>
    <Index>
    p         0       1       False  True
    q         2       3       False  True
    r         4       5       False  True
    <<U1>     <int64> <int64> <bool> <bool>
    >>> sf.FrameGO.from_concat((f1, f2.relabel(columns=('a', 'b'))), axis=0, index=sf.IndexAutoFactory)
    <FrameGO>
    <IndexGO> a        b        <<U1>
    <Index>
    0         0        1
    1         2        3
    2         4        5
    3         False    True
    4         False    True
    5         False    True
    <int64>   <object> <object>

    ```

*classmethod* FrameGO.from\_concat\_items(*items*, *\**, *axis=0*, *union=True*, *name=None*, *fill\_value=nan*, *index\_constructor=None*, *columns\_constructor=None*, *consolidate\_blocks=False*)[](#static_frame.FrameGO.from_concat_items "Link to this definition")
:   Produce a [`Frame`](frame-selector.md#Frame "Frame") with a hierarchical index from an iterable of pairs of labels, [`Frame`](frame-selector.md#Frame "Frame"). The [`IndexHierarchy`](index_hierarchy-selector.md#IndexHierarchy "IndexHierarchy") is formed from the provided labels and the [`Index`](index-selector.md#Index "Index") if each [`Frame`](frame-selector.md#Frame "Frame").

    Parameters:
    :   * **items** – Iterable of pairs of label, [`Frame`](frame-selector.md#Frame "Frame")
        * **axis** –
        * **union** –
        * **name** –
        * **fill\_value** –
        * **index\_constructor** –
        * **columns\_constructor** –
        * **consolidate\_blocks** –

    ```
    >>> f1 = sf.FrameGO(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b       <<U1>
    <Index>
    p            0       1
    q            2       3
    r            4       5
    <<U1>        <int64> <int64>
    >>> f2 = sf.FrameGO((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')
    >>> f2
    <FrameGO: y>
    <IndexGO>    c      d      <<U1>
    <Index>
    p            False  True
    q            False  True
    r            False  True
    <<U1>        <bool> <bool>
    >>> sf.FrameGO.from_concat_items(((f1.name, f1), (f2.name, f2)), axis=1)
    <FrameGO>
    <IndexHierarchyGO> x       x       y      y      <<U1>
                       a       b       c      d      <<U1>
    <Index>
    p                  0       1       False  True
    q                  2       3       False  True
    r                  4       5       False  True
    <<U1>              <int64> <int64> <bool> <bool>
    >>> sf.FrameGO.from_concat_items(((f1.name, f1), (f2.name, f2.relabel(columns=('a', 'b')))), axis=0)
    <FrameGO>
    <IndexGO>              a        b        <<U1>
    <IndexHierarchy>
    x                p     0        1
    x                q     2        3
    x                r     4        5
    y                p     False    True
    y                q     False    True
    y                r     False    True
    <<U1>            <<U1> <object> <object>

    ```

*classmethod* FrameGO.from\_csv(*fp*, *\**, *index\_depth=0*, *index\_column\_first=0*, *index\_name\_depth\_level=None*, *index\_constructors=None*, *index\_continuation\_token=<object object>*, *columns\_depth=1*, *columns\_name\_depth\_level=None*, *columns\_constructors=None*, *columns\_continuation\_token=<object object>*, *columns\_select=None*, *skip\_header=0*, *skip\_footer=0*, *skip\_initial\_space=False*, *quoting=0*, *quote\_char='"'*, *quote\_double=True*, *escape\_char=None*, *thousands\_char=''*, *decimal\_char='.'*, *encoding=None*, *dtypes=None*, *name=None*, *consolidate\_blocks=False*, *store\_filter=None*)[](#static_frame.FrameGO.from_csv "Link to this definition")
:   Specialized version of [`Frame.from_delimited`](frame-constructor.md#static_frame.Frame.from_delimited "static_frame.Frame.from_delimited") for CSV files.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f1 = sf.FrameGO(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b       <<U1>
    <Index>
    p            0       1
    q            2       3
    r            4       5
    <<U1>        <int64> <int64>
    >>> f1.to_csv('/tmp/f.csv')
    >>> from pathlib import Path
    >>> Path('/tmp/f.csv').read_text()
    __index0__,a,b
    p,0,1
    q,2,3
    r,4,5

    >>> sf.FrameGO.from_csv('/tmp/f.csv', index_depth=1)
    <FrameGO>
    <IndexGO> a       b       <<U1>
    <Index>
    p         0       1
    q         2       3
    r         4       5
    <<U1>     <int64> <int64>

    ```

*classmethod* FrameGO.from\_delimited(*fp*, *\**, *delimiter*, *index\_depth=0*, *index\_column\_first=0*, *index\_name\_depth\_level=None*, *index\_constructors=None*, *index\_continuation\_token=<object object>*, *columns\_depth=1*, *columns\_name\_depth\_level=None*, *columns\_constructors=None*, *columns\_continuation\_token=<object object>*, *columns\_select=None*, *skip\_header=0*, *skip\_footer=0*, *skip\_initial\_space=False*, *quoting=0*, *quote\_char='"'*, *quote\_double=True*, *escape\_char=None*, *thousands\_char=''*, *decimal\_char='.'*, *encoding=None*, *dtypes=None*, *name=None*, *consolidate\_blocks=False*, *store\_filter=None*)[](#static_frame.FrameGO.from_delimited "Link to this definition")
:   Create a [`Frame`](frame-selector.md#Frame "Frame") from a file path or a file-like object defining a delimited (CSV, TSV) data file.

    Parameters:
    :   * **fp** – A file path or a file-like object.
        * **delimiter** – The character used to seperate row elements.
        * **index\_depth** – Specify the number of columns used to create the index labels; a value greater than 1 will attempt to create a hierarchical index.
        * **index\_column\_first** – Optionally specify a column, by position in the realized columns, to become the start of the index if index\_depth is greater than 0 and columns\_depth is 0.
        * **index\_name\_depth\_level** – If columns\_depth is greater than 0, interpret values over index as the index name.
        * **index\_constructors** –
        * **index\_continuation\_token** –
        * **columns\_depth** – Specify the number of rows after the skip\_header used to create the column labels. A value of 0 will be no header; a value greater than 1 will attempt to create a hierarchical index.
        * **columns\_name\_depth\_level** – If index\_depth is greater than 0, interpret values over index as the columns name.
        * **columns\_constructors** –
        * **columns\_continuation\_token** –
        * **columns\_select** – an iterable of columns to select by label or position; can only be used if index\_depth is 0.
        * **skip\_header** – Number of leading lines to skip.
        * **skip\_footer** – Number of trailing lines to skip.
        * **store\_filter** – A StoreFilter instance, defining translation between unrepresentable strings and types. By default it is disabled, and only empty fields or “NAN” are intepreted as NaN. To force usage, set the type of the column to string.
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    Returns:
    :   [`static_frame.Frame`](frame.md#static_frame.Frame "static_frame.Frame")

    ```
    >>> f1 = sf.FrameGO(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b       <<U1>
    <Index>
    p            0       1
    q            2       3
    r            4       5
    <<U1>        <int64> <int64>
    >>> f1.to_delimited('/tmp/f.psv', delimiter='|')
    >>> from pathlib import Path
    >>> Path('/tmp/f.psv').read_text()
    __index0__|a|b
    p|0|1
    q|2|3
    r|4|5

    >>> sf.FrameGO.from_delimited('/tmp/f.psv', delimiter='|', index_depth=1)
    <FrameGO>
    <IndexGO> a       b       <<U1>
    <Index>
    p         0       1
    q         2       3
    r         4       5
    <<U1>     <int64> <int64>

    ```

*classmethod* FrameGO.from\_dict(*mapping*, *\**, *index=None*, *fill\_value=nan*, *dtypes=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*, *consolidate\_blocks=False*)[](#static_frame.FrameGO.from_dict "Link to this definition")
:   Create a Frame from a dictionary (or any object that has an items() method) where keys are column labels and values are columns values (either sequence types or [`Series`](series-selector.md#Series "Series")).

    Parameters:
    :   * **mapping** – a dictionary or similar mapping interface.
        * **index** –
        * **fill\_value** –
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **index\_constructor** –
        * **columns\_constructor** –
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    ```
    >>> sf.FrameGO.from_dict(mapping=dict(a=(10, 2, 8, 3), b=('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), dtypes=dict(b=np.datetime64), name='x')
    <FrameGO: x>
    <IndexGO>    a       b               <<U1>
    <Index>
    0            10      1517-01-01
    1            2       1517-04-01
    2            8       1517-12-31
    3            3       1517-06-30
    <int64>      <int64> <datetime64[D]>

    ```

*classmethod* FrameGO.from\_dict\_fields(*fields*, *\**, *columns=None*, *dtypes=None*, *name=None*, *fill\_value=nan*, *consolidate\_blocks=False*, *index\_constructor=None*, *columns\_constructor=None*, *own\_index=False*)[](#static_frame.FrameGO.from_dict_fields "Link to this definition")
:   Frame constructor from an iterable of dictionaries, where each dictionary represents a column; index labels will be derived from the union of all column dictionary keys.

    Parameters:
    :   * **fields** – Iterable of column values, where column values are dictionaries.
        * **index** – Optionally provide an iterable of index labels, equal in length to the number of fields. If a generator, this value will not be evaluated until after fields are loaded.
        * **columns** –
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> sf.FrameGO.from_dict_fields(records=(dict(a=False, b=False, c=True), dict(a='1517-04-01', b='1517-01-01', c='1517-04-01')), columns=('p', 'q'), dtypes=dict(q=np.datetime64), name='x')
    TypeError("Frame.from_dict_fields() got an unexpected keyword argument 'records'")

    ```

*classmethod* FrameGO.from\_dict\_records(*records*, *\**, *index=None*, *dtypes=None*, *name=None*, *fill\_value=nan*, *consolidate\_blocks=False*, *index\_constructor=None*, *columns\_constructor=None*, *own\_index=False*)[](#static_frame.FrameGO.from_dict_records "Link to this definition")
:   Frame constructor from an iterable of dictionaries, where each dictionary represents a row; column names will be derived from the union of all row dictionary keys.

    Parameters:
    :   * **records** – Iterable of row values, where row values are dictionaries.
        * **index** – Optionally provide an iterable of index labels, equal in length to the number of records. If a generator, this value will not be evaluated until after records are loaded.
        * **index** –
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> sf.FrameGO.from_dict_records(records=(dict(a=10, b=False, c='1517-01-01'), dict(a=8, b=True, c='1517-04-01')), index=('p', 'q'), dtypes=dict(c=np.datetime64), name='x')
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    p            10      False  1517-01-01
    q            8       True   1517-04-01
    <<U1>        <int64> <bool> <datetime64[D]>

    ```

*classmethod* FrameGO.from\_dict\_records\_items(*items*, *\**, *dtypes=None*, *name=None*, *consolidate\_blocks=False*)[](#static_frame.FrameGO.from_dict_records_items "Link to this definition")
:   Frame constructor from iterable of pairs of index label, row, where row is a dictionary. Column names will be derived from the union of all row dictionary keys.

    Parameters:
    :   * **items** – Iterable of pairs of index label, row values, where row values are arrays, tuples, lists, dictionaries, or namedtuples.
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    Returns:
    :   [`static_frame.Frame`](frame.md#static_frame.Frame "static_frame.Frame")

    ```
    >>> sf.FrameGO.from_dict_records_items(items=(('p', dict(a=10, b=False, c='1517-01-01')), ('q', dict(a=8, b=True, c='1517-04-01'))), dtypes=dict(c=np.datetime64), name='x')
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    p            10      False  1517-01-01
    q            8       True   1517-04-01
    <<U1>        <int64> <bool> <datetime64[D]>

    ```

*classmethod* FrameGO.from\_duckdb(*fp*, *\**, *label*, *index\_depth=0*, *index\_constructors=None*, *columns\_depth=1*, *columns\_constructors=None*, *consolidate\_blocks=False*)[](#static_frame.FrameGO.from_duckdb "Link to this definition")
:   Load Frame from the contents of a table in an SQLite database file.

    ```
    >>> f1 = sf.FrameGO.from_fields(((10, 2, 8, 3), ('qrs ', 'XYZ', '123', ' wX ')), columns=('a', 'b'), index=('p', 'q', 'r', 's'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> f1.to_duckdb('/tmp/f.db')
    >>> sf.FrameGO.from_duckdb('/tmp/f.db', label=f1.name, index_depth=1)
    <FrameGO: x>
    <IndexGO>    a       b        <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <object>     <int64> <object>

    ```

*classmethod* FrameGO.from\_element(*element*, *\**, *index*, *columns*, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*, *own\_index=False*, *own\_columns=False*)[](#static_frame.FrameGO.from_element "Link to this definition")
:   Create a Frame from an element, i.e., a single value stored in a single cell. Both `index` and `columns` are required, and cannot be specified with `IndexAutoFactory`.

    ```
    >>> sf.FrameGO.from_element(0, index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    <FrameGO: x>
    <IndexGO>    a       b       <<U1>
    <Index>
    p            0       0
    q            0       0
    r            0       0
    <<U1>        <int64> <int64>

    ```

*classmethod* FrameGO.from\_element\_items(*items*, *\**, *index*, *columns*, *dtype=None*, *axis=None*, *name=None*, *fill\_value=<object object>*, *index\_constructor=None*, *columns\_constructor=None*, *own\_index=False*, *own\_columns=False*)[](#static_frame.FrameGO.from_element_items "Link to this definition")
:   Create a [`Frame`](frame-selector.md#Frame "Frame") from an iterable of key, value, where key is a pair of row, column labels.

    This function is partialed (setting the index and columns) and used by `IterNodeDelegate` as the apply constructor for doing application on element iteration.

    Parameters:
    :   * **items** – an iterable of pairs of 2-tuples of row, column loc labels and values.
        * **axis** – when None, items can be in an order; when 0, items must be well-formed and ordered row major; when 1, items must be well-formed and ordered columns major.

    Returns:
    :   [`static_frame.Frame`](frame.md#static_frame.Frame "static_frame.Frame")

    ```
    >>> sf.FrameGO.from_element_items(((('a', 0), -1), (('b', 0), 10), (('a', 1), 3), (('b', 'a'), 1)), columns=(0, 1), index=('a', 'b'), name='x', axis=1)
    ErrorInitTypeBlocks('Array block has unaligned row count: found 1, expected 2')

    ```

*classmethod* FrameGO.from\_elements(*elements*, *\**, *index=None*, *columns=None*, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*, *own\_index=False*, *own\_columns=False*)[](#static_frame.FrameGO.from_elements "Link to this definition")
:   Create a Frame from an iterable of elements, to be formed into a `Frame` with a single column.

    ```
    >>> sf.FrameGO.from_elements((10, 2, 8, 3), index=('p', 'q', 'r', 's'), columns=['a'], name='x')
    <FrameGO: x>
    <IndexGO>    a       <<U1>
    <Index>
    p            10
    q            2
    r            8
    s            3
    <<U1>        <int64>

    ```

*classmethod* FrameGO.from\_fields(*fields*, *\**, *index=None*, *columns=None*, *fill\_value=nan*, *dtypes=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*, *own\_index=False*, *own\_columns=False*, *consolidate\_blocks=False*)[](#static_frame.FrameGO.from_fields "Link to this definition")
:   Frame constructor from an iterator of columns, where columns are iterables. [`Series`](series-selector.md#Series "Series") can be provided as values if an `index` argument is supplied. This constructor is similar to `from_items()`, though here columns are provided through an independent `columns` argument.

    Parameters:
    :   * **fields** – Iterable of column values.
        * **index** – Iterable of values to create an Index.
        * **fill\_value** – If pairs include Series, they will be reindexed with the provided index; reindexing will use this fill value.
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    Returns:
    :   [`static_frame.Frame`](frame.md#static_frame.Frame "static_frame.Frame")

    ```
    >>> sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>

    ```

*classmethod* FrameGO.from\_hdf5(*fp*, *\**, *label*, *index\_depth=0*, *index\_constructors=None*, *columns\_depth=1*, *columns\_constructors=None*, *name=<object object>*, *consolidate\_blocks=False*)[](#static_frame.FrameGO.from_hdf5 "Link to this definition")
:   Load Frame from the contents of a table in an HDF5 file.

    ```
    >>> f1 = sf.FrameGO.from_fields(((10, 2, 8, 3), ('qrs ', 'XYZ', '123', ' wX ')), columns=('a', 'b'), index=('p', 'q', 'r', 's'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> f1.to_hdf5('/tmp/f.hdf5')
    >>> f1.from_hdf5('/tmp/f.hdf5', label='x', index_depth=1)
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>

    ```

*classmethod* FrameGO.from\_items(*pairs*, *\**, *index=None*, *fill\_value=nan*, *dtypes=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*, *consolidate\_blocks=False*)[](#static_frame.FrameGO.from_items "Link to this definition")
:   Frame constructor from an iterator of pairs, where the first value is the column label and the second value is an iterable of column values. [`Series`](series-selector.md#Series "Series") can be provided as values if an `index` argument is supplied.

    Parameters:
    :   * **pairs** – Iterable of pairs of column name, column values.
        * **index** – Iterable of values to create an Index.
        * **fill\_value** – If pairs include Series, they will be reindexed with the provided index; reindexing will use this fill value.
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **index\_constructor** –
        * **columns\_constructor** –
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> sf.FrameGO.from_items((('a', (10, 2, 8, 3)), ('b', ('qrs ', 'XYZ', '123', ' wX '))), index=('p', 'q', 'r', 's'), name='x')
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>

    ```

*classmethod* FrameGO.from\_json\_columns(*json\_data*, *\**, *dtypes=None*, *name=None*, *consolidate\_blocks=False*, *index\_constructor=None*, *columns\_constructor=None*)[](#static_frame.FrameGO.from_json_columns "Link to this definition")
:   Frame constructor from an in-memory JSON document in the following format: A JSON object keyed by column labels, where values are columns represented by an object mapping of index labels to values.

    Parameters:
    :   * **json\_data** – a string or StringIO of JSON data
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> msg = f.to_json_columns(indent=4)
    >>> msg
    {
        "a": {
            "0": 10,
            "1": 2,
            "2": 8,
            "3": 3
        },
        "b": {
            "0": false,
            "1": true,
            "2": true,
            "3": false
        },
        "c": {
            "0": "1517-01-01",
            "1": "1517-04-01",
            "2": "1517-12-31",
            "3": "1517-06-30"
        }
    }
    >>> sf.Frame.from_json_columns(msg, dtypes=dict(c=np.datetime64))
    <Frame>
    <Index> a       b      c          <<U1>
    <Index>
    0       10      False  1517-01-01
    1       2       True   1517-04-01
    2       8       True   1517-12-31
    3       3       False  1517-06-30
    <<U1>   <int64> <bool> <<U10>

    ```

*classmethod* FrameGO.from\_json\_index(*json\_data*, *\**, *dtypes=None*, *name=None*, *consolidate\_blocks=False*, *index\_constructor=None*, *columns\_constructor=None*)[](#static_frame.FrameGO.from_json_index "Link to this definition")
:   Frame constructor from an in-memory JSON document in the following format: A JSON object keyed by index labels, where values are rows represented by an object mapping of column labels to values.

    Parameters:
    :   * **json\_data** – a string or StringIO of JSON data
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> msg = f.to_json_index(indent=4)
    >>> msg
    {
        "0": {
            "a": 10,
            "b": false,
            "c": "1517-01-01"
        },
        "1": {
            "a": 2,
            "b": true,
            "c": "1517-04-01"
        },
        "2": {
            "a": 8,
            "b": true,
            "c": "1517-12-31"
        },
        "3": {
            "a": 3,
            "b": false,
            "c": "1517-06-30"
        }
    }
    >>> sf.Frame.from_json_index(msg, dtypes=dict(c=np.datetime64))
    <Frame>
    <Index> a       b      c               <<U1>
    <Index>
    0       10      False  1517-01-01
    1       2       True   1517-04-01
    2       8       True   1517-12-31
    3       3       False  1517-06-30
    <<U1>   <int64> <bool> <datetime64[D]>

    ```

*classmethod* FrameGO.from\_json\_records(*json\_data*, *\**, *index=None*, *dtypes=None*, *name=None*, *consolidate\_blocks=False*, *index\_constructor=None*, *columns\_constructor=None*)[](#static_frame.FrameGO.from_json_records "Link to this definition")
:   Frame constructor from an in-memory JSON document in the following format: A JSON array of row objects, where column labels are repeated for each row, and no index labels are included.

    Parameters:
    :   * **json\_data** – a string or StringIO of JSON data
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> msg = f.to_json_records(indent=4)
    >>> msg
    [
        {
            "a": 10,
            "b": false,
            "c": "1517-01-01"
        },
        {
            "a": 2,
            "b": true,
            "c": "1517-04-01"
        },
        {
            "a": 8,
            "b": true,
            "c": "1517-12-31"
        },
        {
            "a": 3,
            "b": false,
            "c": "1517-06-30"
        }
    ]
    >>> sf.Frame.from_json_records(msg, dtypes=dict(c=np.datetime64))
    <Frame>
    <Index> a       b      c               <<U1>
    <Index>
    0       10      False  1517-01-01
    1       2       True   1517-04-01
    2       8       True   1517-12-31
    3       3       False  1517-06-30
    <int64> <int64> <bool> <datetime64[D]>

    ```

*classmethod* FrameGO.from\_json\_split(*json\_data*, *\**, *dtypes=None*, *name=None*, *consolidate\_blocks=False*, *index\_constructor=None*, *columns\_constructor=None*)[](#static_frame.FrameGO.from_json_split "Link to this definition")
:   Frame constructor from an in-memory JSON document in the following format: A JSON object with a key for “columns”, “index”, and “data”, where data is given as an array of arrays of row values.

    Parameters:
    :   * **json\_data** – a string or StringIO of JSON data
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> msg = f.to_json_split(indent=4)
    >>> msg
    {
        "columns": [
            "a",
            "b",
            "c"
        ],
        "index": [
            0,
            1,
            2,
            3
        ],
        "data": [
            [
                10,
                false,
                "1517-01-01"
            ],
            [
                2,
                true,
                "1517-04-01"
            ],
            [
                8,
                true,
                "1517-12-31"
            ],
            [
                3,
                false,
                "1517-06-30"
            ]
        ]
    }
    >>> sf.Frame.from_json_split(msg, dtypes=dict(c=np.datetime64))
    <Frame>
    <Index> a       b      c               <<U1>
    <Index>
    0       10      False  1517-01-01
    1       2       True   1517-04-01
    2       8       True   1517-12-31
    3       3       False  1517-06-30
    <int64> <int64> <bool> <datetime64[D]>

    ```

*classmethod* FrameGO.from\_json\_typed(*json\_data*, *\**, *consolidate\_blocks=False*)[](#static_frame.FrameGO.from_json_typed "Link to this definition")
:   Frame constructor from an in-memory JSON document in the following format: A JSON object with a key for “columns”, “index”, and “data”, where data is given as an array of arrays of column values; additionally, a key for “\_\_meta\_\_” defines an object with complete metadata and typing information.

    Parameters:
    :   **json\_data** – a string or StringIO of JSON data

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>              a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> msg = f.to_json_typed(indent=4)
    >>> msg
    {
        "columns": [
            "a",
            "b",
            "c"
        ],
        "index": [
            [
                0,
                "p"
            ],
            [
                0,
                "q"
            ],
            [
                1,
                "p"
            ],
            [
                1,
                "q"
            ]
        ],
        "data": [
            [
                10,
                2,
                8,
                3
            ],
            [
                false,
                true,
                true,
                false
            ],
            [
                "1517-01-01",
                "1517-04-01",
                "1517-12-31",
                "1517-06-30"
            ]
        ],
        "__meta__": {
            "__names__": [
                "x",
                null,
                null
            ],
            "__dtypes__": [
                "=i8",
                "|b1",
                "=M8[D]"
            ],
            "__dtypes_index__": [
                "=i8",
                "=U1"
            ],
            "__dtypes_columns__": [
                "=U1"
            ],
            "__types__": [
                "IndexHierarchy",
                "IndexGO"
            ],
            "__types_index__": [
                "Index",
                "Index"
            ],
            "__depths__": [
                3,
                2,
                1
            ]
        }
    }
    >>> sf.Frame.from_json_typed(msg)
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>

    ```

*classmethod* FrameGO.from\_json\_values(*json\_data*, *\**, *index=None*, *columns=None*, *dtypes=None*, *name=None*, *consolidate\_blocks=False*, *index\_constructor=None*, *columns\_constructor=None*)[](#static_frame.FrameGO.from_json_values "Link to this definition")
:   Frame constructor from an in-memory JSON document in the following format: A JSON array of arrays of row values; no index or columns labels are included.

    Parameters:
    :   * **json\_data** – a string or StringIO of JSON data
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> msg = f.to_json_values(indent=4)
    >>> msg
    [
        [
            10,
            false,
            "1517-01-01"
        ],
        [
            2,
            true,
            "1517-04-01"
        ],
        [
            8,
            true,
            "1517-12-31"
        ],
        [
            3,
            false,
            "1517-06-30"
        ]
    ]
    >>> sf.Frame.from_json_values(msg, columns=tuple('abc'), dtypes=dict(c=np.datetime64))
    <Frame>
    <Index> a       b      c               <<U1>
    <Index>
    0       10      False  1517-01-01
    1       2       True   1517-04-01
    2       8       True   1517-12-31
    3       3       False  1517-06-30
    <int64> <int64> <bool> <datetime64[D]>

    ```

*static* FrameGO.from\_msgpack(*msgpack\_data*)[](#static_frame.FrameGO.from_msgpack "Link to this definition")
:   Frame constructor from an in-memory binary object formatted as a msgpack.

    Parameters:
    :   **msgpack\_data** – A binary msgpack object, encoding a Frame as produced from to\_msgpack()

    ```
    >>> f1 = sf.FrameGO.from_fields(((10, 2, 8, 3), ('qrs ', 'XYZ', '123', ' wX ')), columns=('a', 'b'), index=('p', 'q', 'r', 's'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> mb = f1.to_msgpack()
    >>> mb
    b'\x85\xc4\x02sf\xa7FrameGO\xc4\x04name\xa1x\xc4\x06blocks\xc4\xcd\x82\xc4\x02sf\xaaTypeBlocks\xc4\x06blocks\xc4\xb3\x92\x85\xc4\x02nd\xc3\xc4\x04type\xa3<i8\xc4\x04kind\xc4\x00\xc4\x05shape\x91\x04\xc4\x04data\xc4 \n\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x85\xc4\x02nd\xc3\xc4\x04type\xa3<U4\xc4\x04kind\xc4\x00\xc4\x05shape\x91\x04\xc4\x04data\xc4@q\x00\x00\x00r\x00\x00\x00s\x00\x00\x00 \x00\x00\x00X\x00\x00\x00Y\x00\x00\x00Z\x00\x00\x00\x00\x00\x00\x001\x00\x00\x002\x00\x00\x003\x00\x00\x00\x00\x00\x00\x00 \x00\x00\x00w\x00\x00\x00X\x00\x00\x00 \x00\x00\x00\xc4\x05index\xc4S\x83\xc4\x02sf\xa5Index\xc4\x04name\xc0\xc4\x04data\xc49\x85\xc4\x02nd\xc3\xc4\x04type\xa3<U1\xc4\x04kind\xc4\x00\xc4\x05shape\x91\x04\xc4\x04data\xc4\x10p\x00\x00\x00q\x00\x00\x00r\x00\x00\x00s\x00\x00\x00\xc4\x07columns\xc4M\x83\xc4\x02sf\xa7IndexGO\xc4\x04name\xc0\xc4\x04data\xc41\x85\xc4\x02nd\xc3\xc4\x04type\xa3<U1\xc4\x04kind\xc4\x00\xc4\x05shape\x91\x02\xc4\x04data\xc4\x08a\x00\x00\x00b\x00\x00\x00'
    >>> sf.FrameGO.from_msgpack(mb)
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>

    ```

*classmethod* FrameGO.from\_npy(*fp*)[](#static_frame.FrameGO.from_npy "Link to this definition")
:   Create a [`Frame`](frame-selector.md#Frame "Frame") from an directory of npy files.

    Parameters:
    :   **fp** – The path to the NPY directory.

    ```
    >>> f1 = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> f1.to_npy('/tmp/f.npy')
    >>> sf.FrameGO.from_npy('/tmp/f.npy')
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> import shutil
    >>> shutil.rmtree('/tmp/f.npy')

    ```

*classmethod* FrameGO.from\_npy\_mmap(*fp*)[](#static_frame.FrameGO.from_npy_mmap "Link to this definition")
:   Create a [`Frame`](frame-selector.md#Frame "Frame") from an directory of npy files using memory maps.

    Parameters:
    :   **fp** – The path to the NPY directory.

    Returns:
    :   A tuple of [`Frame`](frame-selector.md#Frame "Frame") and the callable needed to close the open memory map objects. On some platforms this must be called before the process exits.

    ```
    >>> f1 = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> f1.to_npy('/tmp/f.npy')
    >>> f2, closer = sf.FrameGO.from_npy_mmap('/tmp/f.npy')
    >>> f2
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> closer() # close mmaps after usage
    >>> import shutil
    >>> shutil.rmtree('/tmp/f.npy')

    ```

*classmethod* FrameGO.from\_npz(*fp*)[](#static_frame.FrameGO.from_npz "Link to this definition")
:   Create a [`Frame`](frame-selector.md#Frame "Frame") from an npz file.

    ```
    >>> f1 = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> f1.to_npz('/tmp/f.npz')
    >>> sf.FrameGO.from_npz('/tmp/f.npz')
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>

    ```

*classmethod* FrameGO.from\_overlay(*containers*, *\**, *index=None*, *columns=None*, *union=True*, *name=None*, *func=<function isna\_array>*, *fill\_value=<object object>*)[](#static_frame.FrameGO.from_overlay "Link to this definition")
:   Return a new [`Frame`](frame-selector.md#Frame "Frame") made by overlaying containers, filling in values with aligned values from subsequent containers. Values are filled based on a passed function that must return a Boolean array. By default, that function is isna\_array, returning True for missing values (NaN and None).

    Parameters:
    :   * **containers** – Iterable of [`Frame`](frame-selector.md#Frame "Frame").
        * **index** – An optional [`Index`](index-selector.md#Index "Index"), [`IndexHierarchy`](index_hierarchy-selector.md#IndexHierarchy "IndexHierarchy"), or index initializer, to be used as the index upon which all containers are aligned. [`IndexAutoFactory`](index_auto_factory.md#static_frame.IndexAutoFactory "static_frame.IndexAutoFactory") is not supported.
        * **columns** – An optional [`Index`](index-selector.md#Index "Index"), [`IndexHierarchy`](index_hierarchy-selector.md#IndexHierarchy "IndexHierarchy"), or columns initializer, to be used as the columns upon which all containers are aligned. [`IndexAutoFactory`](index_auto_factory.md#static_frame.IndexAutoFactory "static_frame.IndexAutoFactory") is not supported.
        * **union** – If True, and no `index` or `columns` argument is supplied, a union index or columns from `containers` will be used; if False, the intersection index or columns will be used.
        * **name** –
        * **func** – A function that takes an array and returns a same-sized Boolean array, where True indicates availability for insertion.

    ```
    >>> f1 = sf.FrameGO.from_items((('a', (10, 2, np.nan, 3)), ('b', ('qrs ', 'XYZ', None, None))), index=('p', 'q', 'r', 's'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a         b        <<U1>
    <Index>
    p            10.0      qrs
    q            2.0       XYZ
    r            nan       None
    s            3.0       None
    <<U1>        <float64> <object>
    >>> f2 = sf.FrameGO.from_items((('a', (8, 3)), ('b', ('123', ' wX '))), index=('r', 's'), name='y')
    >>> f2
    <FrameGO: y>
    <IndexGO>    a       b     <<U1>
    <Index>
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> sf.FrameGO.from_overlay((f1, f2))
    <FrameGO>
    <IndexGO> a         b        <<U1>
    <Index>
    p         10.0      qrs
    q         2.0       XYZ
    r         8.0       123
    s         3.0        wX
    <<U1>     <float64> <object>

    ```

*classmethod* FrameGO.from\_pandas(*value*, *\**, *index=None*, *index\_constructor=None*, *columns=None*, *columns\_constructor=None*, *dtypes=None*, *name=<object object>*, *consolidate\_blocks=False*, *own\_data=False*)[](#static_frame.FrameGO.from_pandas "Link to this definition")
:   Given a Pandas DataFrame, return a Frame.

    Parameters:
    :   * **value** – Pandas DataFrame.
        * **index\_constructor** – Optional class or constructor function to create the [`Index`](index-selector.md#Index "Index") applied to the rows.
        * **columns\_constructor** – Optional class or constructor function to create the [`Index`](index-selector.md#Index "Index") applied to the columns.
        * **dtypes** –
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.
        * **own\_data** – If True, the underlying NumPy data array will be made immutable and used without a copy.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f1 = sf.FrameGO.from_fields(((10, 2, 8, 3), ('qrs ', 'XYZ', '123', ' wX ')), columns=('a', 'b'), index=('p', 'q', 'r', 's'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> df = f1.to_pandas()
    >>> df
        a     b
    p  10  qrs
    q   2   XYZ
    r   8   123
    s   3   wX
    >>> sf.FrameGO.from_pandas(df, dtypes=dict(b=str))
    <FrameGO: x>
    <IndexGO>    a       b     <object>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <object>     <int64> <<U4>

    ```

*classmethod* FrameGO.from\_parquet(*fp*, *\**, *index\_depth=0*, *index\_name\_depth\_level=None*, *index\_constructors=None*, *columns\_depth=1*, *columns\_name\_depth\_level=None*, *columns\_constructors=None*, *columns\_select=None*, *dtypes=None*, *name=None*, *consolidate\_blocks=False*)[](#static_frame.FrameGO.from_parquet "Link to this definition")
:   Realize a `Frame` from a Parquet file.

    Parameters:
    :   * **fp** – A string file path or `Path` instance.
        * **index\_depth** – integer specification of how many columns to use in forming the index. A value of 0 will select none; a value greater than 1 will create an [`IndexHierarchy`](index_hierarchy-selector.md#IndexHierarchy "IndexHierarchy").
        * **index\_name\_depth\_level** –
        * **index\_constructors** –
        * **columns\_depth** – integer specification of how many rows to use in forming the columns. A value of 0 will select none; a value greater than 1 will create an [`IndexHierarchy`](index_hierarchy-selector.md#IndexHierarchy "IndexHierarchy").
        * **columns\_name\_depth\_level** –
        * **columns\_constructors** –
        * **columns\_select** – An optional iterable of column names to load.
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    ```
    >>> f1 = sf.FrameGO.from_fields(((10, 2, 8, 3), ('qrs ', 'XYZ', '123', ' wX ')), columns=('a', 'b'), index=('p', 'q', 'r', 's'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b     <<U1>
    <Index>
    p            10      qrs
    q            2       XYZ
    r            8       123
    s            3        wX
    <<U1>        <int64> <<U4>
    >>> f1.to_parquet('/tmp/f.parquet')
    >>> sf.FrameGO.from_parquet('/tmp/f.parquet', index_depth=1)
    <FrameGO>
    <IndexGO> a       b        <<U1>
    <Index>
    p         10      qrs
    q         2       XYZ
    r         8       123
    s         3        wX
    <object>  <int64> <object>

    ```

*classmethod* FrameGO.from\_pickle(*fp*)[](#static_frame.FrameGO.from_pickle "Link to this definition")
:   Create a [`Frame`](frame-selector.md#Frame "Frame") from a pickle file.

    The pickle module is not secure. Only unpickle data you trust.

    Parameters:
    :   **fp** – The path to the pickle file.

    ```
    >>> f1 = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> f1.to_pickle('/tmp/f.pickle')
    >>> sf.FrameGO.from_pickle('/tmp/f.pickle')
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>

    ```

*classmethod* FrameGO.from\_records(*records*, *\**, *index=None*, *columns=None*, *dtypes=None*, *name=None*, *consolidate\_blocks=False*, *index\_constructor=None*, *columns\_constructor=None*, *own\_index=False*, *own\_columns=False*)[](#static_frame.FrameGO.from_records "Link to this definition")
:   Construct a [`Frame`](frame-selector.md#Frame "Frame") from an iterable of rows, where rows are defined as iterables, including tuples, lists, and arrays. If each row is a NamedTuple, and `columns` is not provided, column names will be derived from the NamedTuple fields.

    Supplying `dtypes` will significantly improve performance, as otherwise columnar array types must be derived by element-wise examination.

    For records defined as `Series`, use `Frame.from_concat`; for records defined as dictionary, use `Frame.from_dict_records`; for creating a `Frame` from a single dictionary, where keys are column labels and values are columns, use `Frame.from_dict`.

    Parameters:
    :   * **records** – Iterable of row values, where row values are arrays, tuples, lists, or namedtuples. For dictionary records, use `Frame.from_dict_records`.
        * **index** – Optionally provide an iterable of index labels, equal in length to the number of records. If a generator, this value will not be evaluated until after records are loaded.
        * **columns** – Optionally provide an iterable of column labels, equal in length to the number of elements in a row.
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> sf.FrameGO.from_records(((10, False, '1517-01-01'), (8, True,'1517-04-01')), index=('p', 'q'), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    p            10      False  1517-01-01
    q            8       True   1517-04-01
    <<U1>        <int64> <bool> <datetime64[D]>

    ```

*classmethod* FrameGO.from\_records\_items(*items*, *\**, *columns=None*, *dtypes=None*, *name=None*, *consolidate\_blocks=False*, *index\_constructor=None*, *columns\_constructor=None*, *own\_columns=False*)[](#static_frame.FrameGO.from_records_items "Link to this definition")
:   Frame constructor from iterable of pairs of index value, row (where row is an iterable).

    Parameters:
    :   * **items** – Iterable of pairs of index label, row values, where row values are arrays, tuples, lists, dictionaries, or namedtuples.
        * **columns** – Optionally provide an iterable of column labels, equal in length to the length of each row.
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    Returns:
    :   [`static_frame.Frame`](frame.md#static_frame.Frame "static_frame.Frame")

    ```
    >>> sf.FrameGO.from_records_items((('p', (10, False, '1517-01-01')), ('q', (8, True,'1517-04-01'))), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    p            10      False  1517-01-01
    q            8       True   1517-04-01
    <<U1>        <int64> <bool> <datetime64[D]>

    ```

*classmethod* FrameGO.from\_series(*series*, *\**, *name=None*, *columns\_constructor=None*)[](#static_frame.FrameGO.from_series "Link to this definition")
:   Frame constructor from a Series:

    Parameters:
    :   **series** – A Series instance, to be realized as single column, with the column label taken from the name attribute.

    ```
    >>> s = sf.Series((10, 2, 8), index=('a', 'b', 'c'), name='x')
    >>> s
    <Series: x>
    <Index>
    a           10
    b           2
    c           8
    <<U1>       <int64>
    >>> sf.FrameGO.from_series(s)
    <FrameGO>
    <IndexGO> x       <<U1>
    <Index>
    a         10
    b         2
    c         8
    <<U1>     <int64>

    ```

*classmethod* FrameGO.from\_sql(*query*, *\**, *connection*, *index\_depth=0*, *index\_constructors=None*, *columns\_depth=1*, *columns\_select=None*, *columns\_constructors=None*, *dtypes=None*, *name=None*, *consolidate\_blocks=False*, *parameters=()*)[](#static_frame.FrameGO.from_sql "Link to this definition")
:   Frame constructor from an SQL query and a database connection object.

    Parameters:
    :   * **query** – A query string.
        * **connection** – A DBAPI2 (PEP 249) Connection object, such as those returned from SQLite (via the sqlite3 module) or PyODBC.
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **index\_depth** –
        * **index\_constructors** –
        * **columns\_depth** –
        * **columns\_select** – An optional iterable of field names to extract from the results of the query.
        * **columns\_constructors** –
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.
        * **parameters** – Provide a list of values for an SQL query expecting parameter substitution.

    ```
    >>> f1 = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> f1.to_sqlite('/tmp/f.db')
    >>> import sqlite3
    >>> conn = sqlite3.connect('/tmp/f.db')
    >>> sf.FrameGO.from_sql("select * from x limit 2", connection=conn, index_depth=1)
    <FrameGO>
    <IndexGO> a       b       c          <<U1>
    <Index>
    0         10      0       1517-01-01
    1         2       1       1517-04-01
    <int64>   <int64> <int64> <<U10>

    ```

*classmethod* FrameGO.from\_sqlite(*fp*, *\**, *label*, *index\_depth=0*, *index\_constructors=None*, *columns\_depth=1*, *columns\_constructors=None*, *dtypes=None*, *name=<object object>*, *consolidate\_blocks=False*)[](#static_frame.FrameGO.from_sqlite "Link to this definition")
:   Load Frame from the contents of a table in an SQLite database file.

    ```
    >>> f1 = sf.FrameGO.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b      c               <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <datetime64[D]>
    >>> f1.to_sqlite('/tmp/f.db')
    >>> sf.FrameGO.from_sqlite('/tmp/f.db', label=f1.name, index_depth=1)
    <FrameGO: x>
    <IndexGO>    a       b      c          <<U1>
    <Index>
    0            10      False  1517-01-01
    1            2       True   1517-04-01
    2            8       True   1517-12-31
    3            3       False  1517-06-30
    <int64>      <int64> <bool> <<U10>

    ```

*classmethod* FrameGO.from\_structured\_array(*array*, *\**, *index\_depth=0*, *index\_column\_first=None*, *index\_constructors=None*, *columns\_depth=1*, *columns\_constructors=None*, *dtypes=None*, *name=None*, *consolidate\_blocks=False*, *store\_filter=<static\_frame.core.store\_filter.StoreFilter object>*)[](#static_frame.FrameGO.from_structured_array "Link to this definition")
:   Convert a NumPy structed array into a Frame.

    Parameters:
    :   * **array** – Structured NumPy array.
        * **index\_depth** – Depth if index levels, where (for example) 0 is no index, 1 is a single column index, and 2 is a two-columns IndexHierarchy.
        * **index\_column\_first** – Optionally provide the name or position offset of the column to use as the index.
        * **dtypes** – Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used.
        * **name** – A hashable object to label the container.
        * **consolidate\_blocks** – Optionally consolidate adjacent same-typed columns into contiguous arrays.

    Returns:
    :   [`static_frame.Frame`](frame.md#static_frame.Frame "static_frame.Frame")

    ```
    >>> sa = np.array([(False, 8), (True, 19)], dtype=[('a', bool), ('b', int)])
    >>> sa
    [(False,  8) ( True, 19)]
    >>> sf.FrameGO.from_structured_array(sa)
    <FrameGO>
    <IndexGO> a      b       <<U1>
    <Index>
    0         False  8
    1         True   19
    <int64>   <bool> <int64>

    ```

*classmethod* FrameGO.from\_tsv(*fp*, *\**, *index\_depth=0*, *index\_column\_first=0*, *index\_name\_depth\_level=None*, *index\_constructors=None*, *index\_continuation\_token=<object object>*, *columns\_depth=1*, *columns\_name\_depth\_level=None*, *columns\_constructors=None*, *columns\_continuation\_token=<object object>*, *columns\_select=None*, *skip\_header=0*, *skip\_footer=0*, *skip\_initial\_space=False*, *quoting=0*, *quote\_char='"'*, *quote\_double=True*, *escape\_char=None*, *thousands\_char=''*, *decimal\_char='.'*, *encoding=None*, *dtypes=None*, *name=None*, *consolidate\_blocks=False*, *store\_filter=None*)[](#static_frame.FrameGO.from_tsv "Link to this definition")
:   Specialized version of [`Frame.from_delimited`](frame-constructor.md#static_frame.Frame.from_delimited "static_frame.Frame.from_delimited") for TSV files.

    Returns:
    :   [`static_frame.Frame`](frame.md#static_frame.Frame "static_frame.Frame")

    ```
    >>> f1 = sf.FrameGO(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b       <<U1>
    <Index>
    p            0       1
    q            2       3
    r            4       5
    <<U1>        <int64> <int64>
    >>> f1.to_tsv('/tmp/f.tsv')
    >>> from pathlib import Path
    >>> Path('/tmp/f.tsv').read_text()
    __index0__	a	b
    p	0	1
    q	2	3
    r	4	5

    >>> sf.FrameGO.from_tsv('/tmp/f.tsv', index_depth=1)
    <FrameGO>
    <IndexGO> a       b       <<U1>
    <Index>
    p         0       1
    q         2       3
    r         4       5
    <<U1>     <int64> <int64>

    ```

*classmethod* FrameGO.from\_xlsx(*fp*, *\**, *label=<object object>*, *index\_depth=0*, *index\_name\_depth\_level=None*, *index\_constructors=None*, *columns\_depth=1*, *columns\_name\_depth\_level=None*, *columns\_constructors=None*, *dtypes=None*, *name=<object object>*, *consolidate\_blocks=False*, *skip\_header=0*, *skip\_footer=0*, *trim\_nadir=False*, *store\_filter=<static\_frame.core.store\_filter.StoreFilter object>*)[](#static_frame.FrameGO.from_xlsx "Link to this definition")
:   Load Frame from the contents of a sheet in an XLSX workbook.

    Parameters:
    :   **label** – Optionally provide the sheet name from which to read. If not provided, the first sheet will be used.

    ```
    >>> f1 = sf.FrameGO(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f1
    <FrameGO: x>
    <IndexGO>    a       b       <<U1>
    <Index>
    p            0       1
    q            2       3
    r            4       5
    <<U1>        <int64> <int64>
    >>> f1.to_xlsx('/tmp/f.xlsx')
    >>> sf.FrameGO.from_xlsx('/tmp/f.xlsx', index_depth=1)
    <FrameGO>
    <IndexGO> a       b       <<U1>
    <Index>
    p         0       1
    q         2       3
    r         4       5
    <<U1>     <int64> <int64>

    ```

[FrameGO](frame_go.md#api-detail-framego): [Constructor](#api-detail-framego-constructor) | [Exporter](frame_go-exporter.md#api-detail-framego-exporter) | [Attribute](frame_go-attribute.md#api-detail-framego-attribute) | [Method](frame_go-method.md#api-detail-framego-method) | [Dictionary-Like](frame_go-dictionary_like.md#api-detail-framego-dictionary-like) | [Display](frame_go-display.md#api-detail-framego-display) | [Assignment](frame_go-assignment.md#api-detail-framego-assignment) | [Selector](frame_go-selector.md#api-detail-framego-selector) | [Iterator](frame_go-iterator.md#api-detail-framego-iterator) | [Operator Binary](frame_go-operator_binary.md#api-detail-framego-operator-binary) | [Operator Unary](frame_go-operator_unary.md#api-detail-framego-operator-unary) | [Accessor Values](frame_go-accessor_values.md#api-detail-framego-accessor-values) | [Accessor Datetime](frame_go-accessor_datetime.md#api-detail-framego-accessor-datetime) | [Accessor String](frame_go-accessor_string.md#api-detail-framego-accessor-string) | [Accessor Transpose](frame_go-accessor_transpose.md#api-detail-framego-accessor-transpose) | [Accessor Fill Value](frame_go-accessor_fill_value.md#api-detail-framego-accessor-fill-value) | [Accessor Regular Expression](frame_go-accessor_regular_expression.md#api-detail-framego-accessor-regular-expression) | [Accessor Hashlib](frame_go-accessor_hashlib.md#api-detail-framego-accessor-hashlib) | [Accessor Type Clinic](frame_go-accessor_type_clinic.md#api-detail-framego-accessor-type-clinic) | [Accessor Reduce](frame_go-accessor_reduce.md#api-detail-framego-accessor-reduce)

[Previous](frame-accessor_reduce.md "Detail: Frame: Accessor Reduce")
[Next](frame_go-exporter.md "Detail: FrameGO: Exporter")

---

© Copyright 2025, Christopher Ariza.
Last updated on Apr 29, 2025.

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme)
provided by [Read the Docs](https://readthedocs.org).