[![Logo](../_static/sf-logo-web_icon-small.png)](../index.html)

Quick Start

* [static-frame](../readme.html)
* [License](../license.html)

Introduction

* [About StaticFrame](../intro.html)
* [Media](../intro.html#media)
* [What is New in StaticFrame](../new.html)
* [Contributing](../contributing.html)

Articles

* [Improving Code Quality with Array and DataFrame Type Hints](../articles/guard.html)
* [Type-Hinting DataFrames for Static Analysis and Runtime Validation](../articles/ftyping.html)
* [Faster DataFrame Serialization](../articles/serialize.html)
* [The Performance Advantage of No-Copy DataFrame Operations](../articles/no_copy.html)
* [Memoizing DataFrame Functions: Using Hashable DataFrames and Message Digests to Optimize Repeated Calculations](../articles/hash.html)
* [Using Higher-Order Containers to Efficiently Process 7,163 (or More) DataFrames](../articles/uhoc.html)
* [One Fill Value Is Not Enough: Preserving Columnar Types When Reindexing DataFrames](../articles/fill_value.html)
* [Ten Reasons to Use StaticFrame Instead of Pandas](../articles/upgrade.html)
* [Boring Indices & Where to Find Them: The Auto-Incremented Integer Index in StaticFrame](../articles/aiii.html)

API Overview

* [Overview: Series](../api_overview/series.html)
* [Overview: SeriesHE](../api_overview/series_he.html)
* [Overview: Frame](../api_overview/frame.html)
* [Overview: FrameGO](../api_overview/frame_go.html)
* [Overview: FrameHE](../api_overview/frame_he.html)
* [Overview: Bus](../api_overview/bus.html)
* [Overview: Batch](../api_overview/batch.html)
* [Overview: Yarn](../api_overview/yarn.html)
* [Overview: Quilt](../api_overview/quilt.html)
* [Overview: Index](../api_overview/index.html)
* [Overview: IndexGO](../api_overview/index_go.html)
* [Overview: IndexHierarchy](../api_overview/index_hierarchy.html)
* [Overview: IndexHierarchyGO](../api_overview/index_hierarchy_go.html)
* [Overview: IndexYear](../api_overview/index_year.html)
* [Overview: IndexYearGO](../api_overview/index_year_go.html)
* [Overview: IndexYearMonth](../api_overview/index_year_month.html)
* [Overview: IndexYearMonthGO](../api_overview/index_year_month_go.html)
* [Overview: IndexDate](../api_overview/index_date.html)
* [Overview: IndexDateGO](../api_overview/index_date_go.html)
* [Overview: IndexMinute](../api_overview/index_minute.html)
* [Overview: IndexMinuteGO](../api_overview/index_minute_go.html)
* [Overview: IndexHour](../api_overview/index_hour.html)
* [Overview: IndexHourGO](../api_overview/index_hour_go.html)
* [Overview: IndexSecond](../api_overview/index_second.html)
* [Overview: IndexSecondGO](../api_overview/index_second_go.html)
* [Overview: IndexMillisecond](../api_overview/index_millisecond.html)
* [Overview: IndexMillisecondGO](../api_overview/index_millisecond_go.html)
* [Overview: IndexMicrosecond](../api_overview/index_microsecond.html)
* [Overview: IndexMicrosecondGO](../api_overview/index_microsecond_go.html)
* [Overview: IndexNanosecond](../api_overview/index_nanosecond.html)
* [Overview: IndexNanosecondGO](../api_overview/index_nanosecond_go.html)
* [Overview: HLoc](../api_overview/hloc.html)
* [Overview: ILoc](../api_overview/iloc.html)
* [Overview: TypeClinic](../api_overview/type_clinic.html)
* [Overview: CallGuard](../api_overview/call_guard.html)
* [Overview: ClinicResult](../api_overview/clinic_result.html)
* [Overview: Require](../api_overview/require.html)
* [Overview: WWW](../api_overview/www.html)
* [Overview: FillValueAuto](../api_overview/fill_value_auto.html)
* [Overview: DisplayActive](../api_overview/display_active.html)
* [Overview: DisplayConfig](../api_overview/display_config.html)
* [Overview: StoreConfig](../api_overview/store_config.html)
* [Overview: StoreFilter](../api_overview/store_filter.html)
* [Overview: IndexAutoFactory](../api_overview/index_auto_factory.html)
* [Overview: IndexDefaultConstructorFactory](../api_overview/index_default_constructor_factory.html)
* [Overview: IndexAutoConstructorFactory](../api_overview/index_auto_constructor_factory.html)
* [Overview: NPZ](../api_overview/npz.html)
* [Overview: NPY](../api_overview/npy.html)
* [Overview: MemoryDisplay](../api_overview/memory_display.html)
* [Overview: Platform](../api_overview/platform.html)

API Detail

* [Detail: Series](series.html)
* [Detail: SeriesHE](series_he.html)
* [Detail: Frame](frame.html)
* [Detail: FrameGO](frame_go.html)
* [Detail: FrameHE](frame_he.html)
* [Detail: Bus](bus.html)
* [Detail: Batch](batch.html)
* [Detail: Yarn](yarn.html)
* [Detail: Quilt](quilt.html)
* [Detail: Index](index.html)
* [Detail: IndexGO](index_go.html)
* [Detail: IndexHierarchy](index_hierarchy.html)
* [Detail: IndexHierarchyGO](index_hierarchy_go.html)
* [Detail: IndexYear](index_year.html)
* [Detail: IndexYearGO](index_year_go.html)
* [Detail: IndexYearMonth](index_year_month.html)
* [Detail: IndexYearMonthGO](index_year_month_go.html)
* [Detail: IndexDate](index_date.html)
* [Detail: IndexDateGO](index_date_go.html)
* [Detail: IndexMinute](index_minute.html)
* [Detail: IndexMinuteGO](index_minute_go.html)
* [Detail: IndexHour](index_hour.html)
* [Detail: IndexHourGO](index_hour_go.html)
* [Detail: IndexSecond](index_second.html)
* [Detail: IndexSecondGO](index_second_go.html)
* [Detail: IndexMillisecond](index_millisecond.html)
* [Detail: IndexMillisecondGO](index_millisecond_go.html)
* [Detail: IndexMicrosecond](index_microsecond.html)
* [Detail: IndexMicrosecondGO](index_microsecond_go.html)
* [Detail: IndexNanosecond](index_nanosecond.html)
* [Detail: IndexNanosecondGO](index_nanosecond_go.html)
* [Detail: HLoc](hloc.html)
* [Detail: ILoc](iloc.html)
* [Detail: TypeClinic](type_clinic.html)
* [Detail: CallGuard](call_guard.html)
* [Detail: ClinicResult](clinic_result.html)
* [Detail: Require](require.html)
* [Detail: WWW](www.html)
* [Detail: FillValueAuto](fill_value_auto.html)
* [Detail: DisplayActive](display_active.html)
* [Detail: DisplayConfig](display_config.html)
* [Detail: StoreConfig](store_config.html)
* [Detail: StoreFilter](store_filter.html)
* [Detail: IndexAutoFactory](index_auto_factory.html)
* [Detail: IndexDefaultConstructorFactory](index_default_constructor_factory.html)
* [Detail: IndexAutoConstructorFactory](index_auto_constructor_factory.html)
* [Detail: NPZ](npz.html)
* [Detail: NPY](npy.html)
* [Detail: MemoryDisplay](memory_display.html)
* [Detail: Platform](platform.html)

[StaticFrame](../index.html)

* Detail: Batch: Accessor Regular Expression
* [View page source](../_sources/api_detail/batch-accessor_regular_expression.rst.txt)

[Previous](batch-accessor_fill_value.html "Detail: Batch: Accessor Fill Value")
[Next](batch-accessor_hashlib.html "Detail: Batch: Accessor Hashlib")

---

# Detail: Batch: Accessor Regular Expression[](#detail-batch-accessor-regular-expression "Link to this heading")

[Overview: Batch: Accessor Regular Expression](../api_overview/batch-accessor_regular_expression.html#api-overview-batch-accessor-regular-expression)

Batch.via\_re(*pattern*, *flags).search(pos*, *endpos*)
:   via\_re *= <function Batch.via\_re>*[[source]](../_modules/static_frame/core/batch.html#Batch.via_re)

    InterfaceRe.search(*pos=0*, *endpos=None*)[[source]](../_modules/static_frame/core/node_re.html#InterfaceRe.search)
    :   Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string.

        Parameters:
        :   * **pos** – Gives an index in the string where the search is to start; it defaults to 0.
            * **endpos** – Limits how far the string will be searched; it will be as if the string is endpos characters long.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt
    <Batch max_workers=None>
    >>> bt.via_re('[X123]').search().to_frame()
    <Frame>
    <Index>                   a      b      c        <<U1>
    <IndexHierarchy>
    i                p        False  True   nan
    i                q        True   True   nan
    i                r        False  False  nan
    j                0        True   False  True
    j                1        True   True   True
    j                2        False  False  False
    j                3        True   True   True
    <<U1>            <object> <bool> <bool> <object>

    ```

Batch.via\_re(*pattern*, *flags).match(pos*, *endpos*)
:   via\_re *= <function Batch.via\_re>*[[source]](../_modules/static_frame/core/batch.html#Batch.via_re)

    InterfaceRe.match(*pos=0*, *endpos=None*)[[source]](../_modules/static_frame/core/node_re.html#InterfaceRe.match)
    :   If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match.

        Parameters:
        :   * **pos** – Gives an index in the string where the search is to start; it defaults to 0.
            * **endpos** – Limits how far the string will be searched; it will be as if the string is endpos characters long.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt
    <Batch max_workers=None>
    >>> bt.via_re('[X123]').match().to_frame()
    <Frame>
    <Index>                   a      b      c        <<U1>
    <IndexHierarchy>
    i                p        False  True   nan
    i                q        True   True   nan
    i                r        False  False  nan
    j                0        True   False  True
    j                1        True   True   True
    j                2        False  False  False
    j                3        True   True   True
    <<U1>            <object> <bool> <bool> <object>

    ```

Batch.via\_re(*pattern*, *flags).fullmatch(pos*, *endpos*)
:   via\_re *= <function Batch.via\_re>*[[source]](../_modules/static_frame/core/batch.html#Batch.via_re)

    InterfaceRe.fullmatch(*pos=0*, *endpos=None*)[[source]](../_modules/static_frame/core/node_re.html#InterfaceRe.fullmatch)
    :   If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match.

        Parameters:
        :   * **pos** – Gives an index in the string where the search is to start; it defaults to 0.
            * **endpos** – Limits how far the string will be searched; it will be as if the string is endpos characters long.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt
    <Batch max_workers=None>
    >>> bt.via_re('123').fullmatch().to_frame()
    <Frame>
    <Index>                   a      b      c        <<U1>
    <IndexHierarchy>
    i                p        False  False  nan
    i                q        False  False  nan
    i                r        False  False  nan
    j                0        False  False  False
    j                1        False  False  False
    j                2        False  False  False
    j                3        False  True   False
    <<U1>            <object> <bool> <bool> <object>

    ```

Batch.via\_re(*pattern*, *flags).split(maxsplit*)
:   via\_re *= <function Batch.via\_re>*[[source]](../_modules/static_frame/core/batch.html#Batch.via_re)

    InterfaceRe.split(*maxsplit=0*)[[source]](../_modules/static_frame/core/node_re.html#InterfaceRe.split)
    :   Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple.

        Parameters:
        :   **maxsplit** – If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt
    <Batch max_workers=None>
    >>> bt.via_re('[X123]').split().to_frame()
    <Frame>
    <Index>                   a           b                c                    <<U1>
    <IndexHierarchy>
    i                p        ('0',)      ('', '')         nan
    i                q        ('', '')    ('', '')         nan
    i                r        ('4',)      ('5',)           nan
    j                0        ('', '0.0') ('qrs ',)        ('', '5', '7-0', ...
    j                1        ('', '.0')  ('', 'YZ')       ('', '5', '7-04-0...
    j                2        ('nan',)    ('',)            ('NaT',)
    j                3        ('', '.0')  ('', '', '', '') ('', '5', '7-04-0...
    <<U1>            <object> <object>    <object>         <object>

    ```

Batch.via\_re(*pattern*, *flags).findall(pos*, *endpos*)
:   via\_re *= <function Batch.via\_re>*[[source]](../_modules/static_frame/core/batch.html#Batch.via_re)

    InterfaceRe.findall(*pos=0*, *endpos=None*)[[source]](../_modules/static_frame/core/node_re.html#InterfaceRe.findall)
    :   Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result.

        Parameters:
        :   * **pos** – Gives an index in the string where the search is to start; it defaults to 0.
            * **endpos** – Limits how far the string will be searched; it will be as if the string is endpos characters long.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt
    <Batch max_workers=None>
    >>> bt.via_re('[X123]').findall().to_frame()
    <Frame>
    <Index>                   a        b               c                    <<U1>
    <IndexHierarchy>
    i                p        ()       ('1',)          nan
    i                q        ('2',)   ('3',)          nan
    i                r        ()       ()              nan
    j                0        ('1',)   ()              ('1', '1', '1', '1')
    j                1        ('2',)   ('X',)          ('1', '1', '1')
    j                2        ()       ()              ()
    j                3        ('2',)   ('1', '2', '3') ('1', '1', '1')
    <<U1>            <object> <object> <object>        <object>

    ```

Batch.via\_re(*pattern*, *flags).sub(repl*, *count*)
:   via\_re *= <function Batch.via\_re>*[[source]](../_modules/static_frame/core/batch.html#Batch.via_re)

    InterfaceRe.sub(*repl*, *count=0*)[[source]](../_modules/static_frame/core/node_re.html#InterfaceRe.sub)
    :   Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement `repl`. If the pattern is not found, the string is returned unchanged.

        Parameters:
        :   * **repl** – A string or a function; if it is a string, any backslash escapes in it are processed.
            * **count** – The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt
    <Batch max_workers=None>
    >>> bt.via_re('[X123]').sub('==').to_frame()
    <Frame>
    <Index>                   a     b      c              <<U1>
    <IndexHierarchy>
    i                p        0     ==     nan
    i                q        ==    ==     nan
    i                r        4     5      nan
    j                0        ==0.0 qrs    ==5==7-0==-0==
    j                1        ==.0  ==YZ   ==5==7-04-0==
    j                2        nan          NaT
    j                3        ==.0  ====== ==5==7-04-0==
    <<U1>            <object> <<U5> <<U6>  <object>

    ```

Batch.via\_re(*pattern*, *flags).subn(repl*, *count*)
:   via\_re *= <function Batch.via\_re>*[[source]](../_modules/static_frame/core/batch.html#Batch.via_re)

    InterfaceRe.subn(*repl*, *count=0*)[[source]](../_modules/static_frame/core/node_re.html#InterfaceRe.subn)
    :   Perform the same operation as sub(), but return a tuple (new\_string, number\_of\_subs\_made).

        Parameters:
        :   * **repl** – A string or a function; if it is a string, any backslash escapes in it are processed.
            * **count** – The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt
    <Batch max_workers=None>
    >>> bt.via_re('[X123]').subn('==', 1).to_frame()
    <Frame>
    <Index>                   a            b           c                  <<U1>
    <IndexHierarchy>
    i                p        ('0', 0)     ('==', 1)   nan
    i                q        ('==', 1)    ('==', 1)   nan
    i                r        ('4', 0)     ('5', 0)    nan
    j                0        ('==0.0', 1) ('qrs ', 0) ('==517-01-01', 1)
    j                1        ('==.0', 1)  ('==YZ', 1) ('==517-04-01', 1)
    j                2        ('nan', 0)   ('', 0)     ('NaT', 0)
    j                3        ('==.0', 1)  ('==23', 1) ('==517-04-01', 1)
    <<U1>            <object> <object>     <object>    <object>

    ```

[Batch](batch.html#api-detail-batch): [Constructor](batch-constructor.html#api-detail-batch-constructor) | [Exporter](batch-exporter.html#api-detail-batch-exporter) | [Attribute](batch-attribute.html#api-detail-batch-attribute) | [Method](batch-method.html#api-detail-batch-method) | [Dictionary-Like](batch-dictionary_like.html#api-detail-batch-dictionary-like) | [Display](batch-display.html#api-detail-batch-display) | [Selector](batch-selector.html#api-detail-batch-selector) | [Operator Binary](batch-operator_binary.html#api-detail-batch-operator-binary) | [Operator Unary](batch-operator_unary.html#api-detail-batch-operator-unary) | [Accessor Values](batch-accessor_values.html#api-detail-batch-accessor-values) | [Accessor Datetime](batch-accessor_datetime.html#api-detail-batch-accessor-datetime) | [Accessor String](batch-accessor_string.html#api-detail-batch-accessor-string) | [Accessor Transpose](batch-accessor_transpose.html#api-detail-batch-accessor-transpose) | [Accessor Fill Value](batch-accessor_fill_value.html#api-detail-batch-accessor-fill-value) | [Accessor Regular Expression](#api-detail-batch-accessor-regular-expression) | [Accessor Hashlib](batch-accessor_hashlib.html#api-detail-batch-accessor-hashlib) | [Accessor Type Clinic](batch-accessor_type_clinic.html#api-detail-batch-accessor-type-clinic) | [Accessor Reduce](batch-accessor_reduce.html#api-detail-batch-accessor-reduce)

[Previous](batch-accessor_fill_value.html "Detail: Batch: Accessor Fill Value")
[Next](batch-accessor_hashlib.html "Detail: Batch: Accessor Hashlib")

---

© Copyright 2025, Christopher Ariza.
Last updated on Apr 29, 2025.

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme)
provided by [Read the Docs](https://readthedocs.org).