[![Logo](../_static/sf-logo-web_icon-small.png)](../index.md)

Quick Start

* [static-frame](../readme.md)
* [License](../license.md)

Introduction

* [About StaticFrame](../intro.md)
* [Media](../intro.html#media)
* [What is New in StaticFrame](../new.md)
* [Contributing](../contributing.md)

Articles

* [Improving Code Quality with Array and DataFrame Type Hints](../articles/guard.md)
* [Type-Hinting DataFrames for Static Analysis and Runtime Validation](../articles/ftyping.md)
* [Faster DataFrame Serialization](../articles/serialize.md)
* [The Performance Advantage of No-Copy DataFrame Operations](../articles/no_copy.md)
* [Memoizing DataFrame Functions: Using Hashable DataFrames and Message Digests to Optimize Repeated Calculations](../articles/hash.md)
* [Using Higher-Order Containers to Efficiently Process 7,163 (or More) DataFrames](../articles/uhoc.md)
* [One Fill Value Is Not Enough: Preserving Columnar Types When Reindexing DataFrames](../articles/fill_value.md)
* [Ten Reasons to Use StaticFrame Instead of Pandas](../articles/upgrade.md)
* [Boring Indices & Where to Find Them: The Auto-Incremented Integer Index in StaticFrame](../articles/aiii.md)

API Overview

* [Overview: Series](../api_overview/series.md)
* [Overview: SeriesHE](../api_overview/series_he.md)
* [Overview: Frame](../api_overview/frame.md)
* [Overview: FrameGO](../api_overview/frame_go.md)
* [Overview: FrameHE](../api_overview/frame_he.md)
* [Overview: Bus](../api_overview/bus.md)
* [Overview: Batch](../api_overview/batch.md)
* [Overview: Yarn](../api_overview/yarn.md)
* [Overview: Quilt](../api_overview/quilt.md)
* [Overview: Index](../api_overview/index.md)
* [Overview: IndexGO](../api_overview/index_go.md)
* [Overview: IndexHierarchy](../api_overview/index_hierarchy.md)
* [Overview: IndexHierarchyGO](../api_overview/index_hierarchy_go.md)
* [Overview: IndexYear](../api_overview/index_year.md)
* [Overview: IndexYearGO](../api_overview/index_year_go.md)
* [Overview: IndexYearMonth](../api_overview/index_year_month.md)
* [Overview: IndexYearMonthGO](../api_overview/index_year_month_go.md)
* [Overview: IndexDate](../api_overview/index_date.md)
* [Overview: IndexDateGO](../api_overview/index_date_go.md)
* [Overview: IndexMinute](../api_overview/index_minute.md)
* [Overview: IndexMinuteGO](../api_overview/index_minute_go.md)
* [Overview: IndexHour](../api_overview/index_hour.md)
* [Overview: IndexHourGO](../api_overview/index_hour_go.md)
* [Overview: IndexSecond](../api_overview/index_second.md)
* [Overview: IndexSecondGO](../api_overview/index_second_go.md)
* [Overview: IndexMillisecond](../api_overview/index_millisecond.md)
* [Overview: IndexMillisecondGO](../api_overview/index_millisecond_go.md)
* [Overview: IndexMicrosecond](../api_overview/index_microsecond.md)
* [Overview: IndexMicrosecondGO](../api_overview/index_microsecond_go.md)
* [Overview: IndexNanosecond](../api_overview/index_nanosecond.md)
* [Overview: IndexNanosecondGO](../api_overview/index_nanosecond_go.md)
* [Overview: HLoc](../api_overview/hloc.md)
* [Overview: ILoc](../api_overview/iloc.md)
* [Overview: TypeClinic](../api_overview/type_clinic.md)
* [Overview: CallGuard](../api_overview/call_guard.md)
* [Overview: ClinicResult](../api_overview/clinic_result.md)
* [Overview: Require](../api_overview/require.md)
* [Overview: WWW](../api_overview/www.md)
* [Overview: FillValueAuto](../api_overview/fill_value_auto.md)
* [Overview: DisplayActive](../api_overview/display_active.md)
* [Overview: DisplayConfig](../api_overview/display_config.md)
* [Overview: StoreConfig](../api_overview/store_config.md)
* [Overview: StoreFilter](../api_overview/store_filter.md)
* [Overview: IndexAutoFactory](../api_overview/index_auto_factory.md)
* [Overview: IndexDefaultConstructorFactory](../api_overview/index_default_constructor_factory.md)
* [Overview: IndexAutoConstructorFactory](../api_overview/index_auto_constructor_factory.md)
* [Overview: NPZ](../api_overview/npz.md)
* [Overview: NPY](../api_overview/npy.md)
* [Overview: MemoryDisplay](../api_overview/memory_display.md)
* [Overview: Platform](../api_overview/platform.md)

API Detail

* [Detail: Series](series.md)
* [Detail: SeriesHE](series_he.md)
* [Detail: Frame](frame.md)
* [Detail: FrameGO](frame_go.md)
* [Detail: FrameHE](frame_he.md)
* [Detail: Bus](bus.md)
* [Detail: Batch](batch.md)
* [Detail: Yarn](yarn.md)
* [Detail: Quilt](quilt.md)
* [Detail: Index](index.md)
* [Detail: IndexGO](index_go.md)
* [Detail: IndexHierarchy](index_hierarchy.md)
* [Detail: IndexHierarchyGO](index_hierarchy_go.md)
* [Detail: IndexYear](index_year.md)
* [Detail: IndexYearGO](index_year_go.md)
* [Detail: IndexYearMonth](index_year_month.md)
* [Detail: IndexYearMonthGO](index_year_month_go.md)
* [Detail: IndexDate](index_date.md)
* [Detail: IndexDateGO](index_date_go.md)
* [Detail: IndexMinute](index_minute.md)
* [Detail: IndexMinuteGO](index_minute_go.md)
* [Detail: IndexHour](index_hour.md)
* [Detail: IndexHourGO](index_hour_go.md)
* [Detail: IndexSecond](index_second.md)
* [Detail: IndexSecondGO](index_second_go.md)
* [Detail: IndexMillisecond](index_millisecond.md)
* [Detail: IndexMillisecondGO](index_millisecond_go.md)
* [Detail: IndexMicrosecond](index_microsecond.md)
* [Detail: IndexMicrosecondGO](index_microsecond_go.md)
* [Detail: IndexNanosecond](index_nanosecond.md)
* [Detail: IndexNanosecondGO](index_nanosecond_go.md)
* [Detail: HLoc](hloc.md)
* [Detail: ILoc](iloc.md)
* [Detail: TypeClinic](type_clinic.md)
* [Detail: CallGuard](call_guard.md)
* [Detail: ClinicResult](clinic_result.md)
* [Detail: Require](require.md)
* [Detail: WWW](www.md)
* [Detail: FillValueAuto](fill_value_auto.md)
* [Detail: DisplayActive](display_active.md)
* [Detail: DisplayConfig](display_config.md)
* [Detail: StoreConfig](store_config.md)
* [Detail: StoreFilter](store_filter.md)
* [Detail: IndexAutoFactory](index_auto_factory.md)
* [Detail: IndexDefaultConstructorFactory](index_default_constructor_factory.md)
* [Detail: IndexAutoConstructorFactory](index_auto_constructor_factory.md)
* [Detail: NPZ](npz.md)
* [Detail: NPY](npy.md)
* [Detail: MemoryDisplay](memory_display.md)
* [Detail: Platform](platform.md)

[StaticFrame](../index.md)

* Detail: Frame: Iterator
* [View page source](../_sources/api_detail/frame-iterator.rst.txt)

[Previous](frame-selector.html "Detail: Frame: Selector")
[Next](frame-operator_binary.html "Detail: Frame: Operator Binary")

---

# Detail: Frame: Iterator[](#detail-frame-iterator "Link to this heading")

[Overview: Frame: Iterator](../api_overview/frame-iterator.html#api-overview-frame-iterator)

Frame.iter\_array(*\**, *axis*)
:   iter\_array
    :   Iterator of `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_array())
    (array([10, -2,  0,  0]), array([ 8, -3,  8,  0]), array([ 1,  0,  9, 12]))

    ```

Frame.iter\_array(*\**, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_array
    :   Iterator of `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_array().apply(lambda v: v.sum())
    <Series>
    <Index>
    a        8
    b        13
    c        22
    <<U1>    <int64>

    ```

Frame.iter\_array(*\**, *axis).apply\_iter(func*)
:   iter\_array
    :   Iterator of `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_iter(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_array().apply_iter(lambda v: v.sum()))
    (np.int64(8), np.int64(13), np.int64(22))

    ```

Frame.iter\_array(*\**, *axis).apply\_iter\_items(func*)
:   iter\_array
    :   Iterator of `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_iter\_items(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter_items)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_array().apply_iter_items(lambda v: v.sum()))
    ((np.str_('a'), np.int64(8)), (np.str_('b'), np.int64(13)), (np.str_('c'), np.int64(22)))

    ```

Frame.iter\_array(*\**, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_array
    :   Iterator of `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_pool)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_array().apply_pool(lambda v: v.sum(), use_threads=True)
    <Series>
    <Index>
    a        8
    b        13
    c        22
    <<U1>    <int64>

    ```

Frame.iter\_array\_items(*\**, *axis*)
:   iter\_array\_items
    :   Iterator of pairs of label, `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_array_items())
    ((np.str_('a'), array([10, -2,  0,  0])), (np.str_('b'), array([ 8, -3,  8,  0])), (np.str_('c'), array([ 1,  0,  9, 12])))

    ```

Frame.iter\_array\_items(*\**, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_array\_items
    :   Iterator of pairs of label, `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_array_items().apply(lambda k, v: v.sum() if k != 'b' else -1)
    <Series>
    <Index>
    a        8
    b        -1
    c        22
    <<U1>    <int64>

    ```

Frame.iter\_array\_items(*\**, *axis).apply\_iter(func*)
:   iter\_array\_items
    :   Iterator of pairs of label, `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_iter(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_array_items().apply_iter(lambda k, v: v.sum() if k != 'b' else -1))
    (np.int64(8), -1, np.int64(22))

    ```

Frame.iter\_array\_items(*\**, *axis).apply\_iter\_items(func*)
:   iter\_array\_items
    :   Iterator of pairs of label, `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_iter\_items(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter_items)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_array_items().apply_iter_items(lambda k, v: v.sum() if k != 'b' else -1))
    ((np.str_('a'), np.int64(8)), (np.str_('b'), -1), (np.str_('c'), np.int64(22)))

    ```

Frame.iter\_array\_items(*\**, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_array\_items
    :   Iterator of pairs of label, `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_pool)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_array_items().apply_pool(lambda pair: pair[1].sum() if pair[0] != 'b' else -1, use_threads=True)
    <Series>
    <Index>
    a        8
    b        -1
    c        22
    <<U1>    <int64>

    ```

Frame.iter\_element(*\**, *axis*)
:   iter\_element
    :   Iterator of elements, ordered by row then column.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_element())
    (np.int64(10), np.int64(8), np.int64(1), np.int64(-2), np.int64(-3), np.int64(0), np.int64(0), np.int64(8), np.int64(9), np.int64(0), np.int64(0), np.int64(12))

    ```

Frame.iter\_element(*\**, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_element
    :   Iterator of elements, ordered by row then column.

    IterNodeDelegateMapable.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_element().apply(lambda e: e > 5)
    <Frame>
    <Index> a      b      c      <<U1>
    <Index>
    p       True   True   False
    q       False  False  False
    r       False  True   True
    s       False  False  True
    <<U1>   <bool> <bool> <bool>

    ```

Frame.iter\_element(*\**, *axis).apply\_iter(func*)
:   iter\_element
    :   Iterator of elements, ordered by row then column.

    IterNodeDelegateMapable.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_element().apply_iter(lambda e: e > 10))
    (np.False_, np.False_, np.False_, np.False_, np.False_, np.False_, np.False_, np.False_, np.False_, np.False_, np.False_, np.True_)

    ```

Frame.iter\_element(*\**, *axis).apply\_iter\_items(func*)
:   iter\_element
    :   Iterator of elements, ordered by row then column.

    IterNodeDelegateMapable.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_element().apply_iter_items(lambda e: e > 10))
    (((np.str_('p'), np.str_('a')), np.False_), ((np.str_('p'), np.str_('b')), np.False_), ((np.str_('p'), np.str_('c')), np.False_), ((np.str_('q'), np.str_('a')), np.False_), ((np.str_('q'), np.str_('b')), np.False_), ((np.str_('q'), np.str_('c')), np.False_), ((np.str_('r'), np.str_('a')), np.False_), ((np.str_('r'), np.str_('b')), np.False_), ((np.str_('r'), np.str_('c')), np.False_), ((np.str_('s'), np.str_('a')), np.False_), ((np.str_('s'), np.str_('b')), np.False_), ((np.str_('s'), np.str_('c')), np.True_))

    ```

Frame.iter\_element(*\**, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_element
    :   Iterator of elements, ordered by row then column.

    IterNodeDelegateMapable.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_element().apply_pool(lambda e: e > 5, use_threads=True)
    <Frame>
    <Index> a      b      c      <<U1>
    <Index>
    p       True   True   False
    q       False  False  False
    r       False  True   True
    s       False  False  True
    <<U1>   <bool> <bool> <bool>

    ```

Frame.iter\_element(*\**, *axis).map\_all(mapping*, *\**, *dtype*, *name*, *index\_constructor*)
:   iter\_element
    :   Iterator of elements, ordered by row then column.

    IterNodeDelegateMapable.map\_all(*mapping*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((1, 2, 0, 0), (2, 1, 2, 0), (1, 0, 2, 1)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          1       2       1
    q          2       1       0
    r          0       2       2
    s          0       0       1
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_element().map_all({0: 200, 1: -1, 2: 45})
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    p       -1      45      -1
    q       45      -1      200
    r       200     45      45
    s       200     200     -1
    <<U1>   <int64> <int64> <int64>

    ```

Frame.iter\_element(*\**, *axis).map\_all\_iter(mapping*)
:   iter\_element
    :   Iterator of elements, ordered by row then column.

    IterNodeDelegateMapable.map\_all\_iter(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all_iter)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> f = sf.Frame.from_fields(((1, 2, 0, 0), (2, 1, 2, 0), (1, 0, 2, 1)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          1       2       1
    q          2       1       0
    r          0       2       2
    s          0       0       1
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_element().map_all_iter({0: 200, 1: -1, 2: 45}))
    (-1, 45, -1, 45, -1, 200, 200, 45, 45, 200, 200, -1)

    ```

Frame.iter\_element(*\**, *axis).map\_all\_iter\_items(mapping*)
:   iter\_element
    :   Iterator of elements, ordered by row then column.

    IterNodeDelegateMapable.map\_all\_iter\_items(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all_iter_items)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> f = sf.Frame.from_fields(((1, 2, 0, 0), (2, 1, 2, 0), (1, 0, 2, 1)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          1       2       1
    q          2       1       0
    r          0       2       2
    s          0       0       1
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_element().map_all_iter_items({0: 200, 1: -1, 2: 45}))
    (((np.str_('p'), np.str_('a')), -1), ((np.str_('p'), np.str_('b')), 45), ((np.str_('p'), np.str_('c')), -1), ((np.str_('q'), np.str_('a')), 45), ((np.str_('q'), np.str_('b')), -1), ((np.str_('q'), np.str_('c')), 200), ((np.str_('r'), np.str_('a')), 200), ((np.str_('r'), np.str_('b')), 45), ((np.str_('r'), np.str_('c')), 45), ((np.str_('s'), np.str_('a')), 200), ((np.str_('s'), np.str_('b')), 200), ((np.str_('s'), np.str_('c')), -1))

    ```

Frame.iter\_element(*\**, *axis).map\_any(mapping*, *\**, *dtype*, *name*, *index\_constructor*)
:   iter\_element
    :   Iterator of elements, ordered by row then column.

    IterNodeDelegateMapable.map\_any(*mapping*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any)
    :   Apply a mapping; for values not in the mapping, the value is returned. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((1, 2, 0, 0), (2, 1, 2, 0), (1, 0, 2, 1)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          1       2       1
    q          2       1       0
    r          0       2       2
    s          0       0       1
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_element().map_any({1: -1, 2: 45})
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    p       -1      45      -1
    q       45      -1      0
    r       0       45      45
    s       0       0       -1
    <<U1>   <int64> <int64> <int64>

    ```

Frame.iter\_element(*\**, *axis).map\_any\_iter(mapping*)
:   iter\_element
    :   Iterator of elements, ordered by row then column.

    IterNodeDelegateMapable.map\_any\_iter(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any_iter)
    :   Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> f = sf.Frame.from_fields(((1, 2, 0, 0), (2, 1, 2, 0), (1, 0, 2, 1)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          1       2       1
    q          2       1       0
    r          0       2       2
    s          0       0       1
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_element().map_any_iter({1: -1, 2: 45}))
    (-1, 45, -1, 45, -1, np.int64(0), np.int64(0), 45, 45, np.int64(0), np.int64(0), -1)

    ```

Frame.iter\_element(*\**, *axis).map\_any\_iter\_items(mapping*)
:   iter\_element
    :   Iterator of elements, ordered by row then column.

    IterNodeDelegateMapable.map\_any\_iter\_items(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any_iter_items)
    :   Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> f = sf.Frame.from_fields(((1, 2, 0, 0), (2, 1, 2, 0), (1, 0, 2, 1)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          1       2       1
    q          2       1       0
    r          0       2       2
    s          0       0       1
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_element().map_any_iter_items({1: -1, 2: 45}))
    (((np.str_('p'), np.str_('a')), -1), ((np.str_('p'), np.str_('b')), 45), ((np.str_('p'), np.str_('c')), -1), ((np.str_('q'), np.str_('a')), 45), ((np.str_('q'), np.str_('b')), -1), ((np.str_('q'), np.str_('c')), np.int64(0)), ((np.str_('r'), np.str_('a')), np.int64(0)), ((np.str_('r'), np.str_('b')), 45), ((np.str_('r'), np.str_('c')), 45), ((np.str_('s'), np.str_('a')), np.int64(0)), ((np.str_('s'), np.str_('b')), np.int64(0)), ((np.str_('s'), np.str_('c')), -1))

    ```

Frame.iter\_element(*\**, *axis).map\_fill(mapping*, *\**, *fill\_value*, *dtype*, *name*, *index\_constructor*)
:   iter\_element
    :   Iterator of elements, ordered by row then column.

    IterNodeDelegateMapable.map\_fill(*mapping*, */*, *\**, *fill\_value=nan*, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((1, 2, 0, 0), (2, 1, 2, 0), (1, 0, 2, 1)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          1       2       1
    q          2       1       0
    r          0       2       2
    s          0       0       1
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_element().map_fill({1: -1, 2: 45}, fill_value=np.nan)
    <Frame>
    <Index> a         b         c         <<U1>
    <Index>
    p       -1.0      45.0      -1.0
    q       45.0      -1.0      nan
    r       nan       45.0      45.0
    s       nan       nan       -1.0
    <<U1>   <float64> <float64> <float64>

    ```

Frame.iter\_element(*\**, *axis).map\_fill\_iter(mapping*, *\**, *fill\_value*)
:   iter\_element
    :   Iterator of elements, ordered by row then column.

    IterNodeDelegateMapable.map\_fill\_iter(*mapping*, */*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill_iter)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. A generator of resulting values.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.

    ```
    >>> f = sf.Frame.from_fields(((1, 2, 0, 0), (2, 1, 2, 0), (1, 0, 2, 1)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          1       2       1
    q          2       1       0
    r          0       2       2
    s          0       0       1
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_element().map_fill_iter({1: -1, 2: 45}, fill_value=np.nan))
    (-1, 45, -1, 45, -1, nan, nan, 45, 45, nan, nan, -1)

    ```

Frame.iter\_element(*\**, *axis).map\_fill\_iter\_items(mapping*, *\**, *fill\_value*)
:   iter\_element
    :   Iterator of elements, ordered by row then column.

    IterNodeDelegateMapable.map\_fill\_iter\_items(*mapping*, */*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill_iter_items)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. A generator of resulting key, value pairs.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.

    ```
    >>> f = sf.Frame.from_fields(((1, 2, 0, 0), (2, 1, 2, 0), (1, 0, 2, 1)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          1       2       1
    q          2       1       0
    r          0       2       2
    s          0       0       1
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_element().map_fill_iter_items({1: -1, 2: 45}, fill_value=np.nan))
    (((np.str_('p'), np.str_('a')), -1), ((np.str_('p'), np.str_('b')), 45), ((np.str_('p'), np.str_('c')), -1), ((np.str_('q'), np.str_('a')), 45), ((np.str_('q'), np.str_('b')), -1), ((np.str_('q'), np.str_('c')), nan), ((np.str_('r'), np.str_('a')), nan), ((np.str_('r'), np.str_('b')), 45), ((np.str_('r'), np.str_('c')), 45), ((np.str_('s'), np.str_('a')), nan), ((np.str_('s'), np.str_('b')), nan), ((np.str_('s'), np.str_('c')), -1))

    ```

Frame.iter\_element\_items(*\**, *axis*)
:   iter\_element\_items
    :   Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_element_items())
    (((np.str_('p'), np.str_('a')), np.int64(10)), ((np.str_('p'), np.str_('b')), np.int64(8)), ((np.str_('p'), np.str_('c')), np.int64(1)), ((np.str_('q'), np.str_('a')), np.int64(-2)), ((np.str_('q'), np.str_('b')), np.int64(-3)), ((np.str_('q'), np.str_('c')), np.int64(0)), ((np.str_('r'), np.str_('a')), np.int64(0)), ((np.str_('r'), np.str_('b')), np.int64(8)), ((np.str_('r'), np.str_('c')), np.int64(9)), ((np.str_('s'), np.str_('a')), np.int64(0)), ((np.str_('s'), np.str_('b')), np.int64(0)), ((np.str_('s'), np.str_('c')), np.int64(12)))

    ```

Frame.iter\_element\_items(*\**, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_element\_items
    :   Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.

    IterNodeDelegateMapable.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((1, 2, 0, 0), (2, 1, 2, 0), (1, 0, 2, 1)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          1       2       1
    q          2       1       0
    r          0       2       2
    s          0       0       1
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_element_items().apply(lambda k, v: v > 1 if k != ('q', 'b') else 'x')
    <Frame>
    <Index> a      b        c      <<U1>
    <Index>
    p       False  True     False
    q       True   x        False
    r       False  True     True
    s       False  False    False
    <<U1>   <bool> <object> <bool>

    ```

Frame.iter\_element\_items(*\**, *axis).apply\_iter(func*)
:   iter\_element\_items
    :   Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.

    IterNodeDelegateMapable.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((1, 2, 0, 0), (2, 1, 2, 0), (1, 0, 2, 1)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          1       2       1
    q          2       1       0
    r          0       2       2
    s          0       0       1
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_element_items().apply_iter(lambda k, v: v > 1 if k != ('q', 'b') else 'x'))
    (np.False_, np.True_, np.False_, np.True_, 'x', np.False_, np.False_, np.True_, np.True_, np.False_, np.False_, np.False_)

    ```

Frame.iter\_element\_items(*\**, *axis).apply\_iter\_items(func*)
:   iter\_element\_items
    :   Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.

    IterNodeDelegateMapable.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((1, 2, 0, 0), (2, 1, 2, 0), (1, 0, 2, 1)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          1       2       1
    q          2       1       0
    r          0       2       2
    s          0       0       1
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_element_items().apply_iter_items(lambda k, v: v > 1 if k != ('q', 'b') else 'x'))
    (((np.str_('p'), np.str_('a')), np.False_), ((np.str_('p'), np.str_('b')), np.True_), ((np.str_('p'), np.str_('c')), np.False_), ((np.str_('q'), np.str_('a')), np.True_), ((np.str_('q'), np.str_('b')), 'x'), ((np.str_('q'), np.str_('c')), np.False_), ((np.str_('r'), np.str_('a')), np.False_), ((np.str_('r'), np.str_('b')), np.True_), ((np.str_('r'), np.str_('c')), np.True_), ((np.str_('s'), np.str_('a')), np.False_), ((np.str_('s'), np.str_('b')), np.False_), ((np.str_('s'), np.str_('c')), np.False_))

    ```

Frame.iter\_element\_items(*\**, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_element\_items
    :   Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.

    IterNodeDelegateMapable.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

    ```
    >>> def func(pair): return pair[1] > 0 and pair[0] == ('q', 'b')
    >>> f = sf.Frame.from_fields(((1, 2, 0, 0), (2, 1, 2, 0), (1, 0, 2, 1)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          1       2       1
    q          2       1       0
    r          0       2       2
    s          0       0       1
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_element_items().apply_pool(func, use_threads=True)
    <Frame>
    <Index> a      b      c      <<U1>
    <Index>
    p       False  False  False
    q       False  True   False
    r       False  False  False
    s       False  False  False
    <<U1>   <bool> <bool> <bool>

    ```

Frame.iter\_element\_items(*\**, *axis).map\_all(mapping*, *\**, *dtype*, *name*, *index\_constructor*)
:   iter\_element\_items
    :   Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.

    IterNodeDelegateMapable.map\_all(*mapping*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> f.iter_element_items().map_all({(('p', 'a'), 2): 200, (('p', 'b'), 3): -1, (('q', 'a'), 9): 45, (('q', 'b'), 8): 1})
    <Frame>
    <Index> a       b       <<U1>
    <Index>
    p       200     -1
    q       45      1
    <<U1>   <int64> <int64>

    ```

Frame.iter\_element\_items(*\**, *axis).map\_all\_iter(mapping*)
:   iter\_element\_items
    :   Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.

    IterNodeDelegateMapable.map\_all\_iter(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all_iter)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_element_items().map_all_iter({(('p', 'a'), 2): 200, (('p', 'b'), 3): -1, (('q', 'a'), 9): 45, (('q', 'b'), 8): 1}))
    (200, -1, 45, 1)

    ```

Frame.iter\_element\_items(*\**, *axis).map\_all\_iter\_items(mapping*)
:   iter\_element\_items
    :   Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.

    IterNodeDelegateMapable.map\_all\_iter\_items(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all_iter_items)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_element_items().map_all_iter_items({(('p', 'a'), 2): 200, (('p', 'b'), 3): -1, (('q', 'a'), 9): 45, (('q', 'b'), 8): 1}))
    (((np.str_('p'), np.str_('a')), 200), ((np.str_('p'), np.str_('b')), -1), ((np.str_('q'), np.str_('a')), 45), ((np.str_('q'), np.str_('b')), 1))

    ```

Frame.iter\_element\_items(*\**, *axis).map\_any(mapping*, *\**, *dtype*, *name*, *index\_constructor*)
:   iter\_element\_items
    :   Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.

    IterNodeDelegateMapable.map\_any(*mapping*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any)
    :   Apply a mapping; for values not in the mapping, the value is returned. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> f.iter_element_items().map_any({(('p', 'a'), 2): 200, (('q', 'b'), 8): 1})
    <Frame>
    <Index> a       b       <<U1>
    <Index>
    p       200     3
    q       9       1
    <<U1>   <int64> <int64>

    ```

Frame.iter\_element\_items(*\**, *axis).map\_any\_iter(mapping*)
:   iter\_element\_items
    :   Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.

    IterNodeDelegateMapable.map\_any\_iter(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any_iter)
    :   Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_element_items().map_any_iter({(('p', 'a'), 2): 200, (('q', 'b'), 8): 1}))
    (200, np.int64(3), np.int64(9), 1)

    ```

Frame.iter\_element\_items(*\**, *axis).map\_any\_iter\_items(mapping*)
:   iter\_element\_items
    :   Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.

    IterNodeDelegateMapable.map\_any\_iter\_items(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any_iter_items)
    :   Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_element_items().map_any_iter_items({(('p', 'a'), 2): 200, (('q', 'b'), 8): 1}))
    (((np.str_('p'), np.str_('a')), 200), ((np.str_('p'), np.str_('b')), np.int64(3)), ((np.str_('q'), np.str_('a')), np.int64(9)), ((np.str_('q'), np.str_('b')), 1))

    ```

Frame.iter\_element\_items(*\**, *axis).map\_fill(mapping*, *\**, *fill\_value*, *dtype*, *name*, *index\_constructor*)
:   iter\_element\_items
    :   Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.

    IterNodeDelegateMapable.map\_fill(*mapping*, */*, *\**, *fill\_value=nan*, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> f.iter_element_items().map_fill({(('p', 'a'), 2): 200, (('q', 'b'), 8): 1}, fill_value=-1)
    <Frame>
    <Index> a       b       <<U1>
    <Index>
    p       200     -1
    q       -1      1
    <<U1>   <int64> <int64>

    ```

Frame.iter\_element\_items(*\**, *axis).map\_fill\_iter(mapping*, *\**, *fill\_value*)
:   iter\_element\_items
    :   Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.

    IterNodeDelegateMapable.map\_fill\_iter(*mapping*, */*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill_iter)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. A generator of resulting values.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_element_items().map_fill_iter({(('p', 'a'), 2): 200, (('q', 'b'), 8): 1}, fill_value=-1))
    (200, -1, -1, 1)

    ```

Frame.iter\_element\_items(*\**, *axis).map\_fill\_iter\_items(mapping*, *\**, *fill\_value*)
:   iter\_element\_items
    :   Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.

    IterNodeDelegateMapable.map\_fill\_iter\_items(*mapping*, */*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill_iter_items)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. A generator of resulting key, value pairs.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_element_items().map_fill_iter_items({(('p', 'a'), 2): 200, (('q', 'b'), 8): 1}, fill_value=-1))
    (((np.str_('p'), np.str_('a')), 200), ((np.str_('p'), np.str_('b')), -1), ((np.str_('q'), np.str_('a')), -1), ((np.str_('q'), np.str_('b')), 1))

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c'))
    (<Frame>
    <Index> a       b       c       <<U1>
    <Index>
    0       11      0       0
    2       10      3       0
    <int64> <int64> <int64> <int64>, <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    1       4       8       1
    3       2       8       1
    <int64> <int64> <int64> <int64>)

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    IterNodeDelegateReducible.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group('c').apply(lambda f: f['b'].sum())
    <Series>
    <Index: c>
    0          3
    1          16
    <int64>    <int64>

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).apply\_iter(func*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    IterNodeDelegateReducible.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').apply_iter(lambda f: f['b'].sum()))
    (np.int64(3), np.int64(16))

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).apply\_iter\_items(func*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    IterNodeDelegateReducible.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').apply_iter_items(lambda f: f['b'].sum()))
    ((np.int64(0), np.int64(3)), (np.int64(1), np.int64(16)))

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    IterNodeDelegateReducible.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

    ```
    >>> def func(f): return f['b'].sum()
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group('c').apply_pool(func, use_threads=True)
    <Series>
    <Index: c>
    0          3
    1          16
    <int64>    <int64>

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').reduce.from_func(lambda f: f.iloc[1:]).keys())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').reduce.from_func(lambda f: f.iloc[1:]).__iter__())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).items(*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').reduce.from_func(lambda f: f.iloc[1:]).items())
    ((np.int64(0), <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    2       10      3       0
    <int64> <int64> <int64> <int64>), (np.int64(1), <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    3       2       8       1
    <int64> <int64> <int64> <int64>))

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).values(*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').reduce.from_func(lambda f: f.iloc[1:]).values())
    (<Frame>
    <Index> a       b       c       <<U1>
    <Index>
    2       10      3       0
    <int64> <int64> <int64> <int64>, <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    3       2       8       1
    <int64> <int64> <int64> <int64>)

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group('c').reduce.from_func(lambda f: f.iloc[1:]).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    2       10      3       0
    3       2       8       1
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').reduce.from_map_func(np.min).keys())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').reduce.from_map_func(np.min).__iter__())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).items(*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').reduce.from_map_func(np.min).items())
    ((np.int64(0), <Series: 0>
    <Index>
    a           10
    b           0
    c           0
    <<U1>       <int64>), (np.int64(1), <Series: 1>
    <Index>
    a           2
    b           8
    c           1
    <<U1>       <int64>))

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).values(*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').reduce.from_map_func(np.min).values())
    (<Series: 0>
    <Index>
    a           10
    b           0
    c           0
    <<U1>       <int64>, <Series: 1>
    <Index>
    a           2
    b           8
    c           1
    <<U1>       <int64>)

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group('c').reduce.from_map_func(np.min).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    0       10      0       0
    1       2       8       1
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').reduce.from_label_map({'b': np.min, 'a': np.max}).keys())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').reduce.from_label_map({'b': np.min, 'a': np.max}).__iter__())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').reduce.from_label_map({'b': np.min, 'a': np.max}).items())
    ((np.int64(0), <Series: 0>
    <Index>
    b           0
    a           11
    <<U1>       <int64>), (np.int64(1), <Series: 1>
    <Index>
    b           8
    a           4
    <<U1>       <int64>))

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').reduce.from_label_map({'b': np.min, 'a': np.max}).values())
    (<Series: 0>
    <Index>
    b           0
    a           11
    <<U1>       <int64>, <Series: 1>
    <Index>
    b           8
    a           4
    <<U1>       <int64>)

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group('c').reduce.from_label_map({'b': np.min, 'a': np.max}).to_frame()
    <Frame>
    <Index> b       a       <<U1>
    <Index>
    0       0       11
    1       8       4
    <int64> <int64> <int64>

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).keys())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).__iter__())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).items())
    ((np.int64(0), <Series: 0>
    <Index>
    b-min       0
    b-max       3
    <<U5>       <int64>), (np.int64(1), <Series: 1>
    <Index>
    b-min       8
    b-max       8
    <<U5>       <int64>))

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group('c').reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).values())
    (<Series: 0>
    <Index>
    b-min       0
    b-max       3
    <<U5>       <int64>, <Series: 1>
    <Index>
    b-min       8
    b-max       8
    <<U5>       <int64>)

    ```

Frame.iter\_group(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group('c').reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).to_frame()
    <Frame>
    <Index> b-min   b-max   <<U5>
    <Index>
    0       0       3
    1       8       8
    <int64> <int64> <int64>

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c'))
    (array([[11,  0,  0],
           [10,  3,  0]]), array([[4, 8, 1],
           [2, 8, 1]]))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    IterNodeDelegateReducible.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_array('c').apply(lambda a: np.sum(a))
    <Series>
    <Index: c>
    0          24
    1          24
    <int64>    <int64>

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).apply\_iter(func*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    IterNodeDelegateReducible.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').apply_iter(lambda a: np.sum(a)))
    (np.int64(24), np.int64(24))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).apply\_iter\_items(func*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    IterNodeDelegateReducible.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').apply_iter_items(lambda a: np.sum(a)))
    ((np.int64(0), np.int64(24)), (np.int64(1), np.int64(24)))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    IterNodeDelegateReducible.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

    ```
    >>> def func(a): return np.sum(a)
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_array('c').apply_pool(func, use_threads=True)
    <Series>
    <Index: c>
    0          24
    1          24
    <int64>    <int64>

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').reduce.from_func(lambda a: a.sum(axis=0)).keys())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').reduce.from_func(lambda a: a.sum(axis=0)).__iter__())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).items(*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').reduce.from_func(lambda a: a.sum(axis=0)).items())
    ((np.int64(0), array([21,  3,  0])), (np.int64(1), array([ 6, 16,  2])))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).values(*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').reduce.from_func(lambda a: a.sum(axis=0)).values())
    (array([21,  3,  0]), array([ 6, 16,  2]))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_array('c').reduce.from_func(lambda a: a.sum(axis=0)).to_frame()
    <Frame>
    <Index> 0       <int64>
    <Index>
    0       21
    1       3
    2       0
    3       6
    4       16
    5       2
    <int64> <int64>

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').reduce.from_map_func(np.min).keys())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').reduce.from_map_func(np.min).__iter__())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).items(*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').reduce.from_map_func(np.min).items())
    ((np.int64(0), array([10,  0,  0])), (np.int64(1), array([2, 8, 1])))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).values(*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').reduce.from_map_func(np.min).values())
    (array([10,  0,  0]), array([2, 8, 1]))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_array('c').reduce.from_map_func(np.min).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    0       10      0       0
    1       2       8       1
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').reduce.from_label_map({'b': np.min, 'a': np.max}).keys())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').reduce.from_label_map({'b': np.min, 'a': np.max}).__iter__())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').reduce.from_label_map({'b': np.min, 'a': np.max}).items())
    ((np.int64(0), array([ 0, 11])), (np.int64(1), array([8, 4])))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').reduce.from_label_map({'b': np.min, 'a': np.max}).values())
    (array([ 0, 11]), array([8, 4]))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_array('c').reduce.from_label_map({'b': np.min, 'a': np.max}).to_frame()
    <Frame>
    <Index> b       a       <<U1>
    <Index>
    0       0       11
    1       8       4
    <int64> <int64> <int64>

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).keys())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).__iter__())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).items())
    ((np.int64(0), array([0, 3])), (np.int64(1), array([8, 8])))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array('c').reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).values())
    (array([0, 3]), array([8, 8]))

    ```

Frame.iter\_group\_array(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_array
    :   Iterator of `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_array('c').reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).to_frame()
    <Frame>
    <Index> b-min   b-max   <<U5>
    <Index>
    0       0       3
    1       8       8
    <int64> <int64> <int64>

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c'))
    ((np.int64(0), array([[11,  0,  0],
           [10,  3,  0]])), (np.int64(1), array([[4, 8, 1],
           [2, 8, 1]])))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    IterNodeDelegateReducible.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_array_items('c').apply(lambda k, v: np.sum(v) if k == 0 else v.shape)
    <Series>
    <Index: c>
    0          24
    1          (2, 3)
    <int64>    <object>

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).apply\_iter(func*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    IterNodeDelegateReducible.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').apply_iter(lambda k, v: np.sum(v) if k == 0 else v.shape))
    (np.int64(24), (2, 3))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).apply\_iter\_items(func*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    IterNodeDelegateReducible.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').apply_iter_items(lambda k, v: np.sum(v) if k == 0 else v.shape))
    ((np.int64(0), np.int64(24)), (np.int64(1), (2, 3)))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    IterNodeDelegateReducible.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').reduce.from_func(lambda l, a: a.sum(axis=0)).keys())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').reduce.from_func(lambda l, a: a.sum(axis=0)).__iter__())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).items(*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').reduce.from_func(lambda l, a: a.sum(axis=0)).items())
    ((np.int64(0), array([21,  3,  0])), (np.int64(1), array([ 6, 16,  2])))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).values(*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').reduce.from_func(lambda l, a: a.sum(axis=0)).values())
    (array([21,  3,  0]), array([ 6, 16,  2]))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_array_items('c').reduce.from_func(lambda l, a: a.sum(axis=0)).to_frame()
    <Frame>
    <Index> 0       <int64>
    <Index>
    0       21
    1       3
    2       0
    3       6
    4       16
    5       2
    <int64> <int64>

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').reduce.from_map_func(lambda l, a: np.min(a)).keys())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').reduce.from_map_func(lambda l, a: np.min(a)).__iter__())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).items(*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').reduce.from_map_func(lambda l, a: np.min(a)).items())
    ((np.int64(0), array([10,  0,  0])), (np.int64(1), array([2, 8, 1])))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).values(*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').reduce.from_map_func(lambda l, a: np.min(a)).values())
    (array([10,  0,  0]), array([2, 8, 1]))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_array_items('c').reduce.from_map_func(lambda l, a: np.min(a)).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    0       10      0       0
    1       2       8       1
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').reduce.from_label_map({'b': lambda l, a: np.min(a), 'a': lambda l, a: np.max(a)}).keys())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').reduce.from_label_map({'b': lambda l, a: np.min(a), 'a': lambda l, a: np.max(a)}).__iter__())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').reduce.from_label_map({'b': lambda l, a: np.min(a), 'a': lambda l, a: np.max(a)}).items())
    ((np.int64(0), array([ 0, 11])), (np.int64(1), array([8, 4])))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').reduce.from_label_map({'b': lambda l, a: np.min(a), 'a': lambda l, a: np.max(a)}).values())
    (array([ 0, 11]), array([8, 4]))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_array_items('c').reduce.from_label_map({'b': lambda l, a: np.min(a), 'a': lambda l, a: np.max(a)}).to_frame()
    <Frame>
    <Index> b       a       <<U1>
    <Index>
    0       0       11
    1       8       4
    <int64> <int64> <int64>

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').reduce.from_label_pair_map({('b', 'b-min'): lambda l, a: np.min(a), ('b', 'b-max'): lambda l, a: np.max(a)}).keys())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').reduce.from_label_pair_map({('b', 'b-min'): lambda l, a: np.min(a), ('b', 'b-max'): lambda l, a: np.max(a)}).__iter__())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').reduce.from_label_pair_map({('b', 'b-min'): lambda l, a: np.min(a), ('b', 'b-max'): lambda l, a: np.max(a)}).items())
    ((np.int64(0), array([0, 3])), (np.int64(1), array([8, 8])))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_array_items('c').reduce.from_label_pair_map({('b', 'b-min'): lambda l, a: np.min(a), ('b', 'b-max'): lambda l, a: np.max(a)}).values())
    (array([0, 3]), array([8, 8]))

    ```

Frame.iter\_group\_array\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_array_items('c').reduce.from_label_pair_map({('b', 'b-min'): lambda l, a: np.min(a), ('b', 'b-max'): lambda l, a: np.max(a)}).to_frame()
    <Frame>
    <Index> b-min   b-max   <<U5>
    <Index>
    0       0       3
    1       8       8
    <int64> <int64> <int64>

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c'))
    ((np.int64(0), <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    0       11      0       0
    2       10      3       0
    <int64> <int64> <int64> <int64>), (np.int64(1), <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    1       4       8       1
    3       2       8       1
    <int64> <int64> <int64> <int64>))

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    IterNodeDelegateReducible.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_items('c').apply(lambda k, v: v['b'].sum() if k == 0 else v.shape)
    <Series>
    <Index: c>
    0          3
    1          (2, 3)
    <int64>    <object>

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).apply\_iter(func*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    IterNodeDelegateReducible.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').apply_iter(lambda k, v: v['b'].sum() if k == 0 else v.shape))
    (np.int64(3), (2, 3))

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).apply\_iter\_items(func*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    IterNodeDelegateReducible.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').apply_iter_items(lambda k, v: v['b'].sum() if k == 0 else v.shape))
    ((np.int64(0), np.int64(3)), (np.int64(1), (2, 3)))

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    IterNodeDelegateReducible.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').reduce.from_func(lambda l, f: f.iloc[1:]).keys())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').reduce.from_func(lambda l, f: f.iloc[1:]).__iter__())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).items(*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').reduce.from_func(lambda l, f: f.iloc[1:]).items())
    ((np.int64(0), <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    2       10      3       0
    <int64> <int64> <int64> <int64>), (np.int64(1), <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    3       2       8       1
    <int64> <int64> <int64> <int64>))

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).values(*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').reduce.from_func(lambda l, f: f.iloc[1:]).values())
    (<Frame>
    <Index> a       b       c       <<U1>
    <Index>
    2       10      3       0
    <int64> <int64> <int64> <int64>, <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    3       2       8       1
    <int64> <int64> <int64> <int64>)

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_items('c').reduce.from_func(lambda l, f: f.iloc[1:]).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    2       10      3       0
    3       2       8       1
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').reduce.from_map_func(lambda l, s: np.min(s)).keys())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').reduce.from_map_func(lambda l, s: np.min(s)).__iter__())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).items(*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').reduce.from_map_func(lambda l, s: np.min(s)).items())
    ((np.int64(0), <Series: 0>
    <Index>
    a           10
    b           0
    c           0
    <<U1>       <int64>), (np.int64(1), <Series: 1>
    <Index>
    a           2
    b           8
    c           1
    <<U1>       <int64>))

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).values(*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').reduce.from_map_func(lambda l, s: np.min(s)).values())
    (<Series: 0>
    <Index>
    a           10
    b           0
    c           0
    <<U1>       <int64>, <Series: 1>
    <Index>
    a           2
    b           8
    c           1
    <<U1>       <int64>)

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_map\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_items('c').reduce.from_map_func(lambda l, s: np.min(s)).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    0       10      0       0
    1       2       8       1
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').reduce.from_label_map({'b': lambda l, s: np.min(s), 'a': lambda l, s: np.max(s)}).keys())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').reduce.from_label_map({'b': lambda l, s: np.min(s), 'a': lambda l, s: np.max(s)}).__iter__())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').reduce.from_label_map({'b': lambda l, s: np.min(s), 'a': lambda l, s: np.max(s)}).items())
    ((np.int64(0), <Series: 0>
    <Index>
    b           0
    a           11
    <<U1>       <int64>), (np.int64(1), <Series: 1>
    <Index>
    b           8
    a           4
    <<U1>       <int64>))

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').reduce.from_label_map({'b': lambda l, s: np.min(s), 'a': lambda l, s: np.max(s)}).values())
    (<Series: 0>
    <Index>
    b           0
    a           11
    <<U1>       <int64>, <Series: 1>
    <Index>
    b           8
    a           4
    <<U1>       <int64>)

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_items('c').reduce.from_label_map({'b': lambda l, s: np.min(s), 'a': lambda l, s: np.max(s)}).to_frame()
    <Frame>
    <Index> b       a       <<U1>
    <Index>
    0       0       11
    1       8       4
    <int64> <int64> <int64>

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').reduce.from_label_pair_map({('b', 'b-min'): lambda l, s: np.min(s), ('b', 'b-max'): lambda l, s: np.max(s)}).keys())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').reduce.from_label_pair_map({('b', 'b-min'): lambda l, s: np.min(s), ('b', 'b-max'): lambda l, s: np.max(s)}).__iter__())
    (np.int64(0), np.int64(1))

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').reduce.from_label_pair_map({('b', 'b-min'): lambda l, s: np.min(s), ('b', 'b-max'): lambda l, s: np.max(s)}).items())
    ((np.int64(0), <Series: 0>
    <Index>
    b-min       0
    b-max       3
    <<U5>       <int64>), (np.int64(1), <Series: 1>
    <Index>
    b-min       8
    b-max       8
    <<U5>       <int64>))

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_items('c').reduce.from_label_pair_map({('b', 'b-min'): lambda l, s: np.min(s), ('b', 'b-max'): lambda l, s: np.max(s)}).values())
    (<Series: 0>
    <Index>
    b-min       0
    b-max       3
    <<U5>       <int64>, <Series: 1>
    <Index>
    b-min       8
    b-max       8
    <<U5>       <int64>)

    ```

Frame.iter\_group\_items(*key*, *\**, *axis*, *drop).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in one or more columns (axis=0) or rows (axis=1).

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_items('c').reduce.from_label_pair_map({('b', 'b-min'): lambda l, s: np.min(s), ('b', 'b-max'): lambda l, s: np.max(s)}).to_frame()
    <Frame>
    <Index> b-min   b-max   <<U5>
    <Index>
    0       0       3
    1       8       8
    <int64> <int64> <int64>

    ```

Frame.iter\_group\_labels(*depth\_level*, *\**, *axis*)
:   iter\_group\_labels
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> tuple(f.iter_group_labels(1))
    (<Frame>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    1                p     8       True   1517-12-31
    <int64>          <<U1> <int64> <bool> <datetime64[D]>, <Frame>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                q     2       True   1517-04-01
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>)

    ```

Frame.iter\_group\_labels(*depth\_level*, *\**, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_group\_labels
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    IterNodeDelegate.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> f.iter_group_labels(1).apply(lambda f: f['b'].sum())
    <Series>
    <Index>
    p        1
    q        1
    <<U1>    <int64>

    ```

Frame.iter\_group\_labels(*depth\_level*, *\**, *axis).apply\_iter(func*)
:   iter\_group\_labels
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    IterNodeDelegate.apply\_iter(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> tuple(f.iter_group_labels(1).apply_iter(lambda f: f['b'].sum()))
    (np.int64(1), np.int64(1))

    ```

Frame.iter\_group\_labels(*depth\_level*, *\**, *axis).apply\_iter\_items(func*)
:   iter\_group\_labels
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    IterNodeDelegate.apply\_iter\_items(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter_items)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> tuple(f.iter_group_labels(1).apply_iter_items(lambda f: f['b'].sum()))
    ((np.str_('p'), np.int64(1)), (np.str_('q'), np.int64(1)))

    ```

Frame.iter\_group\_labels(*depth\_level*, *\**, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_group\_labels
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    IterNodeDelegate.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_pool)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Frame.iter\_group\_labels\_array(*depth\_level*, *\**, *axis*)
:   iter\_group\_labels\_array
    :   Iterator of `np.ndarray` grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> tuple(f.iter_group_labels_array(1))
    (array([[10, False, datetime.date(1517, 1, 1)],
           [8, True, datetime.date(1517, 12, 31)]], dtype=object), array([[2, True, datetime.date(1517, 4, 1)],
           [3, False, datetime.date(1517, 6, 30)]], dtype=object))

    ```

Frame.iter\_group\_labels\_array(*depth\_level*, *\**, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_group\_labels\_array
    :   Iterator of `np.ndarray` grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    IterNodeDelegate.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> f.iter_group_labels_array(1).apply(lambda a: np.sum(a[:, 0]))
    <Series>
    <Index>
    p        18
    q        5
    <<U1>    <int64>

    ```

Frame.iter\_group\_labels\_array(*depth\_level*, *\**, *axis).apply\_iter(func*)
:   iter\_group\_labels\_array
    :   Iterator of `np.ndarray` grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    IterNodeDelegate.apply\_iter(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> tuple(f.iter_group_labels_array(1).apply_iter(lambda a: np.sum(a[:, 0])))
    (18, 5)

    ```

Frame.iter\_group\_labels\_array(*depth\_level*, *\**, *axis).apply\_iter\_items(func*)
:   iter\_group\_labels\_array
    :   Iterator of `np.ndarray` grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    IterNodeDelegate.apply\_iter\_items(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter_items)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> tuple(f.iter_group_labels_array(1).apply_iter_items(lambda a: np.sum(a[:, 0])))
    ((np.str_('p'), 18), (np.str_('q'), 5))

    ```

Frame.iter\_group\_labels\_array(*depth\_level*, *\**, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_group\_labels\_array
    :   Iterator of `np.ndarray` grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    IterNodeDelegate.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_pool)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Frame.iter\_group\_labels\_array\_items(*depth\_level*, *\**, *axis*)
:   iter\_group\_labels\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> tuple(f.iter_group_labels_array_items(1))
    ((np.str_('p'), array([[10, False, datetime.date(1517, 1, 1)],
           [8, True, datetime.date(1517, 12, 31)]], dtype=object)), (np.str_('q'), array([[2, True, datetime.date(1517, 4, 1)],
           [3, False, datetime.date(1517, 6, 30)]], dtype=object)))

    ```

Frame.iter\_group\_labels\_array\_items(*depth\_level*, *\**, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_group\_labels\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    IterNodeDelegate.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> f.iter_group_labels_array_items(1).apply(lambda k, v: np.sum(v[:, 0]) if k != 'p' else -1)
    <Series>
    <Index>
    p        -1
    q        5
    <<U1>    <int64>

    ```

Frame.iter\_group\_labels\_array\_items(*depth\_level*, *\**, *axis).apply\_iter(func*)
:   iter\_group\_labels\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    IterNodeDelegate.apply\_iter(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> tuple(f.iter_group_labels_array_items(1).apply_iter(lambda k, v: np.sum(v[:, 0]) if k != 'p' else -1))
    (-1, 5)

    ```

Frame.iter\_group\_labels\_array\_items(*depth\_level*, *\**, *axis).apply\_iter\_items(func*)
:   iter\_group\_labels\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    IterNodeDelegate.apply\_iter\_items(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter_items)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> tuple(f.iter_group_labels_array_items(1).apply_iter_items(lambda k, v: np.sum(v[:, 0]) if k != 'p' else -1))
    ((np.str_('p'), -1), (np.str_('q'), 5))

    ```

Frame.iter\_group\_labels\_array\_items(*depth\_level*, *\**, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_group\_labels\_array\_items
    :   Iterator of pairs of label, `np.ndarray` grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    IterNodeDelegate.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_pool)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Frame.iter\_group\_labels\_items(*depth\_level*, *\**, *axis*)
:   iter\_group\_labels\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> tuple(f.iter_group_labels_items(1))
    ((np.str_('p'), <Frame>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    1                p     8       True   1517-12-31
    <int64>          <<U1> <int64> <bool> <datetime64[D]>), (np.str_('q'), <Frame>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                q     2       True   1517-04-01
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>))

    ```

Frame.iter\_group\_labels\_items(*depth\_level*, *\**, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_group\_labels\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    IterNodeDelegate.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> f.iter_group_labels_items(1).apply(lambda k, v: v['b'].sum() if k == 'p' else -1)
    <Series>
    <Index>
    p        1
    q        -1
    <<U1>    <int64>

    ```

Frame.iter\_group\_labels\_items(*depth\_level*, *\**, *axis).apply\_iter(func*)
:   iter\_group\_labels\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    IterNodeDelegate.apply\_iter(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> tuple(f.iter_group_labels_items(1).apply_iter(lambda k, v: v['b'].sum() if k == 'p' else -1))
    (np.int64(1), -1)

    ```

Frame.iter\_group\_labels\_items(*depth\_level*, *\**, *axis).apply\_iter\_items(func*)
:   iter\_group\_labels\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    IterNodeDelegate.apply\_iter\_items(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter_items)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> tuple(f.iter_group_labels_items(1).apply_iter_items(lambda k, v: v['b'].sum() if k == 'p' else -1))
    ((np.str_('p'), np.int64(1)), (np.str_('q'), -1))

    ```

Frame.iter\_group\_labels\_items(*depth\_level*, *\**, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_group\_labels\_items
    :   Iterator of pairs of label, [`Frame`](frame-selector.html#Frame "Frame") grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).

    IterNodeDelegate.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_pool)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 2))
    (<Frame>
    <Index> a       b       c       <<U1>
    <Index>
    0       11      0       0
    2       10      3       0
    <int64> <int64> <int64> <int64>, <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    1       4       8       1
    3       2       8       1
    <int64> <int64> <int64> <int64>)

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    IterNodeDelegateReducible.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other(np.arange(len(f)) % 2).apply(lambda f: f['b'].sum())
    <Series>
    <Index>
    0        3
    1        16
    <int64>  <int64>

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).apply\_iter(func*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    IterNodeDelegateReducible.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 2).apply_iter(lambda f: f['b'].sum()))
    (np.int64(3), np.int64(16))

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).apply\_iter\_items(func*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    IterNodeDelegateReducible.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 2).apply_iter_items(lambda f: f['b'].sum()))
    ((np.int64(0), np.int64(3)), (np.int64(1), np.int64(16)))

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    IterNodeDelegateReducible.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 3).reduce.from_func(lambda f: f.iloc[1:]).keys())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 3).reduce.from_func(lambda f: f.iloc[1:]).__iter__())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).items(*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 3).reduce.from_func(lambda f: f.iloc[1:]).items())
    ((np.int64(0), <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    3       2       8       1
    <int64> <int64> <int64> <int64>), (np.int64(1), <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    <int64> <int64> <int64> <int64>), (np.int64(2), <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    <int64> <int64> <int64> <int64>))

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).values(*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 3).reduce.from_func(lambda f: f.iloc[1:]).values())
    (<Frame>
    <Index> a       b       c       <<U1>
    <Index>
    3       2       8       1
    <int64> <int64> <int64> <int64>, <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    <int64> <int64> <int64> <int64>, <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    <int64> <int64> <int64> <int64>)

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other(np.arange(len(f)) % 3).reduce.from_func(lambda f: f.iloc[1:]).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    3       2       8       1
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 3).reduce.from_map_func(np.min).keys())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 3).reduce.from_map_func(np.min).__iter__())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).items(*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 3).reduce.from_map_func(np.min).items())
    ((np.int64(0), <Series: 0>
    <Index>
    a           2
    b           0
    c           0
    <<U1>       <int64>), (np.int64(1), <Series: 1>
    <Index>
    a           4
    b           8
    c           1
    <<U1>       <int64>), (np.int64(2), <Series: 2>
    <Index>
    a           10
    b           3
    c           0
    <<U1>       <int64>))

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).values(*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 3).reduce.from_map_func(np.min).values())
    (<Series: 0>
    <Index>
    a           2
    b           0
    c           0
    <<U1>       <int64>, <Series: 1>
    <Index>
    a           4
    b           8
    c           1
    <<U1>       <int64>, <Series: 2>
    <Index>
    a           10
    b           3
    c           0
    <<U1>       <int64>)

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other(np.arange(len(f)) % 3).reduce.from_map_func(np.min).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    0       2       0       0
    1       4       8       1
    2       10      3       0
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 3).reduce.from_label_map({'b': np.min, 'a': np.max}).keys())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 3).reduce.from_label_map({'b': np.min, 'a': np.max}).__iter__())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 3).reduce.from_label_map({'b': np.min, 'a': np.max}).items())
    ((np.int64(0), <Series: 0>
    <Index>
    b           0
    a           11
    <<U1>       <int64>), (np.int64(1), <Series: 1>
    <Index>
    b           8
    a           4
    <<U1>       <int64>), (np.int64(2), <Series: 2>
    <Index>
    b           3
    a           10
    <<U1>       <int64>))

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 3).reduce.from_label_map({'b': np.min, 'a': np.max}).values())
    (<Series: 0>
    <Index>
    b           0
    a           11
    <<U1>       <int64>, <Series: 1>
    <Index>
    b           8
    a           4
    <<U1>       <int64>, <Series: 2>
    <Index>
    b           3
    a           10
    <<U1>       <int64>)

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other(np.arange(len(f)) % 3).reduce.from_label_map({'b': np.min, 'a': np.max}).to_frame()
    <Frame>
    <Index> b       a       <<U1>
    <Index>
    0       0       11
    1       8       4
    2       3       10
    <int64> <int64> <int64>

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).keys())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).__iter__())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).items())
    ((np.int64(0), <Series: 0>
    <Index>
    b-min       0
    b-max       8
    <<U5>       <int64>), (np.int64(1), <Series: 1>
    <Index>
    b-min       8
    b-max       8
    <<U5>       <int64>), (np.int64(2), <Series: 2>
    <Index>
    b-min       3
    b-max       3
    <<U5>       <int64>))

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).values())
    (<Series: 0>
    <Index>
    b-min       0
    b-max       8
    <<U5>       <int64>, <Series: 1>
    <Index>
    b-min       8
    b-max       8
    <<U5>       <int64>, <Series: 2>
    <Index>
    b-min       3
    b-max       3
    <<U5>       <int64>)

    ```

Frame.iter\_group\_other(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_other
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).to_frame()
    <Frame>
    <Index> b-min   b-max   <<U5>
    <Index>
    0       0       8
    1       8       8
    2       3       3
    <int64> <int64> <int64>

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 2))
    (array([[11,  0,  0],
           [10,  3,  0]]), array([[4, 8, 1],
           [2, 8, 1]]))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    IterNodeDelegateReducible.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other_array(np.arange(len(f)) % 2).apply(lambda a: np.sum(a))
    <Series>
    <Index>
    0        24
    1        24
    <int64>  <int64>

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).apply\_iter(func*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    IterNodeDelegateReducible.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 2).apply_iter(lambda a: np.sum(a)))
    (np.int64(24), np.int64(24))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).apply\_iter\_items(func*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    IterNodeDelegateReducible.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 2).apply_iter_items(lambda a: np.sum(a)))
    ((np.int64(0), np.int64(24)), (np.int64(1), np.int64(24)))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    IterNodeDelegateReducible.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_func(lambda a: a.sum(axis=0)).keys())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_func(lambda a: a.sum(axis=0)).__iter__())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).items(*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_func(lambda a: a.sum(axis=0)).items())
    ((np.int64(0), array([13,  8,  1])), (np.int64(1), array([4, 8, 1])), (np.int64(2), array([10,  3,  0])))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).values(*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_func(lambda a: a.sum(axis=0)).values())
    (array([13,  8,  1]), array([4, 8, 1]), array([10,  3,  0]))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_func(lambda a: a.sum(axis=0)).to_frame()
    <Frame>
    <Index> 0       <int64>
    <Index>
    0       13
    1       8
    2       1
    3       4
    4       8
    5       1
    6       10
    7       3
    8       0
    <int64> <int64>

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_map_func(np.min).keys())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_map_func(np.min).__iter__())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).items(*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_map_func(np.min).items())
    ((np.int64(0), array([2, 0, 0])), (np.int64(1), array([4, 8, 1])), (np.int64(2), array([10,  3,  0])))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).values(*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_map_func(np.min).values())
    (array([2, 0, 0]), array([4, 8, 1]), array([10,  3,  0]))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_map_func(np.min).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    0       2       0       0
    1       4       8       1
    2       10      3       0
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_label_map({'b': np.min, 'a': np.max}).keys())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_label_map({'b': np.min, 'a': np.max}).__iter__())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_label_map({'b': np.min, 'a': np.max}).items())
    ((np.int64(0), array([ 0, 11])), (np.int64(1), array([8, 4])), (np.int64(2), array([ 3, 10])))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_label_map({'b': np.min, 'a': np.max}).values())
    (array([ 0, 11]), array([8, 4]), array([ 3, 10]))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_label_map({'b': np.min, 'a': np.max}).to_frame()
    <Frame>
    <Index> b       a       <<U1>
    <Index>
    0       0       11
    1       8       4
    2       3       10
    <int64> <int64> <int64>

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).keys())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).__iter__())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).items())
    ((np.int64(0), array([0, 8])), (np.int64(1), array([8, 8])), (np.int64(2), array([3, 3])))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).values())
    (array([0, 8]), array([8, 8]), array([3, 3]))

    ```

Frame.iter\_group\_other\_array(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_other\_array
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other_array(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).to_frame()
    <Frame>
    <Index> b-min   b-max   <<U5>
    <Index>
    0       0       8
    1       8       8
    2       3       3
    <int64> <int64> <int64>

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 2))
    ((np.int64(0), array([[11,  0,  0],
           [10,  3,  0]])), (np.int64(1), array([[4, 8, 1],
           [2, 8, 1]])))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    IterNodeDelegateReducible.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other_array_items(np.arange(len(f)) % 2).apply(lambda k, v: np.sum(v) if k == 0 else v.shape)
    <Series>
    <Index>
    0        24
    1        (2, 3)
    <int64>  <object>

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).apply\_iter(func*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    IterNodeDelegateReducible.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 2).apply_iter(lambda k, v: np.sum(v) if k == 0 else v.shape))
    (np.int64(24), (2, 3))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).apply\_iter\_items(func*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    IterNodeDelegateReducible.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 2).apply_iter_items(lambda k, v: np.sum(v) if k == 0 else v.shape))
    ((np.int64(0), np.int64(24)), (np.int64(1), (2, 3)))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    IterNodeDelegateReducible.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_func(lambda l, a: a.sum(axis=0)).keys())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_func(lambda l, a: a.sum(axis=0)).__iter__())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).items(*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_func(lambda l, a: a.sum(axis=0)).items())
    ((np.int64(0), array([13,  8,  1])), (np.int64(1), array([4, 8, 1])), (np.int64(2), array([10,  3,  0])))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).values(*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_func(lambda l, a: a.sum(axis=0)).values())
    (array([13,  8,  1]), array([4, 8, 1]), array([10,  3,  0]))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_func(lambda l, a: a.sum(axis=0)).to_frame()
    <Frame>
    <Index> 0       <int64>
    <Index>
    0       13
    1       8
    2       1
    3       4
    4       8
    5       1
    6       10
    7       3
    8       0
    <int64> <int64>

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_map_func(lambda l, a: np.min(a)).keys())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_map_func(lambda l, a: np.min(a)).__iter__())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).items(*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_map_func(lambda l, a: np.min(a)).items())
    ((np.int64(0), array([2, 0, 0])), (np.int64(1), array([4, 8, 1])), (np.int64(2), array([10,  3,  0])))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).values(*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_map_func(lambda l, a: np.min(a)).values())
    (array([2, 0, 0]), array([4, 8, 1]), array([10,  3,  0]))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_map_func(lambda l, a: np.min(a)).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    0       2       0       0
    1       4       8       1
    2       10      3       0
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_label_map({'b': lambda l, a: np.min(a), 'a': lambda l, a: np.max(a)}).keys())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_label_map({'b': lambda l, a: np.min(a), 'a': lambda l, a: np.max(a)}).__iter__())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_label_map({'b': lambda l, a: np.min(a), 'a': lambda l, a: np.max(a)}).items())
    ((np.int64(0), array([ 0, 11])), (np.int64(1), array([8, 4])), (np.int64(2), array([ 3, 10])))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_label_map({'b': lambda l, a: np.min(a), 'a': lambda l, a: np.max(a)}).values())
    (array([ 0, 11]), array([8, 4]), array([ 3, 10]))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_label_map({'b': lambda l, a: np.min(a), 'a': lambda l, a: np.max(a)}).to_frame()
    <Frame>
    <Index> b       a       <<U1>
    <Index>
    0       0       11
    1       8       4
    2       3       10
    <int64> <int64> <int64>

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): lambda l, a: np.min(a), ('b', 'b-max'): lambda l, a: np.max(a)}).keys())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): lambda l, a: np.min(a), ('b', 'b-max'): lambda l, a: np.max(a)}).__iter__())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): lambda l, a: np.min(a), ('b', 'b-max'): lambda l, a: np.max(a)}).items())
    ((np.int64(0), array([0, 8])), (np.int64(1), array([8, 8])), (np.int64(2), array([3, 3])))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): lambda l, a: np.min(a), ('b', 'b-max'): lambda l, a: np.max(a)}).values())
    (array([0, 8]), array([8, 8]), array([3, 3]))

    ```

Frame.iter\_group\_other\_array\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_other\_array\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other_array_items(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): lambda l, a: np.min(a), ('b', 'b-max'): lambda l, a: np.max(a)}).to_frame()
    <Frame>
    <Index> b-min   b-max   <<U5>
    <Index>
    0       0       8
    1       8       8
    2       3       3
    <int64> <int64> <int64>

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 2))
    ((np.int64(0), <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    0       11      0       0
    2       10      3       0
    <int64> <int64> <int64> <int64>), (np.int64(1), <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    1       4       8       1
    3       2       8       1
    <int64> <int64> <int64> <int64>))

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    IterNodeDelegateReducible.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other_items(np.arange(len(f)) % 2).apply(lambda k, v: v['b'].sum() if k == 0 else v.shape)
    <Series>
    <Index>
    0        3
    1        (2, 3)
    <int64>  <object>

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).apply\_iter(func*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    IterNodeDelegateReducible.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 2).apply_iter(lambda k, v: v['b'].sum() if k == 0 else v.shape))
    (np.int64(3), (2, 3))

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).apply\_iter\_items(func*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    IterNodeDelegateReducible.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 2).apply_iter_items(lambda k, v: v['b'].sum() if k == 0 else v.shape))
    ((np.int64(0), np.int64(3)), (np.int64(1), (2, 3)))

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    IterNodeDelegateReducible.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_func(lambda l, f: f.iloc[1:]).keys())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_func(lambda l, f: f.iloc[1:]).__iter__())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).items(*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_func(lambda l, f: f.iloc[1:]).items())
    ((np.int64(0), <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    3       2       8       1
    <int64> <int64> <int64> <int64>), (np.int64(1), <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    <int64> <int64> <int64> <int64>), (np.int64(2), <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    <int64> <int64> <int64> <int64>))

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).values(*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_func(lambda l, f: f.iloc[1:]).values())
    (<Frame>
    <Index> a       b       c       <<U1>
    <Index>
    3       2       8       1
    <int64> <int64> <int64> <int64>, <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    <int64> <int64> <int64> <int64>, <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    <int64> <int64> <int64> <int64>)

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_func(lambda l, f: f.iloc[1:]).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    3       2       8       1
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_map_func(lambda l, s: np.min(s)).keys())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_map_func(lambda l, s: np.min(s)).__iter__())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).items(*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_map_func(lambda l, s: np.min(s)).items())
    ((np.int64(0), <Series: 0>
    <Index>
    a           2
    b           0
    c           0
    <<U1>       <int64>), (np.int64(1), <Series: 1>
    <Index>
    a           4
    b           8
    c           1
    <<U1>       <int64>), (np.int64(2), <Series: 2>
    <Index>
    a           10
    b           3
    c           0
    <<U1>       <int64>))

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).values(*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_map_func(lambda l, s: np.min(s)).values())
    (<Series: 0>
    <Index>
    a           2
    b           0
    c           0
    <<U1>       <int64>, <Series: 1>
    <Index>
    a           4
    b           8
    c           1
    <<U1>       <int64>, <Series: 2>
    <Index>
    a           10
    b           3
    c           0
    <<U1>       <int64>)

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_map\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_map_func(lambda l, s: np.min(s)).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    0       2       0       0
    1       4       8       1
    2       10      3       0
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_label_map({'b': lambda l, s: np.min(s), 'a': lambda l, s: np.max(s)}).keys())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_label_map({'b': lambda l, s: np.min(s), 'a': lambda l, s: np.max(s)}).__iter__())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_label_map({'b': lambda l, s: np.min(s), 'a': lambda l, s: np.max(s)}).items())
    ((np.int64(0), <Series: 0>
    <Index>
    b           0
    a           11
    <<U1>       <int64>), (np.int64(1), <Series: 1>
    <Index>
    b           8
    a           4
    <<U1>       <int64>), (np.int64(2), <Series: 2>
    <Index>
    b           3
    a           10
    <<U1>       <int64>))

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_label_map({'b': lambda l, s: np.min(s), 'a': lambda l, s: np.max(s)}).values())
    (<Series: 0>
    <Index>
    b           0
    a           11
    <<U1>       <int64>, <Series: 1>
    <Index>
    b           8
    a           4
    <<U1>       <int64>, <Series: 2>
    <Index>
    b           3
    a           10
    <<U1>       <int64>)

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_label_map({'b': lambda l, s: np.min(s), 'a': lambda l, s: np.max(s)}).to_frame()
    <Frame>
    <Index> b       a       <<U1>
    <Index>
    0       0       11
    1       8       4
    2       3       10
    <int64> <int64> <int64>

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): lambda l, s: np.min(s), ('b', 'b-max'): lambda l, s: np.max(s)}).keys())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): lambda l, s: np.min(s), ('b', 'b-max'): lambda l, s: np.max(s)}).__iter__())
    (np.int64(0), np.int64(1), np.int64(2))

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): lambda l, s: np.min(s), ('b', 'b-max'): lambda l, s: np.max(s)}).items())
    ((np.int64(0), <Series: 0>
    <Index>
    b-min       0
    b-max       8
    <<U5>       <int64>), (np.int64(1), <Series: 1>
    <Index>
    b-min       8
    b-max       8
    <<U5>       <int64>), (np.int64(2), <Series: 2>
    <Index>
    b-min       3
    b-max       3
    <<U5>       <int64>))

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): lambda l, s: np.min(s), ('b', 'b-max'): lambda l, s: np.max(s)}).values())
    (<Series: 0>
    <Index>
    b-min       0
    b-max       8
    <<U5>       <int64>, <Series: 1>
    <Index>
    b-min       8
    b-max       8
    <<U5>       <int64>, <Series: 2>
    <Index>
    b-min       3
    b-max       3
    <<U5>       <int64>)

    ```

Frame.iter\_group\_other\_items(*other*, *\**, *fill\_value*, *axis).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_group\_other\_items
    :   Iterator of [`Frame`](frame-selector.html#Frame "Frame") grouped by unique values found in a supplied container.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_group_other_items(np.arange(len(f)) % 3).reduce.from_label_pair_map({('b', 'b-min'): lambda l, s: np.min(s), ('b', 'b-max'): lambda l, s: np.max(s)}).to_frame()
    <Frame>
    <Index> b-min   b-max   <<U5>
    <Index>
    0       0       8
    1       8       8
    2       3       3
    <int64> <int64> <int64>

    ```

Frame.iter\_series(*\**, *axis*)
:   iter\_series
    :   Iterator of [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_series())
    (<Series: a>
    <Index>
    p           10
    q           -2
    r           0
    s           0
    <<U1>       <int64>, <Series: b>
    <Index>
    p           8
    q           -3
    r           8
    s           0
    <<U1>       <int64>, <Series: c>
    <Index>
    p           1
    q           0
    r           9
    s           12
    <<U1>       <int64>)

    ```

Frame.iter\_series(*\**, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_series
    :   Iterator of [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_series().apply(lambda v: v.sum())
    <Series>
    <Index>
    a        8
    b        13
    c        22
    <<U1>    <int64>

    ```

Frame.iter\_series(*\**, *axis).apply\_iter(func*)
:   iter\_series
    :   Iterator of [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_iter(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_series().apply_iter(lambda v: v.sum()))
    (np.int64(8), np.int64(13), np.int64(22))

    ```

Frame.iter\_series(*\**, *axis).apply\_iter\_items(func*)
:   iter\_series
    :   Iterator of [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_iter\_items(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter_items)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_series().apply_iter_items(lambda v: v.sum()))
    ((np.str_('a'), np.int64(8)), (np.str_('b'), np.int64(13)), (np.str_('c'), np.int64(22)))

    ```

Frame.iter\_series(*\**, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_series
    :   Iterator of [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_pool)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_series().apply_pool(lambda v: v.sum(), use_threads=True)
    <Series>
    <Index>
    a        8
    b        13
    c        22
    <<U1>    <int64>

    ```

Frame.iter\_series\_items(*\**, *axis*)
:   iter\_series\_items
    :   Iterator of pairs of label, [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_series_items())
    ((np.str_('a'), <Series: a>
    <Index>
    p           10
    q           -2
    r           0
    s           0
    <<U1>       <int64>), (np.str_('b'), <Series: b>
    <Index>
    p           8
    q           -3
    r           8
    s           0
    <<U1>       <int64>), (np.str_('c'), <Series: c>
    <Index>
    p           1
    q           0
    r           9
    s           12
    <<U1>       <int64>))

    ```

Frame.iter\_series\_items(*\**, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_series\_items
    :   Iterator of pairs of label, [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_series_items().apply(lambda k, v: v.sum() if k != 'b' else -1)
    <Series>
    <Index>
    a        8
    b        -1
    c        22
    <<U1>    <int64>

    ```

Frame.iter\_series\_items(*\**, *axis).apply\_iter(func*)
:   iter\_series\_items
    :   Iterator of pairs of label, [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_iter(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_series_items().apply_iter(lambda k, v: v.sum() if k != 'b' else -1))
    (np.int64(8), -1, np.int64(22))

    ```

Frame.iter\_series\_items(*\**, *axis).apply\_iter\_items(func*)
:   iter\_series\_items
    :   Iterator of pairs of label, [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_iter\_items(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter_items)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_series_items().apply_iter_items(lambda k, v: v.sum() if k != 'b' else -1))
    ((np.str_('a'), np.int64(8)), (np.str_('b'), -1), (np.str_('c'), np.int64(22)))

    ```

Frame.iter\_series\_items(*\**, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_series\_items
    :   Iterator of pairs of label, [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_pool)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_series_items().apply_pool(lambda pair: pair[1].sum() if pair[0] != 'b' else -1, use_threads=True)
    <Series>
    <Index>
    a        8
    b        -1
    c        22
    <<U1>    <int64>

    ```

Frame.iter\_tuple(*\**, *axis*, *constructor*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_tuple())
    (Axis(p=np.int64(10), q=np.int64(-2), r=np.int64(0), s=np.int64(0)), Axis(p=np.int64(8), q=np.int64(-3), r=np.int64(8), s=np.int64(0)), Axis(p=np.int64(1), q=np.int64(0), r=np.int64(9), s=np.int64(12)))

    ```

Frame.iter\_tuple(*\**, *axis*, *constructor).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_tuple().apply(lambda v: v.p + v.q)
    <Series>
    <Index>
    a        8
    b        5
    c        1
    <<U1>    <int64>

    ```

Frame.iter\_tuple(*\**, *axis*, *constructor).apply\_iter(func*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_tuple().apply_iter(lambda v: v.p + v.q))
    (np.int64(8), np.int64(5), np.int64(1))

    ```

Frame.iter\_tuple(*\**, *axis*, *constructor).apply\_iter\_items(func*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_tuple().apply_iter_items(lambda v: v.p + v.q))
    ((np.str_('a'), np.int64(8)), (np.str_('b'), np.int64(5)), (np.str_('c'), np.int64(1)))

    ```

Frame.iter\_tuple(*\**, *axis*, *constructor).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Frame.iter\_tuple(*\**, *axis*, *constructor).map\_all(mapping*, *\**, *dtype*, *name*, *index\_constructor*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_all(*mapping*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> f.iter_tuple().map_all({(2, 9): -1, (3, 8): -2})
    <Series>
    <Index>
    a        -1
    b        -2
    <<U1>    <int64>

    ```

Frame.iter\_tuple(*\**, *axis*, *constructor).map\_all\_iter(mapping*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_all\_iter(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all_iter)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_tuple().map_all_iter({(2, 9): -1, (3, 8): -2}))
    (-1, -2)

    ```

Frame.iter\_tuple(*\**, *axis*, *constructor).map\_all\_iter\_items(mapping*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_all\_iter\_items(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all_iter_items)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_tuple().map_all_iter_items({(2, 9): -1, (3, 8): -2}))
    ((np.str_('a'), -1), (np.str_('b'), -2))

    ```

Frame.iter\_tuple(*\**, *axis*, *constructor).map\_any(mapping*, *\**, *dtype*, *name*, *index\_constructor*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_any(*mapping*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any)
    :   Apply a mapping; for values not in the mapping, the value is returned. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_tuple().map_any({(2, 9): -1}))
    (np.str_('a'), np.str_('b'))

    ```

Frame.iter\_tuple(*\**, *axis*, *constructor).map\_any\_iter(mapping*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_any\_iter(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any_iter)
    :   Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_tuple().map_any_iter({(2, 9): -1}))
    (-1, Axis(p=np.int64(3), q=np.int64(8)))

    ```

Frame.iter\_tuple(*\**, *axis*, *constructor).map\_any\_iter\_items(mapping*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_any\_iter\_items(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any_iter_items)
    :   Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_tuple().map_any_iter_items({(2, 9): -1}))
    ((np.str_('a'), -1), (np.str_('b'), Axis(p=np.int64(3), q=np.int64(8))))

    ```

Frame.iter\_tuple(*\**, *axis*, *constructor).map\_fill(mapping*, *\**, *fill\_value*, *dtype*, *name*, *index\_constructor*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_fill(*mapping*, */*, *\**, *fill\_value=nan*, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> f.iter_tuple().map_fill({(2, 9): -1}, fill_value=np.nan)
    <Series>
    <Index>
    a        -1.0
    b        nan
    <<U1>    <float64>

    ```

Frame.iter\_tuple(*\**, *axis*, *constructor).map\_fill\_iter(mapping*, *\**, *fill\_value*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_fill\_iter(*mapping*, */*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill_iter)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. A generator of resulting values.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_tuple().map_fill_iter({(2, 9): -1}, fill_value=np.nan))
    (-1, nan)

    ```

Frame.iter\_tuple(*\**, *axis*, *constructor).map\_fill\_iter\_items(mapping*, *\**, *fill\_value*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_fill\_iter\_items(*mapping*, */*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill_iter_items)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. A generator of resulting key, value pairs.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_tuple().map_fill_iter_items({(2, 9): -1}, fill_value=np.nan))
    ((np.str_('a'), -1), (np.str_('b'), nan))

    ```

Frame.iter\_tuple\_items(*\**, *axis*, *constructor*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_tuple_items())
    ((np.str_('a'), Axis(p=np.int64(10), q=np.int64(-2), r=np.int64(0), s=np.int64(0))), (np.str_('b'), Axis(p=np.int64(8), q=np.int64(-3), r=np.int64(8), s=np.int64(0))), (np.str_('c'), Axis(p=np.int64(1), q=np.int64(0), r=np.int64(9), s=np.int64(12))))

    ```

Frame.iter\_tuple\_items(*\**, *axis*, *constructor).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_tuple_items().apply(lambda k, v: v.p + v.q if k == 'b' else -1)
    <Series>
    <Index>
    a        -1
    b        5
    c        -1
    <<U1>    <int64>

    ```

Frame.iter\_tuple\_items(*\**, *axis*, *constructor).apply\_iter(func*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> tuple(f.iter_tuple_items().apply_iter(lambda k, v: v.p + v.q if k == 'b' else -1))
    (-1, np.int64(5), -1)

    ```

Frame.iter\_tuple\_items(*\**, *axis*, *constructor).apply\_iter\_items(func*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> tuple(f.iter_tuple_items().apply_iter_items(lambda k, v: v.p + v.q if k == 'b' else -1))
    ((np.str_('a'), -1), (np.str_('b'), np.int64(5)), (np.str_('c'), -1))

    ```

Frame.iter\_tuple\_items(*\**, *axis*, *constructor).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Frame.iter\_tuple\_items(*\**, *axis*, *constructor).map\_all(mapping*, *\**, *dtype*, *name*, *index\_constructor*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_all(*mapping*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> f.iter_tuple_items().map_all({('a', (2, 9)): -1, ('b', (3, 8)): -2})
    <Series>
    <Index>
    a        -1
    b        -2
    <<U1>    <int64>

    ```

Frame.iter\_tuple\_items(*\**, *axis*, *constructor).map\_all\_iter(mapping*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_all\_iter(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all_iter)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_tuple_items().map_all_iter({('a', (2, 9)): -1, ('b', (3, 8)): -2}))
    (-1, -2)

    ```

Frame.iter\_tuple\_items(*\**, *axis*, *constructor).map\_all\_iter\_items(mapping*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_all\_iter\_items(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all_iter_items)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_tuple_items().map_all_iter_items({('a', (2, 9)): -1, ('b', (3, 8)): -2}))
    ((np.str_('a'), -1), (np.str_('b'), -2))

    ```

Frame.iter\_tuple\_items(*\**, *axis*, *constructor).map\_any(mapping*, *\**, *dtype*, *name*, *index\_constructor*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_any(*mapping*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any)
    :   Apply a mapping; for values not in the mapping, the value is returned. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> f.iter_tuple_items().map_any({('a', (2, 9)): -1})
    <Series>
    <Index>
    a        -1
    b        Axis(p=np.int64(3...
    <<U1>    <object>

    ```

Frame.iter\_tuple\_items(*\**, *axis*, *constructor).map\_any\_iter(mapping*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_any\_iter(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any_iter)
    :   Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_tuple_items().map_any_iter({('a', (2, 9)): -1}))
    (-1, Axis(p=np.int64(3), q=np.int64(8)))

    ```

Frame.iter\_tuple\_items(*\**, *axis*, *constructor).map\_any\_iter\_items(mapping*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_any\_iter\_items(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any_iter_items)
    :   Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_tuple_items().map_any_iter_items({('a', (2, 9)): -1}))
    ((np.str_('a'), -1), (np.str_('b'), Axis(p=np.int64(3), q=np.int64(8))))

    ```

Frame.iter\_tuple\_items(*\**, *axis*, *constructor).map\_fill(mapping*, *\**, *fill\_value*, *dtype*, *name*, *index\_constructor*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_fill(*mapping*, */*, *\**, *fill\_value=nan*, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> f.iter_tuple_items().map_fill({('a', (2, 9)): -1}, fill_value=np.nan)
    <Series>
    <Index>
    a        -1.0
    b        nan
    <<U1>    <float64>

    ```

Frame.iter\_tuple\_items(*\**, *axis*, *constructor).map\_fill\_iter(mapping*, *\**, *fill\_value*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_fill\_iter(*mapping*, */*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill_iter)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. A generator of resulting values.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_tuple_items().map_fill_iter({('a', (2, 9)): -1}, fill_value=np.nan))
    (-1, nan)

    ```

Frame.iter\_tuple\_items(*\**, *axis*, *constructor).map\_fill\_iter\_items(mapping*, *\**, *fill\_value*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_fill\_iter\_items(*mapping*, */*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill_iter_items)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. A generator of resulting key, value pairs.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.

    ```
    >>> f = sf.Frame.from_fields(((2, 9), (3, 8)), columns=('a', 'b'), index=('p', 'q'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       3
    q          9       8
    <<U1>      <int64> <int64>
    >>> tuple(f.iter_tuple_items().map_fill_iter_items({('a', (2, 9)): -1}, fill_value=np.nan))
    ((np.str_('a'), -1), (np.str_('b'), nan))

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1))
    (<Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    <<U1>      <int64> <int64> <int64>, <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    q          -2      -3      0
    r          0       8       9
    <<U1>      <int64> <int64> <int64>, <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>)

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegateReducible.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_window(size=2, step=1).apply(lambda f: f.max().max())
    <Series>
    <Index>
    q        10
    r        9
    s        12
    <<U1>    <int64>

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_iter(func*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegateReducible.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).apply_iter(lambda f: f.max().max()))
    (np.int64(10), np.int64(9), np.int64(12))

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_iter\_items(func*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegateReducible.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).apply_iter_items(lambda f: f.max().max()))
    ((np.str_('q'), np.int64(10)), (np.str_('r'), np.int64(9)), (np.str_('s'), np.int64(12)))

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegateReducible.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).reduce.from_func(lambda f: f.iloc[1:]).keys())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).reduce.from_func(lambda f: f.iloc[1:]).__iter__())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).items(*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).reduce.from_func(lambda f: f.iloc[1:]).items())
    ((np.int64(1), <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    1          4       8       1
    <int64>    <int64> <int64> <int64>), (np.int64(2), <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    2          10      3       0
    <int64>    <int64> <int64> <int64>), (np.int64(3), <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    3          2       8       1
    <int64>    <int64> <int64> <int64>))

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).values(*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).reduce.from_func(lambda f: f.iloc[1:]).values())
    (<Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    1          4       8       1
    <int64>    <int64> <int64> <int64>, <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    2          10      3       0
    <int64>    <int64> <int64> <int64>, <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    3          2       8       1
    <int64>    <int64> <int64> <int64>)

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_window(size=2, step=1).reduce.from_func(lambda f: f.iloc[1:]).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    1       4       8       1
    2       10      3       0
    3       2       8       1
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).reduce.from_map_func(np.min).keys())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).reduce.from_map_func(np.min).__iter__())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).items(*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).reduce.from_map_func(np.min).items())
    ((np.int64(1), <Series: 1>
    <Index>
    a           4
    b           0
    c           0
    <<U1>       <int64>), (np.int64(2), <Series: 2>
    <Index>
    a           4
    b           3
    c           0
    <<U1>       <int64>), (np.int64(3), <Series: 3>
    <Index>
    a           2
    b           3
    c           0
    <<U1>       <int64>))

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).values(*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).reduce.from_map_func(np.min).values())
    (<Series: 1>
    <Index>
    a           4
    b           0
    c           0
    <<U1>       <int64>, <Series: 2>
    <Index>
    a           4
    b           3
    c           0
    <<U1>       <int64>, <Series: 3>
    <Index>
    a           2
    b           3
    c           0
    <<U1>       <int64>)

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_window(size=2, step=1).reduce.from_map_func(np.min).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    1       4       0       0
    2       4       3       0
    3       2       3       0
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).reduce.from_label_map({'b': np.min, 'a': np.max}).keys())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).reduce.from_label_map({'b': np.min, 'a': np.max}).__iter__())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).reduce.from_label_map({'b': np.min, 'a': np.max}).items())
    ((np.int64(1), <Series: 1>
    <Index>
    b           0
    a           11
    <<U1>       <int64>), (np.int64(2), <Series: 2>
    <Index>
    b           3
    a           10
    <<U1>       <int64>), (np.int64(3), <Series: 3>
    <Index>
    b           3
    a           10
    <<U1>       <int64>))

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).reduce.from_label_map({'b': np.min, 'a': np.max}).values())
    (<Series: 1>
    <Index>
    b           0
    a           11
    <<U1>       <int64>, <Series: 2>
    <Index>
    b           3
    a           10
    <<U1>       <int64>, <Series: 3>
    <Index>
    b           3
    a           10
    <<U1>       <int64>)

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_window(size=2, step=1).reduce.from_label_map({'b': np.min, 'a': np.max}).to_frame()
    <Frame>
    <Index> b       a       <<U1>
    <Index>
    1       0       11
    2       3       10
    3       3       10
    <int64> <int64> <int64>

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).keys())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).__iter__())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).items())
    ((np.int64(1), <Series: 1>
    <Index>
    b-min       0
    b-max       8
    <<U5>       <int64>), (np.int64(2), <Series: 2>
    <Index>
    b-min       3
    b-max       8
    <<U5>       <int64>), (np.int64(3), <Series: 3>
    <Index>
    b-min       3
    b-max       8
    <<U5>       <int64>))

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).values())
    (<Series: 1>
    <Index>
    b-min       0
    b-max       8
    <<U5>       <int64>, <Series: 2>
    <Index>
    b-min       3
    b-max       8
    <<U5>       <int64>, <Series: 3>
    <Index>
    b-min       3
    b-max       8
    <<U5>       <int64>)

    ```

Frame.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_window(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).to_frame()
    <Frame>
    <Index> b-min   b-max   <<U5>
    <Index>
    1       0       8
    2       3       8
    3       3       8
    <int64> <int64> <int64>

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1))
    (array([[10,  8,  1],
           [-2, -3,  0]]), array([[-2, -3,  0],
           [ 0,  8,  9]]), array([[ 0,  8,  9],
           [ 0,  0, 12]]))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegateReducible.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_window_array(size=2, step=1).apply(lambda a: np.max(a))
    <Series>
    <Index>
    q        10
    r        9
    s        12
    <<U1>    <int64>

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_iter(func*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegateReducible.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).apply_iter(lambda a: np.max(a)))
    (np.int64(10), np.int64(9), np.int64(12))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_iter\_items(func*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegateReducible.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).apply_iter_items(lambda a: np.max(a)))
    ((np.str_('q'), np.int64(10)), (np.str_('r'), np.int64(9)), (np.str_('s'), np.int64(12)))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegateReducible.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).reduce.from_func(lambda a: a.sum(axis=0)).keys())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).reduce.from_func(lambda a: a.sum(axis=0)).__iter__())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).items(*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).reduce.from_func(lambda a: a.sum(axis=0)).items())
    ((np.int64(1), array([15,  8,  1])), (np.int64(2), array([14, 11,  1])), (np.int64(3), array([12, 11,  1])))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).values(*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).reduce.from_func(lambda a: a.sum(axis=0)).values())
    (array([15,  8,  1]), array([14, 11,  1]), array([12, 11,  1]))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_window_array(size=2, step=1).reduce.from_func(lambda a: a.sum(axis=0)).to_frame()
    <Frame>
    <Index> 0       <int64>
    <Index>
    0       15
    1       8
    2       1
    3       14
    4       11
    5       1
    6       12
    7       11
    8       1
    <int64> <int64>

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).reduce.from_map_func(np.min).keys())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).reduce.from_map_func(np.min).__iter__())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).items(*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).reduce.from_map_func(np.min).items())
    ((np.int64(1), array([4, 0, 0])), (np.int64(2), array([4, 3, 0])), (np.int64(3), array([2, 3, 0])))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).values(*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).reduce.from_map_func(np.min).values())
    (array([4, 0, 0]), array([4, 3, 0]), array([2, 3, 0]))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_window_array(size=2, step=1).reduce.from_map_func(np.min).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    1       4       0       0
    2       4       3       0
    3       2       3       0
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).reduce.from_label_map({'b': np.min, 'a': np.max}).keys())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).reduce.from_label_map({'b': np.min, 'a': np.max}).__iter__())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).reduce.from_label_map({'b': np.min, 'a': np.max}).items())
    ((np.int64(1), array([ 0, 11])), (np.int64(2), array([ 3, 10])), (np.int64(3), array([ 3, 10])))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).reduce.from_label_map({'b': np.min, 'a': np.max}).values())
    (array([ 0, 11]), array([ 3, 10]), array([ 3, 10]))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_window_array(size=2, step=1).reduce.from_label_map({'b': np.min, 'a': np.max}).to_frame()
    <Frame>
    <Index> b       a       <<U1>
    <Index>
    1       0       11
    2       3       10
    3       3       10
    <int64> <int64> <int64>

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).keys())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).__iter__())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).items())
    ((np.int64(1), array([0, 8])), (np.int64(2), array([3, 8])), (np.int64(3), array([3, 8])))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).values())
    (array([0, 8]), array([3, 8]), array([3, 8]))

    ```

Frame.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_window_array(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): np.min, ('b', 'b-max'): np.max}).to_frame()
    <Frame>
    <Index> b-min   b-max   <<U5>
    <Index>
    1       0       8
    2       3       8
    3       3       8
    <int64> <int64> <int64>

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1))
    ((np.str_('q'), array([[10,  8,  1],
           [-2, -3,  0]])), (np.str_('r'), array([[-2, -3,  0],
           [ 0,  8,  9]])), (np.str_('s'), array([[ 0,  8,  9],
           [ 0,  0, 12]])))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegateReducible.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_window_array_items(size=2, step=1).apply(lambda k, v: np.max(v) if k == 'r' else np.min(v))
    <Series>
    <Index>
    q        -3
    r        9
    s        0
    <<U1>    <int64>

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_iter(func*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegateReducible.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).apply_iter(lambda k, v: np.max(v) if k == 'r' else np.min(v)))
    (np.int64(-3), np.int64(9), np.int64(0))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_iter\_items(func*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegateReducible.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).apply_iter_items(lambda k, v: np.max(v) if k == 'r' else np.min(v)))
    ((np.str_('q'), np.int64(-3)), (np.str_('r'), np.int64(9)), (np.str_('s'), np.int64(0)))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegateReducible.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).reduce.from_func(lambda l, a: a.sum(axis=0)).keys())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).reduce.from_func(lambda l, a: a.sum(axis=0)).__iter__())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).items(*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).reduce.from_func(lambda l, a: a.sum(axis=0)).items())
    ((np.int64(1), array([15,  8,  1])), (np.int64(2), array([14, 11,  1])), (np.int64(3), array([12, 11,  1])))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).values(*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).reduce.from_func(lambda l, a: a.sum(axis=0)).values())
    (array([15,  8,  1]), array([14, 11,  1]), array([12, 11,  1]))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_window_array_items(size=2, step=1).reduce.from_func(lambda l, a: a.sum(axis=0)).to_frame()
    <Frame>
    <Index> 0       <int64>
    <Index>
    0       15
    1       8
    2       1
    3       14
    4       11
    5       1
    6       12
    7       11
    8       1
    <int64> <int64>

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).reduce.from_map_func(lambda l, a: np.min(a)).keys())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).reduce.from_map_func(lambda l, a: np.min(a)).__iter__())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).items(*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).reduce.from_map_func(lambda l, a: np.min(a)).items())
    ((np.int64(1), array([4, 0, 0])), (np.int64(2), array([4, 3, 0])), (np.int64(3), array([2, 3, 0])))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).values(*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).reduce.from_map_func(lambda l, a: np.min(a)).values())
    (array([4, 0, 0]), array([4, 3, 0]), array([2, 3, 0]))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_window_array_items(size=2, step=1).reduce.from_map_func(lambda l, a: np.min(a)).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    1       4       0       0
    2       4       3       0
    3       2       3       0
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).reduce.from_label_map({'b': lambda l, a: np.min(a), 'a': lambda l, a: np.max(a)}).keys())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).reduce.from_label_map({'b': lambda l, a: np.min(a), 'a': lambda l, a: np.max(a)}).__iter__())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).reduce.from_label_map({'b': lambda l, a: np.min(a), 'a': lambda l, a: np.max(a)}).items())
    ((np.int64(1), array([ 0, 11])), (np.int64(2), array([ 3, 10])), (np.int64(3), array([ 3, 10])))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).reduce.from_label_map({'b': lambda l, a: np.min(a), 'a': lambda l, a: np.max(a)}).values())
    (array([ 0, 11]), array([ 3, 10]), array([ 3, 10]))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_window_array_items(size=2, step=1).reduce.from_label_map({'b': lambda l, a: np.min(a), 'a': lambda l, a: np.max(a)}).to_frame()
    <Frame>
    <Index> b       a       <<U1>
    <Index>
    1       0       11
    2       3       10
    3       3       10
    <int64> <int64> <int64>

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): lambda l, a: np.min(a), ('b', 'b-max'): lambda l, a: np.max(a)}).keys())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): lambda l, a: np.min(a), ('b', 'b-max'): lambda l, a: np.max(a)}).__iter__())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): lambda l, a: np.min(a), ('b', 'b-max'): lambda l, a: np.max(a)}).items())
    ((np.int64(1), array([0, 8])), (np.int64(2), array([3, 8])), (np.int64(3), array([3, 8])))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_array_items(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): lambda l, a: np.min(a), ('b', 'b-max'): lambda l, a: np.max(a)}).values())
    (array([0, 8]), array([3, 8]), array([3, 8]))

    ```

Frame.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_window_array_items(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): lambda l, a: np.min(a), ('b', 'b-max'): lambda l, a: np.max(a)}).to_frame()
    <Frame>
    <Index> b-min   b-max   <<U5>
    <Index>
    1       0       8
    2       3       8
    3       3       8
    <int64> <int64> <int64>

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1))
    ((np.str_('q'), <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    <<U1>      <int64> <int64> <int64>), (np.str_('r'), <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    q          -2      -3      0
    r          0       8       9
    <<U1>      <int64> <int64> <int64>), (np.str_('s'), <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>))

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegateReducible.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iter_window_items(size=2, step=1).apply(lambda k, v: v.max().max() if k == 'r' else v.min().min())
    <Series>
    <Index>
    q        -3
    r        9
    s        0
    <<U1>    <int64>

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_iter(func*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegateReducible.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).apply_iter(lambda k, v: v.max().max() if k == 'r' else v.min().min()))
    (np.int64(-3), np.int64(9), np.int64(0))

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_iter\_items(func*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegateReducible.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).apply_iter_items(lambda k, v: v.max().max() if k == 'r' else v.min().min()))
    ((np.str_('q'), np.int64(-3)), (np.str_('r'), np.int64(9)), (np.str_('s'), np.int64(0)))

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegateReducible.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).reduce.from_func(lambda l, f: f.iloc[1:]).keys())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).reduce.from_func(lambda l, f: f.iloc[1:]).__iter__())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).items(*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).reduce.from_func(lambda l, f: f.iloc[1:]).items())
    ((np.int64(1), <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    1          4       8       1
    <int64>    <int64> <int64> <int64>), (np.int64(2), <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    2          10      3       0
    <int64>    <int64> <int64> <int64>), (np.int64(3), <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    3          2       8       1
    <int64>    <int64> <int64> <int64>))

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).values(*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).reduce.from_func(lambda l, f: f.iloc[1:]).values())
    (<Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    1          4       8       1
    <int64>    <int64> <int64> <int64>, <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    2          10      3       0
    <int64>    <int64> <int64> <int64>, <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    3          2       8       1
    <int64>    <int64> <int64> <int64>)

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_func)
    :   For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_window_items(size=2, step=1).reduce.from_func(lambda l, f: f.iloc[1:]).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    1       4       8       1
    2       10      3       0
    3       2       8       1
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).keys(*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).reduce.from_map_func(lambda l, s: np.min(s)).keys())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).reduce.from_map_func(lambda l, s: np.min(s)).__iter__())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).items(*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).reduce.from_map_func(lambda l, s: np.min(s)).items())
    ((np.int64(1), <Series: 1>
    <Index>
    a           4
    b           0
    c           0
    <<U1>       <int64>), (np.int64(2), <Series: 2>
    <Index>
    a           4
    b           3
    c           0
    <<U1>       <int64>), (np.int64(3), <Series: 3>
    <Index>
    a           2
    b           3
    c           0
    <<U1>       <int64>))

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).values(*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).reduce.from_map_func(lambda l, s: np.min(s)).values())
    (<Series: 1>
    <Index>
    a           4
    b           0
    c           0
    <<U1>       <int64>, <Series: 2>
    <Index>
    a           4
    b           3
    c           0
    <<U1>       <int64>, <Series: 3>
    <Index>
    a           2
    b           3
    c           0
    <<U1>       <int64>)

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_map\_func(func*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_map\_func(*func*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_map_func)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_window_items(size=2, step=1).reduce.from_map_func(lambda l, s: np.min(s)).to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    1       4       0       0
    2       4       3       0
    3       2       3       0
    <int64> <int64> <int64> <int64>

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).reduce.from_label_map({'b': lambda l, s: np.min(s), 'a': lambda l, s: np.max(s)}).keys())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).reduce.from_label_map({'b': lambda l, s: np.min(s), 'a': lambda l, s: np.max(s)}).__iter__())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).reduce.from_label_map({'b': lambda l, s: np.min(s), 'a': lambda l, s: np.max(s)}).items())
    ((np.int64(1), <Series: 1>
    <Index>
    b           0
    a           11
    <<U1>       <int64>), (np.int64(2), <Series: 2>
    <Index>
    b           3
    a           10
    <<U1>       <int64>), (np.int64(3), <Series: 3>
    <Index>
    b           3
    a           10
    <<U1>       <int64>))

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).reduce.from_label_map({'b': lambda l, s: np.min(s), 'a': lambda l, s: np.max(s)}).values())
    (<Series: 1>
    <Index>
    b           0
    a           11
    <<U1>       <int64>, <Series: 2>
    <Index>
    b           3
    a           10
    <<U1>       <int64>, <Series: 3>
    <Index>
    b           3
    a           10
    <<U1>       <int64>)

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_window_items(size=2, step=1).reduce.from_label_map({'b': lambda l, s: np.min(s), 'a': lambda l, s: np.max(s)}).to_frame()
    <Frame>
    <Index> b       a       <<U1>
    <Index>
    1       0       11
    2       3       10
    3       3       10
    <int64> <int64> <int64>

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).keys(*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): lambda l, s: np.min(s), ('b', 'b-max'): lambda l, s: np.max(s)}).keys())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).\_\_iter\_\_(*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): lambda l, s: np.min(s), ('b', 'b-max'): lambda l, s: np.max(s)}).__iter__())
    (np.int64(1), np.int64(2), np.int64(3))

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).items(*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): lambda l, s: np.min(s), ('b', 'b-max'): lambda l, s: np.max(s)}).items())
    ((np.int64(1), <Series: 1>
    <Index>
    b-min       0
    b-max       8
    <<U5>       <int64>), (np.int64(2), <Series: 2>
    <Index>
    b-min       3
    b-max       8
    <<U5>       <int64>), (np.int64(3), <Series: 3>
    <Index>
    b-min       3
    b-max       8
    <<U5>       <int64>))

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).values(*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> tuple(f.iter_window_items(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): lambda l, s: np.min(s), ('b', 'b-max'): lambda l, s: np.max(s)}).values())
    (<Series: 1>
    <Index>
    b-min       0
    b-max       8
    <<U5>       <int64>, <Series: 2>
    <Index>
    b-min       3
    b-max       8
    <<U5>       <int64>, <Series: 3>
    <Index>
    b-min       3
    b-max       8
    <<U5>       <int64>)

    ```

Frame.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).reduce.from\_label\_pair\_map(func\_map*, *\**, *fill\_value).to\_frame(\**, *index*, *columns*, *index\_constructor*, *columns\_constructor*, *name*, *consolidate\_blocks*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ReduceDispatch.from\_label\_pair\_map(*func\_map*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/reduce.html#ReduceDispatch.from_label_pair_map)

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.iter_window_items(size=2, step=1).reduce.from_label_pair_map({('b', 'b-min'): lambda l, s: np.min(s), ('b', 'b-max'): lambda l, s: np.max(s)}).to_frame()
    <Frame>
    <Index> b-min   b-max   <<U5>
    <Index>
    1       0       8
    2       3       8
    3       3       8
    <int64> <int64> <int64>

    ```

[Frame](frame.html#api-detail-frame): [Constructor](frame-constructor.html#api-detail-frame-constructor) | [Exporter](frame-exporter.html#api-detail-frame-exporter) | [Attribute](frame-attribute.html#api-detail-frame-attribute) | [Method](frame-method.html#api-detail-frame-method) | [Dictionary-Like](frame-dictionary_like.html#api-detail-frame-dictionary-like) | [Display](frame-display.html#api-detail-frame-display) | [Assignment](frame-assignment.html#api-detail-frame-assignment) | [Selector](frame-selector.html#api-detail-frame-selector) | [Iterator](#api-detail-frame-iterator) | [Operator Binary](frame-operator_binary.html#api-detail-frame-operator-binary) | [Operator Unary](frame-operator_unary.html#api-detail-frame-operator-unary) | [Accessor Values](frame-accessor_values.html#api-detail-frame-accessor-values) | [Accessor Datetime](frame-accessor_datetime.html#api-detail-frame-accessor-datetime) | [Accessor String](frame-accessor_string.html#api-detail-frame-accessor-string) | [Accessor Transpose](frame-accessor_transpose.html#api-detail-frame-accessor-transpose) | [Accessor Fill Value](frame-accessor_fill_value.html#api-detail-frame-accessor-fill-value) | [Accessor Regular Expression](frame-accessor_regular_expression.html#api-detail-frame-accessor-regular-expression) | [Accessor Hashlib](frame-accessor_hashlib.html#api-detail-frame-accessor-hashlib) | [Accessor Type Clinic](frame-accessor_type_clinic.html#api-detail-frame-accessor-type-clinic) | [Accessor Reduce](frame-accessor_reduce.html#api-detail-frame-accessor-reduce)

[Previous](frame-selector.html "Detail: Frame: Selector")
[Next](frame-operator_binary.html "Detail: Frame: Operator Binary")

---

© Copyright 2025, Christopher Ariza.
Last updated on Apr 29, 2025.

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme)
provided by [Read the Docs](https://readthedocs.org).