[![Logo](../_static/sf-logo-web_icon-small.png)](../index.md)

Quick Start

* [static-frame](../readme.md)
* [License](../license.md)

Introduction

* [About StaticFrame](../intro.md)
* [Media](../intro.md#media)
* [What is New in StaticFrame](../new.md)
* [Contributing](../contributing.md)

Articles

* [Improving Code Quality with Array and DataFrame Type Hints](../articles/guard.md)
* [Type-Hinting DataFrames for Static Analysis and Runtime Validation](../articles/ftyping.md)
* [Faster DataFrame Serialization](../articles/serialize.md)
* [The Performance Advantage of No-Copy DataFrame Operations](../articles/no_copy.md)
* [Memoizing DataFrame Functions: Using Hashable DataFrames and Message Digests to Optimize Repeated Calculations](../articles/hash.md)
* [Using Higher-Order Containers to Efficiently Process 7,163 (or More) DataFrames](../articles/uhoc.md)
* [One Fill Value Is Not Enough: Preserving Columnar Types When Reindexing DataFrames](../articles/fill_value.md)
* [Ten Reasons to Use StaticFrame Instead of Pandas](../articles/upgrade.md)
* [Boring Indices & Where to Find Them: The Auto-Incremented Integer Index in StaticFrame](../articles/aiii.md)

API Overview

* [Overview: Series](../api_overview/series.md)
* [Overview: SeriesHE](../api_overview/series_he.md)
* [Overview: Frame](../api_overview/frame.md)
* [Overview: FrameGO](../api_overview/frame_go.md)
* [Overview: FrameHE](../api_overview/frame_he.md)
* [Overview: Bus](../api_overview/bus.md)
* [Overview: Batch](../api_overview/batch.md)
* [Overview: Yarn](../api_overview/yarn.md)
* [Overview: Quilt](../api_overview/quilt.md)
* [Overview: Index](../api_overview/index.md)
* [Overview: IndexGO](../api_overview/index_go.md)
* [Overview: IndexHierarchy](../api_overview/index_hierarchy.md)
* [Overview: IndexHierarchyGO](../api_overview/index_hierarchy_go.md)
* [Overview: IndexYear](../api_overview/index_year.md)
* [Overview: IndexYearGO](../api_overview/index_year_go.md)
* [Overview: IndexYearMonth](../api_overview/index_year_month.md)
* [Overview: IndexYearMonthGO](../api_overview/index_year_month_go.md)
* [Overview: IndexDate](../api_overview/index_date.md)
* [Overview: IndexDateGO](../api_overview/index_date_go.md)
* [Overview: IndexMinute](../api_overview/index_minute.md)
* [Overview: IndexMinuteGO](../api_overview/index_minute_go.md)
* [Overview: IndexHour](../api_overview/index_hour.md)
* [Overview: IndexHourGO](../api_overview/index_hour_go.md)
* [Overview: IndexSecond](../api_overview/index_second.md)
* [Overview: IndexSecondGO](../api_overview/index_second_go.md)
* [Overview: IndexMillisecond](../api_overview/index_millisecond.md)
* [Overview: IndexMillisecondGO](../api_overview/index_millisecond_go.md)
* [Overview: IndexMicrosecond](../api_overview/index_microsecond.md)
* [Overview: IndexMicrosecondGO](../api_overview/index_microsecond_go.md)
* [Overview: IndexNanosecond](../api_overview/index_nanosecond.md)
* [Overview: IndexNanosecondGO](../api_overview/index_nanosecond_go.md)
* [Overview: HLoc](../api_overview/hloc.md)
* [Overview: ILoc](../api_overview/iloc.md)
* [Overview: TypeClinic](../api_overview/type_clinic.md)
* [Overview: CallGuard](../api_overview/call_guard.md)
* [Overview: ClinicResult](../api_overview/clinic_result.md)
* [Overview: Require](../api_overview/require.md)
* [Overview: WWW](../api_overview/www.md)
* [Overview: FillValueAuto](../api_overview/fill_value_auto.md)
* [Overview: DisplayActive](../api_overview/display_active.md)
* [Overview: DisplayConfig](../api_overview/display_config.md)
* [Overview: StoreConfig](../api_overview/store_config.md)
* [Overview: StoreFilter](../api_overview/store_filter.md)
* [Overview: IndexAutoFactory](../api_overview/index_auto_factory.md)
* [Overview: IndexDefaultConstructorFactory](../api_overview/index_default_constructor_factory.md)
* [Overview: IndexAutoConstructorFactory](../api_overview/index_auto_constructor_factory.md)
* [Overview: NPZ](../api_overview/npz.md)
* [Overview: NPY](../api_overview/npy.md)
* [Overview: MemoryDisplay](../api_overview/memory_display.md)
* [Overview: Platform](../api_overview/platform.md)

API Detail

* [Detail: Series](series.md)
* [Detail: SeriesHE](series_he.md)
* [Detail: Frame](frame.md)
* [Detail: FrameGO](frame_go.md)
* [Detail: FrameHE](frame_he.md)
* [Detail: Bus](bus.md)
* [Detail: Batch](batch.md)
* [Detail: Yarn](yarn.md)
* [Detail: Quilt](quilt.md)
* [Detail: Index](index.md)
* [Detail: IndexGO](index_go.md)
* [Detail: IndexHierarchy](index_hierarchy.md)
* [Detail: IndexHierarchyGO](index_hierarchy_go.md)
* [Detail: IndexYear](index_year.md)
* [Detail: IndexYearGO](index_year_go.md)
* [Detail: IndexYearMonth](index_year_month.md)
* [Detail: IndexYearMonthGO](index_year_month_go.md)
* [Detail: IndexDate](index_date.md)
* [Detail: IndexDateGO](index_date_go.md)
* [Detail: IndexMinute](index_minute.md)
* [Detail: IndexMinuteGO](index_minute_go.md)
* [Detail: IndexHour](index_hour.md)
* [Detail: IndexHourGO](index_hour_go.md)
* [Detail: IndexSecond](index_second.md)
* [Detail: IndexSecondGO](index_second_go.md)
* [Detail: IndexMillisecond](index_millisecond.md)
* [Detail: IndexMillisecondGO](index_millisecond_go.md)
* [Detail: IndexMicrosecond](index_microsecond.md)
* [Detail: IndexMicrosecondGO](index_microsecond_go.md)
* [Detail: IndexNanosecond](index_nanosecond.md)
* [Detail: IndexNanosecondGO](index_nanosecond_go.md)
* [Detail: HLoc](hloc.md)
* [Detail: ILoc](iloc.md)
* [Detail: TypeClinic](type_clinic.md)
* [Detail: CallGuard](call_guard.md)
* [Detail: ClinicResult](clinic_result.md)
* [Detail: Require](require.md)
* [Detail: WWW](www.md)
* [Detail: FillValueAuto](fill_value_auto.md)
* [Detail: DisplayActive](display_active.md)
* [Detail: DisplayConfig](display_config.md)
* [Detail: StoreConfig](store_config.md)
* [Detail: StoreFilter](store_filter.md)
* [Detail: IndexAutoFactory](index_auto_factory.md)
* [Detail: IndexDefaultConstructorFactory](index_default_constructor_factory.md)
* [Detail: IndexAutoConstructorFactory](index_auto_constructor_factory.md)
* [Detail: NPZ](npz.md)
* [Detail: NPY](npy.md)
* [Detail: MemoryDisplay](memory_display.md)
* [Detail: Platform](platform.md)

[StaticFrame](../index.md)

* Detail: IndexNanosecond: Accessor Regular Expression
* [View page source](../_sources/api_detail/index_nanosecond-accessor_regular_expression.rst.txt)

[Previous](index_nanosecond-accessor_string.md "Detail: IndexNanosecond: Accessor String")
[Next](index_nanosecond-accessor_hashlib.md "Detail: IndexNanosecond: Accessor Hashlib")

---

# Detail: IndexNanosecond: Accessor Regular Expression[](#detail-indexnanosecond-accessor-regular-expression "Link to this heading")

[Overview: IndexNanosecond: Accessor Regular Expression](../api_overview/index_nanosecond-accessor_regular_expression.md#api-overview-indexnanosecond-accessor-regular-expression)

IndexNanosecond.via\_re(*pattern*, *flags).search(pos*, *endpos*)
:   via\_re *= <function Index.via\_re>*

    InterfaceRe.search(*pos=0*, *endpos=None*)[[source]](../_modules/static_frame/core/node_re.md#InterfaceRe.search)
    :   Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string.

        Parameters:
        :   * **pos** – Gives an index in the string where the search is to start; it defaults to 0.
            * **endpos** – Limits how far the string will be searched; it will be as if the string is endpos characters long.

    ```
    >>> ix = sf.IndexNanosecond(('1789-05-05', '1789-12-31', '1799-11-09'))
    >>> ix
    <IndexNanosecond>
    1789-05-05T00:00:00.000000000
    1789-12-31T00:00:00.000000000
    1799-11-09T00:00:00.000000000
    <datetime64[ns]>
    >>> ix.via_re('[X123]').search()
    [ True  True  True]

    ```

IndexNanosecond.via\_re(*pattern*, *flags).match(pos*, *endpos*)
:   via\_re *= <function Index.via\_re>*

    InterfaceRe.match(*pos=0*, *endpos=None*)[[source]](../_modules/static_frame/core/node_re.md#InterfaceRe.match)
    :   If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match.

        Parameters:
        :   * **pos** – Gives an index in the string where the search is to start; it defaults to 0.
            * **endpos** – Limits how far the string will be searched; it will be as if the string is endpos characters long.

    ```
    >>> ix = sf.IndexNanosecond(('1789-05-05', '1789-12-31', '1799-11-09'))
    >>> ix
    <IndexNanosecond>
    1789-05-05T00:00:00.000000000
    1789-12-31T00:00:00.000000000
    1799-11-09T00:00:00.000000000
    <datetime64[ns]>
    >>> ix.via_re('[X123]').match()
    [ True  True  True]

    ```

IndexNanosecond.via\_re(*pattern*, *flags).fullmatch(pos*, *endpos*)
:   via\_re *= <function Index.via\_re>*

    InterfaceRe.fullmatch(*pos=0*, *endpos=None*)[[source]](../_modules/static_frame/core/node_re.md#InterfaceRe.fullmatch)
    :   If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match.

        Parameters:
        :   * **pos** – Gives an index in the string where the search is to start; it defaults to 0.
            * **endpos** – Limits how far the string will be searched; it will be as if the string is endpos characters long.

    ```
    >>> ix = sf.IndexNanosecond(('1789-05-05', '1789-12-31', '1799-11-09'))
    >>> ix
    <IndexNanosecond>
    1789-05-05T00:00:00.000000000
    1789-12-31T00:00:00.000000000
    1799-11-09T00:00:00.000000000
    <datetime64[ns]>
    >>> ix.via_re('123').fullmatch()
    [False False False]

    ```

IndexNanosecond.via\_re(*pattern*, *flags).split(maxsplit*)
:   via\_re *= <function Index.via\_re>*

    InterfaceRe.split(*maxsplit=0*)[[source]](../_modules/static_frame/core/node_re.md#InterfaceRe.split)
    :   Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple.

        Parameters:
        :   **maxsplit** – If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.

    ```
    >>> ix = sf.IndexNanosecond(('1789-05-05', '1789-12-31', '1799-11-09'))
    >>> ix
    <IndexNanosecond>
    1789-05-05T00:00:00.000000000
    1789-12-31T00:00:00.000000000
    1799-11-09T00:00:00.000000000
    <datetime64[ns]>
    >>> ix.via_re('[X123]').split()
    [('', '789-05-05T00:00:00.000000000')
     ('', '789-', '', '-', '', 'T00:00:00.000000000')
     ('', '799-', '', '-09T00:00:00.000000000')]

    ```

IndexNanosecond.via\_re(*pattern*, *flags).findall(pos*, *endpos*)
:   via\_re *= <function Index.via\_re>*

    InterfaceRe.findall(*pos=0*, *endpos=None*)[[source]](../_modules/static_frame/core/node_re.md#InterfaceRe.findall)
    :   Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result.

        Parameters:
        :   * **pos** – Gives an index in the string where the search is to start; it defaults to 0.
            * **endpos** – Limits how far the string will be searched; it will be as if the string is endpos characters long.

    ```
    >>> ix = sf.IndexNanosecond(('1789-05-05', '1789-12-31', '1799-11-09'))
    >>> ix
    <IndexNanosecond>
    1789-05-05T00:00:00.000000000
    1789-12-31T00:00:00.000000000
    1799-11-09T00:00:00.000000000
    <datetime64[ns]>
    >>> ix.via_re('[X123]').findall()
    [('1',) ('1', '1', '2', '3', '1') ('1', '1', '1')]

    ```

IndexNanosecond.via\_re(*pattern*, *flags).sub(repl*, *count*)
:   via\_re *= <function Index.via\_re>*

    InterfaceRe.sub(*repl*, *count=0*)[[source]](../_modules/static_frame/core/node_re.md#InterfaceRe.sub)
    :   Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement `repl`. If the pattern is not found, the string is returned unchanged.

        Parameters:
        :   * **repl** – A string or a function; if it is a string, any backslash escapes in it are processed.
            * **count** – The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.

    ```
    >>> ix = sf.IndexNanosecond(('1789-05-05', '1789-12-31', '1799-11-09'))
    >>> ix
    <IndexNanosecond>
    1789-05-05T00:00:00.000000000
    1789-12-31T00:00:00.000000000
    1799-11-09T00:00:00.000000000
    <datetime64[ns]>
    >>> ix.via_re('[X123]').sub('==')
    ['==789-05-05T00:00:00.000000000' '==789-====-====T00:00:00.000000000'
     '==799-====-09T00:00:00.000000000']

    ```

IndexNanosecond.via\_re(*pattern*, *flags).subn(repl*, *count*)
:   via\_re *= <function Index.via\_re>*

    InterfaceRe.subn(*repl*, *count=0*)[[source]](../_modules/static_frame/core/node_re.md#InterfaceRe.subn)
    :   Perform the same operation as sub(), but return a tuple (new\_string, number\_of\_subs\_made).

        Parameters:
        :   * **repl** – A string or a function; if it is a string, any backslash escapes in it are processed.
            * **count** – The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.

    ```
    >>> ix = sf.IndexNanosecond(('1789-05-05', '1789-12-31', '1799-11-09'))
    >>> ix
    <IndexNanosecond>
    1789-05-05T00:00:00.000000000
    1789-12-31T00:00:00.000000000
    1799-11-09T00:00:00.000000000
    <datetime64[ns]>
    >>> ix.via_re('[X123]').subn('==', 1)
    [('==789-05-05T00:00:00.000000000', 1)
     ('==789-12-31T00:00:00.000000000', 1)
     ('==799-11-09T00:00:00.000000000', 1)]

    ```

[IndexNanosecond](index_nanosecond.md#api-detail-indexnanosecond): [Constructor](index_nanosecond-constructor.md#api-detail-indexnanosecond-constructor) | [Exporter](index_nanosecond-exporter.md#api-detail-indexnanosecond-exporter) | [Attribute](index_nanosecond-attribute.md#api-detail-indexnanosecond-attribute) | [Method](index_nanosecond-method.md#api-detail-indexnanosecond-method) | [Dictionary-Like](index_nanosecond-dictionary_like.md#api-detail-indexnanosecond-dictionary-like) | [Display](index_nanosecond-display.md#api-detail-indexnanosecond-display) | [Selector](index_nanosecond-selector.md#api-detail-indexnanosecond-selector) | [Iterator](index_nanosecond-iterator.md#api-detail-indexnanosecond-iterator) | [Operator Binary](index_nanosecond-operator_binary.md#api-detail-indexnanosecond-operator-binary) | [Operator Unary](index_nanosecond-operator_unary.md#api-detail-indexnanosecond-operator-unary) | [Accessor Values](index_nanosecond-accessor_values.md#api-detail-indexnanosecond-accessor-values) | [Accessor Datetime](index_nanosecond-accessor_datetime.md#api-detail-indexnanosecond-accessor-datetime) | [Accessor String](index_nanosecond-accessor_string.md#api-detail-indexnanosecond-accessor-string) | [Accessor Regular Expression](#api-detail-indexnanosecond-accessor-regular-expression) | [Accessor Hashlib](index_nanosecond-accessor_hashlib.md#api-detail-indexnanosecond-accessor-hashlib) | [Accessor Type Clinic](index_nanosecond-accessor_type_clinic.md#api-detail-indexnanosecond-accessor-type-clinic)

[Previous](index_nanosecond-accessor_string.md "Detail: IndexNanosecond: Accessor String")
[Next](index_nanosecond-accessor_hashlib.md "Detail: IndexNanosecond: Accessor Hashlib")

---

© Copyright 2025, Christopher Ariza.
Last updated on Apr 29, 2025.

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme)
provided by [Read the Docs](https://readthedocs.org).