[![Logo](../_static/sf-logo-web_icon-small.png)](../index.html)

Quick Start

* [static-frame](../readme.html)
* [License](../license.html)

Introduction

* [About StaticFrame](../intro.html)
* [Media](../intro.html#media)
* [What is New in StaticFrame](../new.html)
* [Contributing](../contributing.html)

Articles

* [Improving Code Quality with Array and DataFrame Type Hints](../articles/guard.html)
* [Type-Hinting DataFrames for Static Analysis and Runtime Validation](../articles/ftyping.html)
* [Faster DataFrame Serialization](../articles/serialize.html)
* [The Performance Advantage of No-Copy DataFrame Operations](../articles/no_copy.html)
* [Memoizing DataFrame Functions: Using Hashable DataFrames and Message Digests to Optimize Repeated Calculations](../articles/hash.html)
* [Using Higher-Order Containers to Efficiently Process 7,163 (or More) DataFrames](../articles/uhoc.html)
* [One Fill Value Is Not Enough: Preserving Columnar Types When Reindexing DataFrames](../articles/fill_value.html)
* [Ten Reasons to Use StaticFrame Instead of Pandas](../articles/upgrade.html)
* [Boring Indices & Where to Find Them: The Auto-Incremented Integer Index in StaticFrame](../articles/aiii.html)

API Overview

* [Overview: Series](../api_overview/series.html)
* [Overview: SeriesHE](../api_overview/series_he.html)
* [Overview: Frame](../api_overview/frame.html)
* [Overview: FrameGO](../api_overview/frame_go.html)
* [Overview: FrameHE](../api_overview/frame_he.html)
* [Overview: Bus](../api_overview/bus.html)
* [Overview: Batch](../api_overview/batch.html)
* [Overview: Yarn](../api_overview/yarn.html)
* [Overview: Quilt](../api_overview/quilt.html)
* [Overview: Index](../api_overview/index.html)
* [Overview: IndexGO](../api_overview/index_go.html)
* [Overview: IndexHierarchy](../api_overview/index_hierarchy.html)
* [Overview: IndexHierarchyGO](../api_overview/index_hierarchy_go.html)
* [Overview: IndexYear](../api_overview/index_year.html)
* [Overview: IndexYearGO](../api_overview/index_year_go.html)
* [Overview: IndexYearMonth](../api_overview/index_year_month.html)
* [Overview: IndexYearMonthGO](../api_overview/index_year_month_go.html)
* [Overview: IndexDate](../api_overview/index_date.html)
* [Overview: IndexDateGO](../api_overview/index_date_go.html)
* [Overview: IndexMinute](../api_overview/index_minute.html)
* [Overview: IndexMinuteGO](../api_overview/index_minute_go.html)
* [Overview: IndexHour](../api_overview/index_hour.html)
* [Overview: IndexHourGO](../api_overview/index_hour_go.html)
* [Overview: IndexSecond](../api_overview/index_second.html)
* [Overview: IndexSecondGO](../api_overview/index_second_go.html)
* [Overview: IndexMillisecond](../api_overview/index_millisecond.html)
* [Overview: IndexMillisecondGO](../api_overview/index_millisecond_go.html)
* [Overview: IndexMicrosecond](../api_overview/index_microsecond.html)
* [Overview: IndexMicrosecondGO](../api_overview/index_microsecond_go.html)
* [Overview: IndexNanosecond](../api_overview/index_nanosecond.html)
* [Overview: IndexNanosecondGO](../api_overview/index_nanosecond_go.html)
* [Overview: HLoc](../api_overview/hloc.html)
* [Overview: ILoc](../api_overview/iloc.html)
* [Overview: TypeClinic](../api_overview/type_clinic.html)
* [Overview: CallGuard](../api_overview/call_guard.html)
* [Overview: ClinicResult](../api_overview/clinic_result.html)
* [Overview: Require](../api_overview/require.html)
* [Overview: WWW](../api_overview/www.html)
* [Overview: FillValueAuto](../api_overview/fill_value_auto.html)
* [Overview: DisplayActive](../api_overview/display_active.html)
* [Overview: DisplayConfig](../api_overview/display_config.html)
* [Overview: StoreConfig](../api_overview/store_config.html)
* [Overview: StoreFilter](../api_overview/store_filter.html)
* [Overview: IndexAutoFactory](../api_overview/index_auto_factory.html)
* [Overview: IndexDefaultConstructorFactory](../api_overview/index_default_constructor_factory.html)
* [Overview: IndexAutoConstructorFactory](../api_overview/index_auto_constructor_factory.html)
* [Overview: NPZ](../api_overview/npz.html)
* [Overview: NPY](../api_overview/npy.html)
* [Overview: MemoryDisplay](../api_overview/memory_display.html)
* [Overview: Platform](../api_overview/platform.html)

API Detail

* [Detail: Series](series.html)
* [Detail: SeriesHE](series_he.html)
* [Detail: Frame](frame.html)
* [Detail: FrameGO](frame_go.html)
* [Detail: FrameHE](frame_he.html)
* [Detail: Bus](bus.html)
* [Detail: Batch](batch.html)
* [Detail: Yarn](yarn.html)
* [Detail: Quilt](quilt.html)
* [Detail: Index](index.html)
* [Detail: IndexGO](index_go.html)
* [Detail: IndexHierarchy](index_hierarchy.html)
* [Detail: IndexHierarchyGO](index_hierarchy_go.html)
* [Detail: IndexYear](index_year.html)
* [Detail: IndexYearGO](index_year_go.html)
* [Detail: IndexYearMonth](index_year_month.html)
* [Detail: IndexYearMonthGO](index_year_month_go.html)
* [Detail: IndexDate](index_date.html)
* [Detail: IndexDateGO](index_date_go.html)
* [Detail: IndexMinute](index_minute.html)
* [Detail: IndexMinuteGO](index_minute_go.html)
* [Detail: IndexHour](index_hour.html)
* [Detail: IndexHourGO](index_hour_go.html)
* [Detail: IndexSecond](index_second.html)
* [Detail: IndexSecondGO](index_second_go.html)
* [Detail: IndexMillisecond](index_millisecond.html)
* [Detail: IndexMillisecondGO](index_millisecond_go.html)
* [Detail: IndexMicrosecond](index_microsecond.html)
* [Detail: IndexMicrosecondGO](index_microsecond_go.html)
* [Detail: IndexNanosecond](index_nanosecond.html)
* [Detail: IndexNanosecondGO](index_nanosecond_go.html)
* [Detail: HLoc](hloc.html)
* [Detail: ILoc](iloc.html)
* [Detail: TypeClinic](type_clinic.html)
* [Detail: CallGuard](call_guard.html)
* [Detail: ClinicResult](clinic_result.html)
* [Detail: Require](require.html)
* [Detail: WWW](www.html)
* [Detail: FillValueAuto](fill_value_auto.html)
* [Detail: DisplayActive](display_active.html)
* [Detail: DisplayConfig](display_config.html)
* [Detail: StoreConfig](store_config.html)
* [Detail: StoreFilter](store_filter.html)
* [Detail: IndexAutoFactory](index_auto_factory.html)
* [Detail: IndexDefaultConstructorFactory](index_default_constructor_factory.html)
* [Detail: IndexAutoConstructorFactory](index_auto_constructor_factory.html)
* [Detail: NPZ](npz.html)
* [Detail: NPY](npy.html)
* [Detail: MemoryDisplay](memory_display.html)
* [Detail: Platform](platform.html)

[StaticFrame](../index.html)

* Detail: Quilt: Iterator
* [View page source](../_sources/api_detail/quilt-iterator.rst.txt)

[Previous](quilt-selector.html "Detail: Quilt: Selector")
[Next](quilt-accessor_hashlib.html "Detail: Quilt: Accessor Hashlib")

---

# Detail: Quilt: Iterator[](#detail-quilt-iterator "Link to this heading")

[Overview: Quilt: Iterator](../api_overview/quilt-iterator.html#api-overview-quilt-iterator)

Quilt.iter\_array(*\**, *axis*)
:   iter\_array
    :   Iterator of `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_array(axis=1))
    (array([0, 1]), array([2, 3]), array([4, 5]), array([40, 41]), array([42, 43]), array([44, 45]))

    ```

Quilt.iter\_array(*\**, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_array
    :   Iterator of `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_array(axis=1).apply(lambda v: v.sum())
    <Series>
    <IndexHierarchy>
    x                p     1
    x                q     5
    x                r     9
    v                p     81
    v                q     85
    v                r     89
    <<U1>            <<U1> <int64>

    ```

Quilt.iter\_array(*\**, *axis).apply\_iter(func*)
:   iter\_array
    :   Iterator of `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_iter(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_array(axis=1).apply_iter(lambda v: v.sum()))
    (np.int64(1), np.int64(5), np.int64(9), np.int64(81), np.int64(85), np.int64(89))

    ```

Quilt.iter\_array(*\**, *axis).apply\_iter\_items(func*)
:   iter\_array
    :   Iterator of `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_iter\_items(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter_items)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_array(axis=1).apply_iter_items(lambda v: v.sum()))
    (((np.str_('x'), np.str_('p')), np.int64(1)), ((np.str_('x'), np.str_('q')), np.int64(5)), ((np.str_('x'), np.str_('r')), np.int64(9)), ((np.str_('v'), np.str_('p')), np.int64(81)), ((np.str_('v'), np.str_('q')), np.int64(85)), ((np.str_('v'), np.str_('r')), np.int64(89)))

    ```

Quilt.iter\_array(*\**, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_array
    :   Iterator of `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_pool)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_array(axis=1).apply_pool(lambda v: v.sum(), use_threads=True)
    <Series>
    <IndexHierarchy>
    x                p     1
    x                q     5
    x                r     9
    v                p     81
    v                q     85
    v                r     89
    <<U1>            <<U1> <int64>

    ```

Quilt.iter\_array\_items(*\**, *axis*)
:   iter\_array\_items
    :   Iterator of pairs of label, `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_array_items(axis=1))
    (((np.str_('x'), np.str_('p')), array([0, 1])), ((np.str_('x'), np.str_('q')), array([2, 3])), ((np.str_('x'), np.str_('r')), array([4, 5])), ((np.str_('v'), np.str_('p')), array([40, 41])), ((np.str_('v'), np.str_('q')), array([42, 43])), ((np.str_('v'), np.str_('r')), array([44, 45])))

    ```

Quilt.iter\_array\_items(*\**, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_array\_items
    :   Iterator of pairs of label, `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_array_items(axis=1).apply(lambda k, v: v.sum() if 'q' in k else -1)
    <Series>
    <IndexHierarchy>
    x                p     -1
    x                q     5
    x                r     -1
    v                p     -1
    v                q     85
    v                r     -1
    <<U1>            <<U1> <int64>

    ```

Quilt.iter\_array\_items(*\**, *axis).apply\_iter(func*)
:   iter\_array\_items
    :   Iterator of pairs of label, `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_iter(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_array_items(axis=1).apply_iter(lambda k, v: v.sum() if 'q' in k else -1))
    (-1, np.int64(5), -1, -1, np.int64(85), -1)

    ```

Quilt.iter\_array\_items(*\**, *axis).apply\_iter\_items(func*)
:   iter\_array\_items
    :   Iterator of pairs of label, `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_iter\_items(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter_items)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_array_items(axis=1).apply_iter_items(lambda k, v: v.sum() if 'q' in k else -1))
    (((np.str_('x'), np.str_('p')), -1), ((np.str_('x'), np.str_('q')), np.int64(5)), ((np.str_('x'), np.str_('r')), -1), ((np.str_('v'), np.str_('p')), -1), ((np.str_('v'), np.str_('q')), np.int64(85)), ((np.str_('v'), np.str_('r')), -1))

    ```

Quilt.iter\_array\_items(*\**, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_array\_items
    :   Iterator of pairs of label, `np.array`, where arrays are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_pool)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_array_items(axis=1).apply_pool(lambda pair: pair[1].sum() if pair[0][1] != 'p' else -1, use_threads=True)
    <Series>
    <IndexHierarchy>
    x                p     -1
    x                q     5
    x                r     9
    v                p     -1
    v                q     85
    v                r     89
    <<U1>            <<U1> <int64>

    ```

Quilt.iter\_series(*\**, *axis*)
:   iter\_series
    :   Iterator of [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_series(axis=1))
    (<Series: (np.str_('x'), np.str_('...
    <Index>
    a                                    0
    b                                    1
    <<U1>                                <int64>, <Series: (np.str_('x'), np.str_('...
    <Index>
    a                                    2
    b                                    3
    <<U1>                                <int64>, <Series: (np.str_('x'), np.str_('...
    <Index>
    a                                    4
    b                                    5
    <<U1>                                <int64>, <Series: (np.str_('v'), np.str_('...
    <Index>
    a                                    40
    b                                    41
    <<U1>                                <int64>, <Series: (np.str_('v'), np.str_('...
    <Index>
    a                                    42
    b                                    43
    <<U1>                                <int64>, <Series: (np.str_('v'), np.str_('...
    <Index>
    a                                    44
    b                                    45
    <<U1>                                <int64>)

    ```

Quilt.iter\_series(*\**, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_series
    :   Iterator of [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_series(axis=1).apply(lambda v: v.sum())
    <Series>
    <IndexHierarchy>
    x                p     1
    x                q     5
    x                r     9
    v                p     81
    v                q     85
    v                r     89
    <<U1>            <<U1> <int64>

    ```

Quilt.iter\_series(*\**, *axis).apply\_iter(func*)
:   iter\_series
    :   Iterator of [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_iter(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_series(axis=1).apply_iter(lambda v: v.sum()))
    (np.int64(1), np.int64(5), np.int64(9), np.int64(81), np.int64(85), np.int64(89))

    ```

Quilt.iter\_series(*\**, *axis).apply\_iter\_items(func*)
:   iter\_series
    :   Iterator of [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_iter\_items(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter_items)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_series(axis=1).apply_iter_items(lambda v: v.sum()))
    (((np.str_('x'), np.str_('p')), np.int64(1)), ((np.str_('x'), np.str_('q')), np.int64(5)), ((np.str_('x'), np.str_('r')), np.int64(9)), ((np.str_('v'), np.str_('p')), np.int64(81)), ((np.str_('v'), np.str_('q')), np.int64(85)), ((np.str_('v'), np.str_('r')), np.int64(89)))

    ```

Quilt.iter\_series(*\**, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_series
    :   Iterator of [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_pool)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_series(axis=1).apply_pool(lambda v: v.sum(), use_threads=True)
    <Series>
    <IndexHierarchy>
    x                p     1
    x                q     5
    x                r     9
    v                p     81
    v                q     85
    v                r     89
    <<U1>            <<U1> <int64>

    ```

Quilt.iter\_series\_items(*\**, *axis*)
:   iter\_series\_items
    :   Iterator of pairs of label, [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_series_items(axis=1))
    (((np.str_('x'), np.str_('p')), <Series: (np.str_('x'), np.str_('...
    <Index>
    a                                    0
    b                                    1
    <<U1>                                <int64>), ((np.str_('x'), np.str_('q')), <Series: (np.str_('x'), np.str_('...
    <Index>
    a                                    2
    b                                    3
    <<U1>                                <int64>), ((np.str_('x'), np.str_('r')), <Series: (np.str_('x'), np.str_('...
    <Index>
    a                                    4
    b                                    5
    <<U1>                                <int64>), ((np.str_('v'), np.str_('p')), <Series: (np.str_('v'), np.str_('...
    <Index>
    a                                    40
    b                                    41
    <<U1>                                <int64>), ((np.str_('v'), np.str_('q')), <Series: (np.str_('v'), np.str_('...
    <Index>
    a                                    42
    b                                    43
    <<U1>                                <int64>), ((np.str_('v'), np.str_('r')), <Series: (np.str_('v'), np.str_('...
    <Index>
    a                                    44
    b                                    45
    <<U1>                                <int64>))

    ```

Quilt.iter\_series\_items(*\**, *axis).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_series\_items
    :   Iterator of pairs of label, [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_series_items(axis=1).apply(lambda k, v: v.sum() if 'q' in k else -1)
    <Series>
    <IndexHierarchy>
    x                p     -1
    x                q     5
    x                r     -1
    v                p     -1
    v                q     85
    v                r     -1
    <<U1>            <<U1> <int64>

    ```

Quilt.iter\_series\_items(*\**, *axis).apply\_iter(func*)
:   iter\_series\_items
    :   Iterator of pairs of label, [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_iter(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_series_items(axis=1).apply_iter(lambda k, v: v.sum() if 'q' in k else -1))
    (-1, np.int64(5), -1, -1, np.int64(85), -1)

    ```

Quilt.iter\_series\_items(*\**, *axis).apply\_iter\_items(func*)
:   iter\_series\_items
    :   Iterator of pairs of label, [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_iter\_items(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter_items)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_series_items(axis=1).apply_iter_items(lambda k, v: v.sum() if 'q' in k else -1))
    (((np.str_('x'), np.str_('p')), -1), ((np.str_('x'), np.str_('q')), np.int64(5)), ((np.str_('x'), np.str_('r')), -1), ((np.str_('v'), np.str_('p')), -1), ((np.str_('v'), np.str_('q')), np.int64(85)), ((np.str_('v'), np.str_('r')), -1))

    ```

Quilt.iter\_series\_items(*\**, *axis).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_series\_items
    :   Iterator of pairs of label, [`Series`](series-selector.html#Series "Series"), where [`Series`](series-selector.html#Series "Series") are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegate.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_pool)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_series_items(axis=1).apply_pool(lambda pair: pair[1].sum() if pair[0][1] != 'p' else -1, use_threads=True)
    <Series>
    <IndexHierarchy>
    x                p     -1
    x                q     5
    x                r     9
    v                p     -1
    v                q     85
    v                r     89
    <<U1>            <<U1> <int64>

    ```

Quilt.iter\_tuple(*\**, *axis*, *constructor*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_tuple(axis=1))
    (Axis(a=np.int64(0), b=np.int64(1)), Axis(a=np.int64(2), b=np.int64(3)), Axis(a=np.int64(4), b=np.int64(5)), Axis(a=np.int64(40), b=np.int64(41)), Axis(a=np.int64(42), b=np.int64(43)), Axis(a=np.int64(44), b=np.int64(45)))

    ```

Quilt.iter\_tuple(*\**, *axis*, *constructor).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_tuple(axis=1).apply(lambda v: v.a + v.b)
    <Series>
    <IndexHierarchy>
    x                p     1
    x                q     5
    x                r     9
    v                p     81
    v                q     85
    v                r     89
    <<U1>            <<U1> <int64>

    ```

Quilt.iter\_tuple(*\**, *axis*, *constructor).apply\_iter(func*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_tuple(axis=1).apply_iter(lambda v: v.a + v.b))
    (np.int64(1), np.int64(5), np.int64(9), np.int64(81), np.int64(85), np.int64(89))

    ```

Quilt.iter\_tuple(*\**, *axis*, *constructor).apply\_iter\_items(func*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_tuple(axis=1).apply_iter_items(lambda v: v.a + v.b))
    (((np.str_('x'), np.str_('p')), np.int64(1)), ((np.str_('x'), np.str_('q')), np.int64(5)), ((np.str_('x'), np.str_('r')), np.int64(9)), ((np.str_('v'), np.str_('p')), np.int64(81)), ((np.str_('v'), np.str_('q')), np.int64(85)), ((np.str_('v'), np.str_('r')), np.int64(89)))

    ```

Quilt.iter\_tuple(*\**, *axis*, *constructor).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Quilt.iter\_tuple(*\**, *axis*, *constructor).map\_all(mapping*, *\**, *dtype*, *name*, *index\_constructor*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_all(*mapping*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iloc[:2].iter_tuple(axis=1).map_all({(0, 1): -1, (2, 3): -2})
    <Series>
    <IndexHierarchy>
    x                p     -1
    x                q     -2
    <<U1>            <<U1> <int64>

    ```

Quilt.iter\_tuple(*\**, *axis*, *constructor).map\_all\_iter(mapping*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_all\_iter(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all_iter)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iloc[:2].iter_tuple(axis=1).map_all_iter({(0, 1): -1, (2, 3): -2}))
    (-1, -2)

    ```

Quilt.iter\_tuple(*\**, *axis*, *constructor).map\_all\_iter\_items(mapping*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_all\_iter\_items(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all_iter_items)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iloc[:2].iter_tuple(axis=1).map_all_iter_items({(0, 1): -1, (2, 3): -2}))
    (((np.str_('x'), np.str_('p')), -1), ((np.str_('x'), np.str_('q')), -2))

    ```

Quilt.iter\_tuple(*\**, *axis*, *constructor).map\_any(mapping*, *\**, *dtype*, *name*, *index\_constructor*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_any(*mapping*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any)
    :   Apply a mapping; for values not in the mapping, the value is returned. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_tuple(axis=1).map_any({(0, 1): -1, (42, 43): -2})
    <Series>
    <IndexHierarchy>
    x                p     -1
    x                q     Axis(a=np.int64(2...
    x                r     Axis(a=np.int64(4...
    v                p     Axis(a=np.int64(4...
    v                q     -2
    v                r     Axis(a=np.int64(4...
    <<U1>            <<U1> <object>

    ```

Quilt.iter\_tuple(*\**, *axis*, *constructor).map\_any\_iter(mapping*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_any\_iter(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any_iter)
    :   Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_tuple(axis=1).map_any_iter({(0, 1): -1, (42, 43): -2}))
    (-1, Axis(a=np.int64(2), b=np.int64(3)), Axis(a=np.int64(4), b=np.int64(5)), Axis(a=np.int64(40), b=np.int64(41)), -2, Axis(a=np.int64(44), b=np.int64(45)))

    ```

Quilt.iter\_tuple(*\**, *axis*, *constructor).map\_any\_iter\_items(mapping*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_any\_iter\_items(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any_iter_items)
    :   Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_tuple(axis=1).map_any_iter_items({(0, 1): -1, (42, 43): -2}))
    (((np.str_('x'), np.str_('p')), -1), ((np.str_('x'), np.str_('q')), Axis(a=np.int64(2), b=np.int64(3))), ((np.str_('x'), np.str_('r')), Axis(a=np.int64(4), b=np.int64(5))), ((np.str_('v'), np.str_('p')), Axis(a=np.int64(40), b=np.int64(41))), ((np.str_('v'), np.str_('q')), -2), ((np.str_('v'), np.str_('r')), Axis(a=np.int64(44), b=np.int64(45))))

    ```

Quilt.iter\_tuple(*\**, *axis*, *constructor).map\_fill(mapping*, *\**, *fill\_value*, *dtype*, *name*, *index\_constructor*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_fill(*mapping*, */*, *\**, *fill\_value=nan*, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_tuple(axis=1).map_fill({(0, 1): -1, (42, 43): -2}, fill_value=np.nan)
    <Series>
    <IndexHierarchy>
    x                p     -1.0
    x                q     nan
    x                r     nan
    v                p     nan
    v                q     -2.0
    v                r     nan
    <<U1>            <<U1> <float64>

    ```

Quilt.iter\_tuple(*\**, *axis*, *constructor).map\_fill\_iter(mapping*, *\**, *fill\_value*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_fill\_iter(*mapping*, */*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill_iter)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. A generator of resulting values.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_tuple(axis=1).map_fill_iter({(0, 1): -1, (42, 43): -2}, fill_value=np.nan))
    (-1, nan, nan, nan, -2, nan)

    ```

Quilt.iter\_tuple(*\**, *axis*, *constructor).map\_fill\_iter\_items(mapping*, *\**, *fill\_value*)
:   iter\_tuple
    :   Iterator of `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional `constructor` callable can be used to provide a `NamedTuple` class (or any other constructor called with a single iterable) to be used to create each yielded axis value.

    IterNodeDelegateMapable.map\_fill\_iter\_items(*mapping*, */*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill_iter_items)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. A generator of resulting key, value pairs.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_tuple(axis=1).map_fill_iter_items({(0, 1): -1, (42, 43): -2}, fill_value=np.nan))
    (((np.str_('x'), np.str_('p')), -1), ((np.str_('x'), np.str_('q')), nan), ((np.str_('x'), np.str_('r')), nan), ((np.str_('v'), np.str_('p')), nan), ((np.str_('v'), np.str_('q')), -2), ((np.str_('v'), np.str_('r')), nan))

    ```

Quilt.iter\_tuple\_items(*\**, *axis*, *constructor*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_tuple_items(axis=1))
    (((np.str_('x'), np.str_('p')), Axis(a=np.int64(0), b=np.int64(1))), ((np.str_('x'), np.str_('q')), Axis(a=np.int64(2), b=np.int64(3))), ((np.str_('x'), np.str_('r')), Axis(a=np.int64(4), b=np.int64(5))), ((np.str_('v'), np.str_('p')), Axis(a=np.int64(40), b=np.int64(41))), ((np.str_('v'), np.str_('q')), Axis(a=np.int64(42), b=np.int64(43))), ((np.str_('v'), np.str_('r')), Axis(a=np.int64(44), b=np.int64(45))))

    ```

Quilt.iter\_tuple\_items(*\**, *axis*, *constructor).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_tuple_items(axis=1).apply(lambda k, v: v.a + v.b if 'r' in k else -1)
    <Series>
    <IndexHierarchy>
    x                p     -1
    x                q     -1
    x                r     9
    v                p     -1
    v                q     -1
    v                r     89
    <<U1>            <<U1> <int64>

    ```

Quilt.iter\_tuple\_items(*\**, *axis*, *constructor).apply\_iter(func*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.apply\_iter(*func*, */*)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_tuple_items(axis=1).apply_iter(lambda k, v: v.a + v.b if 'r' in k else -1))
    (-1, -1, np.int64(9), -1, -1, np.int64(89))

    ```

Quilt.iter\_tuple\_items(*\**, *axis*, *constructor).apply\_iter\_items(func*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.apply\_iter\_items(*func*, */*)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_tuple_items(axis=1).apply_iter_items(lambda k, v: v.a + v.b if 'r' in k else -1))
    (((np.str_('x'), np.str_('p')), -1), ((np.str_('x'), np.str_('q')), -1), ((np.str_('x'), np.str_('r')), np.int64(9)), ((np.str_('v'), np.str_('p')), -1), ((np.str_('v'), np.str_('q')), -1), ((np.str_('v'), np.str_('r')), np.int64(89)))

    ```

Quilt.iter\_tuple\_items(*\**, *axis*, *constructor).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Quilt.iter\_tuple\_items(*\**, *axis*, *constructor).map\_all(mapping*, *\**, *dtype*, *name*, *index\_constructor*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_all(*mapping*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iloc[:2].iter_tuple_items(axis=1).map_all({(('x', 'p'), (0, 1)): -1, (('x', 'q'), (2, 3)): -2})
    <Series>
    <IndexHierarchy>
    x                p     -1
    x                q     -2
    <<U1>            <<U1> <int64>

    ```

Quilt.iter\_tuple\_items(*\**, *axis*, *constructor).map\_all\_iter(mapping*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_all\_iter(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all_iter)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iloc[:2].iter_tuple_items(axis=1).map_all_iter({(('x', 'p'), (0, 1)): -1, (('x', 'q'), (2, 3)): -2}))
    (-1, -2)

    ```

Quilt.iter\_tuple\_items(*\**, *axis*, *constructor).map\_all\_iter\_items(mapping*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_all\_iter\_items(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_all_iter_items)
    :   Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iloc[:2].iter_tuple_items(axis=1).map_all_iter_items({(('x', 'p'), (0, 1)): -1, (('x', 'q'), (2, 3)): -2}))
    (((np.str_('x'), np.str_('p')), -1), ((np.str_('x'), np.str_('q')), -2))

    ```

Quilt.iter\_tuple\_items(*\**, *axis*, *constructor).map\_any(mapping*, *\**, *dtype*, *name*, *index\_constructor*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_any(*mapping*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any)
    :   Apply a mapping; for values not in the mapping, the value is returned. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_tuple_items(axis=1).map_any({(('x', 'p'), (0, 1)): -1, (('x', 'q'), (2, 3)): -2})
    <Series>
    <IndexHierarchy>
    x                p     -1
    x                q     -2
    x                r     Axis(a=np.int64(4...
    v                p     Axis(a=np.int64(4...
    v                q     Axis(a=np.int64(4...
    v                r     Axis(a=np.int64(4...
    <<U1>            <<U1> <object>

    ```

Quilt.iter\_tuple\_items(*\**, *axis*, *constructor).map\_any\_iter(mapping*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_any\_iter(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any_iter)
    :   Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_tuple_items(axis=1).map_any_iter({(('x', 'p'), (0, 1)): -1, (('x', 'q'), (2, 3)): -2}))
    (-1, -2, Axis(a=np.int64(4), b=np.int64(5)), Axis(a=np.int64(40), b=np.int64(41)), Axis(a=np.int64(42), b=np.int64(43)), Axis(a=np.int64(44), b=np.int64(45)))

    ```

Quilt.iter\_tuple\_items(*\**, *axis*, *constructor).map\_any\_iter\_items(mapping*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_any\_iter\_items(*mapping*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_any_iter_items)
    :   Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs.

        Parameters:
        :   **mapping** – A mapping type, such as a dictionary or Series.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_tuple_items(axis=1).map_any_iter_items({(('x', 'p'), (0, 1)): -1, (('x', 'q'), (2, 3)): -2}))
    (((np.str_('x'), np.str_('p')), -1), ((np.str_('x'), np.str_('q')), -2), ((np.str_('x'), np.str_('r')), Axis(a=np.int64(4), b=np.int64(5))), ((np.str_('v'), np.str_('p')), Axis(a=np.int64(40), b=np.int64(41))), ((np.str_('v'), np.str_('q')), Axis(a=np.int64(42), b=np.int64(43))), ((np.str_('v'), np.str_('r')), Axis(a=np.int64(44), b=np.int64(45))))

    ```

Quilt.iter\_tuple\_items(*\**, *axis*, *constructor).map\_fill(mapping*, *\**, *fill\_value*, *dtype*, *name*, *index\_constructor*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_fill(*mapping*, */*, *\**, *fill\_value=nan*, *dtype=None*, *name=None*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. Returns a new container.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_tuple_items(axis=1).map_fill({(('x', 'p'), (0, 1)): -1, (('x', 'q'), (2, 3)): -2}, fill_value=np.nan)
    <Series>
    <IndexHierarchy>
    x                p     -1.0
    x                q     -2.0
    x                r     nan
    v                p     nan
    v                q     nan
    v                r     nan
    <<U1>            <<U1> <float64>

    ```

Quilt.iter\_tuple\_items(*\**, *axis*, *constructor).map\_fill\_iter(mapping*, *\**, *fill\_value*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_fill\_iter(*mapping*, */*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill_iter)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. A generator of resulting values.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_tuple_items(axis=1).map_fill_iter({(('x', 'p'), (0, 1)): -1, (('x', 'q'), (2, 3)): -2}, fill_value=np.nan))
    (-1, -2, nan, nan, nan, nan)

    ```

Quilt.iter\_tuple\_items(*\**, *axis*, *constructor).map\_fill\_iter\_items(mapping*, *\**, *fill\_value*)
:   iter\_tuple\_items
    :   Iterator of pairs of label, `NamedTuple`, where tuples are drawn from columns (axis=0) or rows (axis=1)

    IterNodeDelegateMapable.map\_fill\_iter\_items(*mapping*, */*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegateMapable.map_fill_iter_items)
    :   Apply a mapping; for values not in the mapping, the `fill_value` is returned. A generator of resulting key, value pairs.

        Parameters:
        :   * **mapping** – A mapping type, such as a dictionary or Series.
            * **fill\_value** – Value to be returned if the values is not a key in the mapping.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_tuple_items(axis=1).map_fill_iter_items({(('x', 'p'), (0, 1)): -1, (('x', 'q'), (2, 3)): -2}, fill_value=np.nan))
    (((np.str_('x'), np.str_('p')), -1), ((np.str_('x'), np.str_('q')), -2), ((np.str_('x'), np.str_('r')), nan), ((np.str_('v'), np.str_('p')), nan), ((np.str_('v'), np.str_('q')), nan), ((np.str_('v'), np.str_('r')), nan))

    ```

Quilt.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_window(size=2, step=2, axis=0))
    (<Frame: x>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    x                p     0       1
    x                q     2       3
    <<U1>            <<U1> <int64> <int64>, <Frame>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    x                r     4       5
    v                p     40      41
    <<U1>            <<U1> <int64> <int64>, <Frame: v>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    v                q     42      43
    v                r     44      45
    <<U1>            <<U1> <int64> <int64>)

    ```

Quilt.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegate.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_window(size=2, step=2, axis=0).apply(lambda f: f.max().max())
    <Series>
    <IndexHierarchy>
    x                q     3
    v                p     41
    v                r     45
    <<U1>            <<U1> <int64>

    ```

Quilt.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_iter(func*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegate.apply\_iter(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_window(size=2, step=2, axis=0).apply_iter(lambda f: f.max().max()))
    (np.int64(3), np.int64(41), np.int64(45))

    ```

Quilt.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_iter\_items(func*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegate.apply\_iter\_items(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter_items)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_window(size=2, step=2, axis=0).apply_iter_items(lambda f: f.max().max()))
    (((np.str_('x'), np.str_('q')), np.int64(3)), ((np.str_('v'), np.str_('p')), np.int64(41)), ((np.str_('v'), np.str_('r')), np.int64(45)))

    ```

Quilt.iter\_window(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_window
    :   Iterator of windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegate.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_pool)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Quilt.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_window_array(size=2, step=2, axis=0))
    (array([[0, 1],
           [2, 3]]), array([[ 4,  5],
           [40, 41]]), array([[42, 43],
           [44, 45]]))

    ```

Quilt.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegate.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_window_array(size=2, step=2, axis=0).apply(lambda a: np.max(a))
    <Series>
    <IndexHierarchy>
    x                q     3
    v                p     41
    v                r     45
    <<U1>            <<U1> <int64>

    ```

Quilt.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_iter(func*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegate.apply\_iter(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_window_array(size=2, step=2, axis=0).apply_iter(lambda a: np.max(a)))
    (np.int64(3), np.int64(41), np.int64(45))

    ```

Quilt.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_iter\_items(func*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegate.apply\_iter\_items(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter_items)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_window_array(size=2, step=2, axis=0).apply_iter_items(lambda a: np.max(a)))
    (((np.str_('x'), np.str_('q')), np.int64(3)), ((np.str_('v'), np.str_('p')), np.int64(41)), ((np.str_('v'), np.str_('r')), np.int64(45)))

    ```

Quilt.iter\_window\_array(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_window\_array
    :   Iterator of windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegate.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_pool)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Quilt.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_window_array_items(size=2, step=2, axis=0))
    (((np.str_('x'), np.str_('q')), array([[0, 1],
           [2, 3]])), ((np.str_('v'), np.str_('p')), array([[ 4,  5],
           [40, 41]])), ((np.str_('v'), np.str_('r')), array([[42, 43],
           [44, 45]])))

    ```

Quilt.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegate.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_window_array_items(size=2, step=2, axis=0).apply(lambda k, v: np.max(v) if k == ('v', 'p') else np.min(v))
    <Series>
    <IndexHierarchy>
    x                q     0
    v                p     41
    v                r     42
    <<U1>            <<U1> <int64>

    ```

Quilt.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_iter(func*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegate.apply\_iter(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_window_array_items(size=2, step=2, axis=0).apply_iter(lambda k, v: np.max(v) if k == ('v', 'p') else np.min(v)))
    (np.int64(0), np.int64(41), np.int64(42))

    ```

Quilt.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_iter\_items(func*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegate.apply\_iter\_items(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter_items)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_window_array_items(size=2, step=2, axis=0).apply_iter_items(lambda k, v: np.max(v) if k == ('v', 'p') else np.min(v)))
    (((np.str_('x'), np.str_('q')), np.int64(0)), ((np.str_('v'), np.str_('p')), np.int64(41)), ((np.str_('v'), np.str_('r')), np.int64(42)))

    ```

Quilt.iter\_window\_array\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_window\_array\_items
    :   Iterator of pairs of label, windowed values, where values are given as a `np.array`.

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegate.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_pool)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

Quilt.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_window_items(size=2, step=2, axis=0))
    (((np.str_('x'), np.str_('q')), <Frame: x>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    x                p     0       1
    x                q     2       3
    <<U1>            <<U1> <int64> <int64>), ((np.str_('v'), np.str_('p')), <Frame>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    x                r     4       5
    v                p     40      41
    <<U1>            <<U1> <int64> <int64>), ((np.str_('v'), np.str_('r')), <Frame: v>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    v                q     42      43
    v                r     44      45
    <<U1>            <<U1> <int64> <int64>))

    ```

Quilt.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply(func*, *\**, *dtype*, *name*, *index\_constructor*, *columns\_constructor*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegate.apply(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply)
    :   Apply a function to each value. Returns a new container.

        Parameters:
        :   * **func** – A function that takes a value.
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> q.iter_window_items(size=2, step=2, axis=0).apply(lambda k, v: v.max().max() if k == ('v', 'p') else v.min().min())
    <Series>
    <IndexHierarchy>
    x                q     0
    v                p     41
    v                r     42
    <<U1>            <<U1> <int64>

    ```

Quilt.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_iter(func*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegate.apply\_iter(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter)
    :   Apply a function to each value. A generator of resulting values.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Values after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_window_items(size=2, step=2, axis=0).apply_iter(lambda k, v: v.max().max() if k == ('v', 'p') else v.min().min()))
    (np.int64(0), np.int64(41), np.int64(42))

    ```

Quilt.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_iter\_items(func*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegate.apply\_iter\_items(*func*, */*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_iter_items)
    :   Apply a function to each value. A generator of resulting key, value pairs.

        Parameters:
        :   **func** – A function that takes a value.

        Yields:
        :   Pairs of label, value after function application.

    ```
    >>> b = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), name='j')
    >>> q = sf.Quilt(b, retain_labels=True, axis=0)
    >>> q
    <Quilt: j>
    <Index: Aligned> a b <<U1>
    <Index: Frames>
    x                . .
    v                . .
    <<U1>
    >>> tuple(q.iter_window_items(size=2, step=2, axis=0).apply_iter_items(lambda k, v: v.max().max() if k == ('v', 'p') else v.min().min()))
    (((np.str_('x'), np.str_('q')), np.int64(0)), ((np.str_('v'), np.str_('p')), np.int64(41)), ((np.str_('v'), np.str_('r')), np.int64(42)))

    ```

Quilt.iter\_window\_items(*\**, *size*, *axis*, *step*, *window\_sized*, *window\_func*, *window\_valid*, *label\_shift*, *label\_missing\_skips*, *label\_missing\_raises*, *start\_shift*, *size\_increment).apply\_pool(func*, *\**, *dtype*, *name*, *index\_constructor*, *max\_workers*, *chunksize*, *use\_threads*)
:   iter\_window\_items
    :   Iterator of pairs of label, windowed values, where values are given as a [`Frame`](frame-selector.html#Frame "Frame").

        Parameters:
        :   * **size** – Elements per window, given as an integer greater than 0.
            * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
            * **step** – Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the `size` will result in non-overlapping windows.
            * **window\_sized** – if True, windows with fewer elements than `size` are skipped.
            * **window\_func** – Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window.
            * **window\_valid** – Function that, given an array window, returns True if the window is valid; invalid windows are skipped.
            * **label\_shift** – A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, `label_shift` can be set to one less than `size`.
            * **label\_missing\_skips** – If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label.
            * **label\_missing\_raises** – If True, a window that cannot derive a label will raise an exception.
            * **start\_shift** – A shift to determine the first element where window collection begins.
            * **size\_increment** – A value to be added to `size` with each window after the first, so as to, in combination with setting `step` to 0, permit iterating over expanding windows.

    IterNodeDelegate.apply\_pool(*func*, */*, *\**, *dtype=None*, *name=None*, *index\_constructor=None*, *max\_workers=None*, *chunksize=1*, *use\_threads=False*)[[source]](../_modules/static_frame/core/node_iter.html#IterNodeDelegate.apply_pool)
    :   Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor.

        Parameters:
        :   * **func** – A function that takes a value.
            * **\*** –
            * **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.
            * **name** – A hashable object to label the container.
            * **max\_workers** – Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; `None` defaults to the max number of machine processes.
            * **chunksize** – Units of work per executor, as passed to the Thread- or ProcessPoolExecutor.
            * **use\_threads** – Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.

[Quilt](quilt.html#api-detail-quilt): [Constructor](quilt-constructor.html#api-detail-quilt-constructor) | [Exporter](quilt-exporter.html#api-detail-quilt-exporter) | [Attribute](quilt-attribute.html#api-detail-quilt-attribute) | [Method](quilt-method.html#api-detail-quilt-method) | [Dictionary-Like](quilt-dictionary_like.html#api-detail-quilt-dictionary-like) | [Display](quilt-display.html#api-detail-quilt-display) | [Selector](quilt-selector.html#api-detail-quilt-selector) | [Iterator](#api-detail-quilt-iterator) | [Accessor Hashlib](quilt-accessor_hashlib.html#api-detail-quilt-accessor-hashlib) | [Accessor Type Clinic](quilt-accessor_type_clinic.html#api-detail-quilt-accessor-type-clinic)

[Previous](quilt-selector.html "Detail: Quilt: Selector")
[Next](quilt-accessor_hashlib.html "Detail: Quilt: Accessor Hashlib")

---

© Copyright 2025, Christopher Ariza.
Last updated on Apr 29, 2025.

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme)
provided by [Read the Docs](https://readthedocs.org).