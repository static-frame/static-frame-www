[![Logo](../_static/sf-logo-web_icon-small.png)](../index.md)

Quick Start

* [static-frame](../readme.md)
* [License](../license.md)

Introduction

* [About StaticFrame](../intro.md)
* [Media](../intro.md#media)
* [What is New in StaticFrame](../new.md)
* [Contributing](../contributing.md)

Articles

* [Improving Code Quality with Array and DataFrame Type Hints](../articles/guard.md)
* [Type-Hinting DataFrames for Static Analysis and Runtime Validation](../articles/ftyping.md)
* [Faster DataFrame Serialization](../articles/serialize.md)
* [The Performance Advantage of No-Copy DataFrame Operations](../articles/no_copy.md)
* [Memoizing DataFrame Functions: Using Hashable DataFrames and Message Digests to Optimize Repeated Calculations](../articles/hash.md)
* [Using Higher-Order Containers to Efficiently Process 7,163 (or More) DataFrames](../articles/uhoc.md)
* [One Fill Value Is Not Enough: Preserving Columnar Types When Reindexing DataFrames](../articles/fill_value.md)
* [Ten Reasons to Use StaticFrame Instead of Pandas](../articles/upgrade.md)
* [Boring Indices & Where to Find Them: The Auto-Incremented Integer Index in StaticFrame](../articles/aiii.md)

API Overview

* [Overview: Series](../api_overview/series.md)
* [Overview: SeriesHE](../api_overview/series_he.md)
* [Overview: Frame](../api_overview/frame.md)
* [Overview: FrameGO](../api_overview/frame_go.md)
* [Overview: FrameHE](../api_overview/frame_he.md)
* [Overview: Bus](../api_overview/bus.md)
* [Overview: Batch](../api_overview/batch.md)
* [Overview: Yarn](../api_overview/yarn.md)
* [Overview: Quilt](../api_overview/quilt.md)
* [Overview: Index](../api_overview/index.md)
* [Overview: IndexGO](../api_overview/index_go.md)
* [Overview: IndexHierarchy](../api_overview/index_hierarchy.md)
* [Overview: IndexHierarchyGO](../api_overview/index_hierarchy_go.md)
* [Overview: IndexYear](../api_overview/index_year.md)
* [Overview: IndexYearGO](../api_overview/index_year_go.md)
* [Overview: IndexYearMonth](../api_overview/index_year_month.md)
* [Overview: IndexYearMonthGO](../api_overview/index_year_month_go.md)
* [Overview: IndexDate](../api_overview/index_date.md)
* [Overview: IndexDateGO](../api_overview/index_date_go.md)
* [Overview: IndexMinute](../api_overview/index_minute.md)
* [Overview: IndexMinuteGO](../api_overview/index_minute_go.md)
* [Overview: IndexHour](../api_overview/index_hour.md)
* [Overview: IndexHourGO](../api_overview/index_hour_go.md)
* [Overview: IndexSecond](../api_overview/index_second.md)
* [Overview: IndexSecondGO](../api_overview/index_second_go.md)
* [Overview: IndexMillisecond](../api_overview/index_millisecond.md)
* [Overview: IndexMillisecondGO](../api_overview/index_millisecond_go.md)
* [Overview: IndexMicrosecond](../api_overview/index_microsecond.md)
* [Overview: IndexMicrosecondGO](../api_overview/index_microsecond_go.md)
* [Overview: IndexNanosecond](../api_overview/index_nanosecond.md)
* [Overview: IndexNanosecondGO](../api_overview/index_nanosecond_go.md)
* [Overview: HLoc](../api_overview/hloc.md)
* [Overview: ILoc](../api_overview/iloc.md)
* [Overview: TypeClinic](../api_overview/type_clinic.md)
* [Overview: CallGuard](../api_overview/call_guard.md)
* [Overview: ClinicResult](../api_overview/clinic_result.md)
* [Overview: Require](../api_overview/require.md)
* [Overview: WWW](../api_overview/www.md)
* [Overview: FillValueAuto](../api_overview/fill_value_auto.md)
* [Overview: DisplayActive](../api_overview/display_active.md)
* [Overview: DisplayConfig](../api_overview/display_config.md)
* [Overview: StoreConfig](../api_overview/store_config.md)
* [Overview: StoreFilter](../api_overview/store_filter.md)
* [Overview: IndexAutoFactory](../api_overview/index_auto_factory.md)
* [Overview: IndexDefaultConstructorFactory](../api_overview/index_default_constructor_factory.md)
* [Overview: IndexAutoConstructorFactory](../api_overview/index_auto_constructor_factory.md)
* [Overview: NPZ](../api_overview/npz.md)
* [Overview: NPY](../api_overview/npy.md)
* [Overview: MemoryDisplay](../api_overview/memory_display.md)
* [Overview: Platform](../api_overview/platform.md)

API Detail

* [Detail: Series](series.md)
* [Detail: SeriesHE](series_he.md)
* [Detail: Frame](frame.md)
* [Detail: FrameGO](frame_go.md)
* [Detail: FrameHE](frame_he.md)
* [Detail: Bus](bus.md)
* [Detail: Batch](batch.md)
* [Detail: Yarn](yarn.md)
* [Detail: Quilt](quilt.md)
* [Detail: Index](index.md)
* [Detail: IndexGO](index_go.md)
* [Detail: IndexHierarchy](index_hierarchy.md)
* [Detail: IndexHierarchyGO](index_hierarchy_go.md)
* [Detail: IndexYear](index_year.md)
* [Detail: IndexYearGO](index_year_go.md)
* [Detail: IndexYearMonth](index_year_month.md)
* [Detail: IndexYearMonthGO](index_year_month_go.md)
* [Detail: IndexDate](index_date.md)
* [Detail: IndexDateGO](index_date_go.md)
* [Detail: IndexMinute](index_minute.md)
* [Detail: IndexMinuteGO](index_minute_go.md)
* [Detail: IndexHour](index_hour.md)
* [Detail: IndexHourGO](index_hour_go.md)
* [Detail: IndexSecond](index_second.md)
* [Detail: IndexSecondGO](index_second_go.md)
* [Detail: IndexMillisecond](index_millisecond.md)
* [Detail: IndexMillisecondGO](index_millisecond_go.md)
* [Detail: IndexMicrosecond](index_microsecond.md)
* [Detail: IndexMicrosecondGO](index_microsecond_go.md)
* [Detail: IndexNanosecond](index_nanosecond.md)
* [Detail: IndexNanosecondGO](index_nanosecond_go.md)
* [Detail: HLoc](hloc.md)
* [Detail: ILoc](iloc.md)
* [Detail: TypeClinic](type_clinic.md)
* [Detail: CallGuard](call_guard.md)
* [Detail: ClinicResult](clinic_result.md)
* [Detail: Require](require.md)
* [Detail: WWW](www.md)
* [Detail: FillValueAuto](fill_value_auto.md)
* [Detail: DisplayActive](display_active.md)
* [Detail: DisplayConfig](display_config.md)
* [Detail: StoreConfig](store_config.md)
* [Detail: StoreFilter](store_filter.md)
* [Detail: IndexAutoFactory](index_auto_factory.md)
* [Detail: IndexDefaultConstructorFactory](index_default_constructor_factory.md)
* [Detail: IndexAutoConstructorFactory](index_auto_constructor_factory.md)
* [Detail: NPZ](npz.md)
* [Detail: NPY](npy.md)
* [Detail: MemoryDisplay](memory_display.md)
* [Detail: Platform](platform.md)

[StaticFrame](../index.md)

* Detail: Batch: Method
* [View page source](../_sources/api_detail/batch-method.rst.txt)

[Previous](batch-attribute.md "Detail: Batch: Attribute")
[Next](batch-dictionary_like.md "Detail: Batch: Dictionary-Like")

---

# Detail: Batch: Method[](#detail-batch-method "Link to this heading")

[Overview: Batch: Method](../api_overview/batch-method.md#api-overview-batch-method)

Batch.\_\_array\_\_(*dtype=None*)[](#static_frame.Batch.__array__ "Link to this definition")
:   Support the \_\_array\_\_ interface, returning an array of values.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> tuple(bt.__array__())
    (<Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>, <Frame: v>
    <Index>    a       b       <<U1>
    <Index>
    p          40      41
    q          42      43
    r          44      45
    <<U1>      <int64> <int64>)

    ```

Batch.\_\_array\_ufunc\_\_(*ufunc*, *method*, *\*args*, *\*\*kwargs*)[](#static_frame.Batch.__array_ufunc__ "Link to this definition")
:   Support for NumPy elements or arrays on the left hand of binary operators.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> (np.array((0.5, 0)) * bt).to_frame()
    <Frame>
    <Index>                a         b         <<U1>
    <IndexHierarchy>
    i                p     0.0       0.0
    i                q     1.0       0.0
    i                r     2.0       0.0
    j                p     20.0      0.0
    j                q     21.0      0.0
    j                r     22.0      0.0
    <<U1>            <<U1> <float64> <float64>

    ```

Batch.\_\_bool\_\_()[](#static_frame.Batch.__bool__ "Link to this definition")
:   Raises ValueError to prohibit ambiguous use of truthy evaluation.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bool(bt)
    ErrorNotTruthy('The truth value of a container is ambiguous. For a truthy indicator of non-empty status, use the `size` attribute.')

    ```

Batch.\_\_round\_\_(*decimals=0*, */*)[[source]](../_modules/static_frame/core/batch.md#Batch.__round__)[](#static_frame.Batch.__round__ "Link to this definition")
:   Return a [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") rounded to the given decimals. Negative decimals round to the left of the decimal point.

    Parameters:
    :   **decimals** – number of decimals to round to.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), ('j', sf.Frame(np.arange(100, 106).reshape(3,2) / 3, index=('p', 'q', 'r'), columns=('a', 'b'), name='x'))))
    >>> round(bt, 2).to_frame()
    <Frame>
    <Index>                a         b         <<U1>
    <IndexHierarchy>
    i                p     40.0      41.0
    i                q     42.0      43.0
    i                r     44.0      45.0
    j                p     33.33     33.67
    j                q     34.0      34.33
    j                r     34.67     35.0
    <<U1>            <<U1> <float64> <float64>

    ```

Batch.all(*\**, *axis=0*, *skipna=True*, *out=None*)[](#static_frame.Batch.all "Link to this definition")
:   Logical `and` over values along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> bt = sf.Batch((('i', sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), ('j', sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w'))))
    >>> bt.all().to_frame()
    <Frame>
    <Index> c      d      <<U1>
    <Index>
    i       False  True
    j       False  False
    <<U1>   <bool> <bool>

    ```

Batch.any(*\**, *axis=0*, *skipna=True*, *out=None*)[](#static_frame.Batch.any "Link to this definition")
:   Logical `or` over values along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> bt = sf.Batch((('i', sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), ('j', sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w'))))
    >>> bt.any().to_frame()
    <Frame>
    <Index> c      d      <<U1>
    <Index>
    i       False  True
    j       True   True
    <<U1>   <bool> <bool>

    ```

Batch.apply(*func*, */*)[[source]](../_modules/static_frame/core/batch.md#Batch.apply)[](#static_frame.Batch.apply "Link to this definition")
:   Apply a function to each [`Frame`](frame-selector.md#Frame "Frame") contained in this [`Frame`](frame-selector.md#Frame "Frame"), where a function is given the [`Frame`](frame-selector.md#Frame "Frame") as an argument.

    ```
    >>> bt = sf.Batch((('i', sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), ('j', sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w'))))
    >>> bt.apply(lambda f: f.iter_element().apply(lambda e: '+' if e else '-')).to_frame()
    <Frame>
    <Index>                c     d     <<U1>
    <IndexHierarchy>
    i                p     -     +
    i                q     -     +
    i                r     -     +
    j                p     -     +
    j                q     +     -
    j                r     +     +
    <<U1>            <<U1> <<U1> <<U1>

    ```

Batch.apply\_except(*func*, *exception*, */*)[[source]](../_modules/static_frame/core/batch.md#Batch.apply_except)[](#static_frame.Batch.apply_except "Link to this definition")
:   Apply a function to each [`Frame`](frame-selector.md#Frame "Frame") contained in this [`Frame`](frame-selector.md#Frame "Frame"), where a function is given the [`Frame`](frame-selector.md#Frame "Frame") as an argument. Exceptions raised that matching the except argument will be silenced.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt.apply_except(lambda f: f + 100, Exception).to_frame()
    <Frame>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    i                p     100     101
    i                q     102     103
    i                r     104     105
    <<U1>            <<U1> <int64> <int64>

    ```

Batch.apply\_items(*func*, */*)[[source]](../_modules/static_frame/core/batch.md#Batch.apply_items)[](#static_frame.Batch.apply_items "Link to this definition")
:   Apply a function to each [`Frame`](frame-selector.md#Frame "Frame") contained in this [`Frame`](frame-selector.md#Frame "Frame"), where a function is given the pair of label, [`Frame`](frame-selector.md#Frame "Frame") as an argument.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.apply_items(lambda l, f: f * 100 if l == 'j' else f * 0.001).to_frame()
    <Frame>
    <Index>                a         b         <<U1>
    <IndexHierarchy>
    i                p     0.0       0.001
    i                q     0.002     0.003
    i                r     0.004     0.005
    j                p     4000.0    4100.0
    j                q     4200.0    4300.0
    j                r     4400.0    4500.0
    <<U1>            <<U1> <float64> <float64>

    ```

Batch.apply\_items\_except(*func*, */*, *\**, *exception*)[[source]](../_modules/static_frame/core/batch.md#Batch.apply_items_except)[](#static_frame.Batch.apply_items_except "Link to this definition")
:   Apply a function to each [`Frame`](frame-selector.md#Frame "Frame") contained in this [`Frame`](frame-selector.md#Frame "Frame"), where a function is given the pair of label, [`Frame`](frame-selector.md#Frame "Frame") as an argument. Exceptions raised that matching the except argument will be silenced.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt.apply_items_except(lambda l, f: f * 100 if l == 'j' else f * 0.001, exception=Exception).to_frame()
    <Frame>
    <Index>                a         b         <<U1>
    <IndexHierarchy>
    i                p     0.0       0.001
    i                q     0.002     0.003
    i                r     0.004     0.005
    <<U1>            <<U1> <float64> <float64>

    ```

Batch.astype[*key*](*dtypes*, *\**, *consolidate\_blocks*)
:   astype
    :   Return a new Batch with astype transformed.

    InterfaceBatchAsType.\_\_getitem\_\_(*key*)[[source]](../_modules/static_frame/core/node_selector.md#InterfaceBatchAsType.__getitem__)
    :   Selector of columns by label.

        Parameters:
        :   **key** – A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.astype['a'](str).to_frame()
    <Frame>
    <Index>                a      b       <<U1>
    <IndexHierarchy>
    i                p     0      1
    i                q     2      3
    i                r     4      5
    j                p     40     41
    j                q     42     43
    j                r     44     45
    <<U1>            <<U1> <<U21> <int64>

    ```

Batch.astype(*dtype*)
:   astype
    :   Return a new Batch with astype transformed.

    InterfaceBatchAsType.\_\_call\_\_(*dtype*, */*)[[source]](../_modules/static_frame/core/node_selector.md#InterfaceBatchAsType.__call__)
    :   Apply a single `dtype` to all columns.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.astype(str).to_frame()
    <Frame>
    <Index>                a      b      <<U1>
    <IndexHierarchy>
    i                p     0      1
    i                q     2      3
    i                r     4      5
    j                p     40     41
    j                q     42     43
    j                r     44     45
    <<U1>            <<U1> <<U21> <<U21>

    ```

Batch.clip(*\**, *lower=None*, *upper=None*, *axis=None*)[[source]](../_modules/static_frame/core/batch.md#Batch.clip)[](#static_frame.Batch.clip "Link to this definition")
:   Apply a clip operation to this [`Batch`](batch-selector.md#Batch "Batch"). Note that clip operations can be applied to object types, but cannot be applied to non-numerical objects (e.g., strings, None)

    Parameters:
    :   * **lower** – value, [`Series`](series-selector.md#Series "Series"), [`Frame`](frame-selector.md#Frame "Frame")
        * **upper** – value, [`Series`](series-selector.md#Series "Series"), [`Frame`](frame-selector.md#Frame "Frame")
        * **axis** – required if `lower` or `upper` are given as a [`Series`](series-selector.md#Series "Series").

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.clip(lower=3, upper=41).to_frame()
    <Frame>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    i                p     3       3
    i                q     3       3
    i                r     4       5
    j                p     40      41
    j                q     41      41
    j                r     41      41
    <<U1>            <<U1> <int64> <int64>

    ```

Batch.corr(*\**, *axis=1*)[[source]](../_modules/static_frame/core/batch.md#Batch.corr)[](#static_frame.Batch.corr "Link to this definition")
:   Compute a correlation matrix.

    Parameters:
    :   **axis** – if 0, each row represents a variable, with observations as columns; if 1, each column represents a variable, with observations as rows. Defaults to 1.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), ('j', sf.Frame(np.arange(100, 106).reshape(3,2) / 3, index=('p', 'q', 'r'), columns=('a', 'b'), name='x'))))
    >>> bt.corr().to_frame()
    <Frame>
    <Index>                a         b         <<U1>
    <IndexHierarchy>
    i                a     1.0       1.0
    i                b     1.0       1.0
    j                a     1.0       1.0
    j                b     1.0       1.0
    <<U1>            <<U1> <float64> <float64>

    ```

Batch.count(*\**, *skipna=True*, *skipfalsy=False*, *unique=False*, *axis=0*)[[source]](../_modules/static_frame/core/batch.md#Batch.count)[](#static_frame.Batch.count "Link to this definition")
:   Apply count on contained Frames.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.count(skipna=True).to_frame()
    <Frame>
    <Index> a       b       <<U1>
    <Index>
    i       3       3
    j       3       3
    <<U1>   <int64> <int64>
    >>> bt.count(unique=True).to_frame()
    <Frame>
    <Index> a       b       <<U1>
    <Index>
    i       3       3
    j       3       3
    <<U1>   <int64> <int64>

    ```

Batch.cov(*\**, *axis=1*, *ddof=1*)[[source]](../_modules/static_frame/core/batch.md#Batch.cov)[](#static_frame.Batch.cov "Link to this definition")
:   Compute a covariance matrix.

    Parameters:
    :   * **axis** – if 0, each row represents a variable, with observations as columns; if 1, each column represents a variable, with observations as rows. Defaults to 1.
        * **ddof** – Delta degrees of freedom, defaults to 1.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), ('j', sf.Frame(np.arange(100, 106).reshape(3,2) / 3, index=('p', 'q', 'r'), columns=('a', 'b'), name='x'))))
    >>> bt.cov().to_frame()
    <Frame>
    <Index>                a                   b                   <<U1>
    <IndexHierarchy>
    i                a     4.0                 4.0
    i                b     4.0                 4.0
    j                a     0.4444444444444413  0.44444444444444364
    j                b     0.44444444444444364 0.44444444444444603
    <<U1>            <<U1> <float64>           <float64>

    ```

Batch.cumprod(*\**, *axis=0*, *skipna=True*)[](#static_frame.Batch.cumprod "Link to this definition")
:   Return the cumulative product over the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), ('j', sf.Frame(np.arange(100, 106).reshape(3,2) / 3, index=('p', 'q', 'r'), columns=('a', 'b'), name='x'))))
    >>> bt.cumprod().to_frame()
    <Frame>
    <Index>                a                  b                  <<U1>
    <IndexHierarchy>
    i                p     40.0               41.0
    i                q     1680.0             1763.0
    i                r     73920.0            79335.0
    j                p     33.333333333333336 33.666666666666664
    j                q     1133.3333333333335 1155.888888888889
    j                r     39288.88888888889  40456.11111111111
    <<U1>            <<U1> <float64>          <float64>

    ```

Batch.cumsum(*\**, *axis=0*, *skipna=True*)[](#static_frame.Batch.cumsum "Link to this definition")
:   Return the cumulative sum over the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), ('j', sf.Frame(np.arange(100, 106).reshape(3,2) / 3, index=('p', 'q', 'r'), columns=('a', 'b'), name='x'))))
    >>> bt.cumsum().to_frame()
    <Frame>
    <Index>                a                  b                  <<U1>
    <IndexHierarchy>
    i                p     40.0               41.0
    i                q     82.0               84.0
    i                r     126.0              129.0
    j                p     33.333333333333336 33.666666666666664
    j                q     67.33333333333334  68.0
    j                r     102.0              103.0
    <<U1>            <<U1> <float64>          <float64>

    ```

Batch.drop\_duplicated(*\**, *axis=0*, *exclude\_first=False*, *exclude\_last=False*)[[source]](../_modules/static_frame/core/batch.md#Batch.drop_duplicated)[](#static_frame.Batch.drop_duplicated "Link to this definition")
:   Return a [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") with duplicated rows (axis 0) or columns (axis 1) removed. All values in the row or column are compared to determine duplication.

    Parameters:
    :   * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
        * **exclude\_first** – Boolean to select if the first duplicated value is excluded.
        * **exclude\_last** – Boolean to select if the last duplicated value is excluded.

    ```
    >>> bt = sf.Batch((('i', sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), ('j', sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w'))))
    >>> bt.drop_duplicated().to_frame()
    <Frame>
    <Index>                c      d      <<U1>
    <IndexHierarchy>
    j                p     False  True
    j                q     True   False
    j                r     True   True
    <<U1>            <<U1> <bool> <bool>

    ```

Batch.dropfalsy(*\**, *axis=0*, *condition=<function all>*)[[source]](../_modules/static_frame/core/batch.md#Batch.dropfalsy)[](#static_frame.Batch.dropfalsy "Link to this definition")
:   Return a [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") after removing rows (axis 0) or columns (axis 1) where any or all values are NA (NaN or None). The condition is determined by a NumPy ufunc that process the Boolean array returned by `isna()`; the default is `np.all`.

    Parameters:
    :   * **axis** –
        * **condition** –

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt.dropfalsy(condition=np.any, axis=0).to_frame()
    <Frame>
    <Index>                   a         b        c          <<U1>
    <IndexHierarchy>
    i                q        2.0       3        nan
    i                r        4.0       5        nan
    j                0        10.0      qrs      1517-01-01
    j                1        2.0       XYZ      1517-04-01
    j                3        2.0       123      1517-04-01
    <<U1>            <object> <float64> <object> <object>

    ```

Batch.dropna(*\**, *axis=0*, *condition=<function all>*)[[source]](../_modules/static_frame/core/batch.md#Batch.dropna)[](#static_frame.Batch.dropna "Link to this definition")
:   Return a [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") after removing rows (axis 0) or columns (axis 1) where any or all values are NA (NaN or None). The condition is determined by a NumPy ufunc that process the Boolean array returned by `isna()`; the default is `np.all`.

    Parameters:
    :   * **axis** –
        * **condition** –

    ```
    >>> bt = sf.Batch((('i', sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), ('j', sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w'))))
    >>> bt.dropna().to_frame()
    <Frame>
    <Index>                c      d      <<U1>
    <IndexHierarchy>
    i                p     False  True
    i                q     False  True
    i                r     False  True
    j                p     False  True
    j                q     True   False
    j                r     True   True
    <<U1>            <<U1> <bool> <bool>

    ```

Batch.duplicated(*\**, *axis=0*, *exclude\_first=False*, *exclude\_last=False*)[[source]](../_modules/static_frame/core/batch.md#Batch.duplicated)[](#static_frame.Batch.duplicated "Link to this definition")
:   Return an axis-sized Boolean [`Series`](series-selector.md#Series "Series") that shows True for all rows (axis 0) or columns (axis 1) duplicated.

    Parameters:
    :   * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
        * **exclude\_first** – Boolean to select if the first duplicated value is excluded.
        * **exclude\_last** – Boolean to select if the last duplicated value is excluded.

    ```
    >>> bt = sf.Batch((('i', sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), ('j', sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w'))))
    >>> bt.duplicated().to_frame()
    <Frame>
    <Index> p      q      r      <<U1>
    <Index>
    i       True   True   True
    j       False  False  False
    <<U1>   <bool> <bool> <bool>

    ```

Batch.equals(*other*, */*, *\**, *compare\_name=False*, *compare\_dtype=False*, *compare\_class=False*, *skipna=True*)[](#static_frame.Batch.equals "Link to this definition")
:   ```
    >>> bt1 = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt2 = sf.Batch((('i', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v')), ('j', sf.Frame(np.arange(100, 106).reshape(3,2) / 3, index=('p', 'q', 'r'), columns=('a', 'b'), name='x'))))
    >>> bt1.equals(bt2)
    NotImplementedError()

    ```

Batch.fillfalsy(*value*, */*)[[source]](../_modules/static_frame/core/batch.md#Batch.fillfalsy)[](#static_frame.Batch.fillfalsy "Link to this definition")
:   Return a new [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") after filling falsy values with the provided `value`.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt.fillfalsy([-1, '', np.nan]).to_frame()
    <Frame>
    <Index>                   a         b        c          <<U1>
    <IndexHierarchy>
    i                p        -1.0      1        nan
    i                q        2.0       3        nan
    i                r        4.0       5        nan
    j                0        10.0      qrs      1517-01-01
    j                1        2.0       XYZ      1517-04-01
    j                2        -1.0               nan
    j                3        2.0       123      1517-04-01
    <<U1>            <object> <float64> <object> <object>

    ```

Batch.fillfalsy\_backward(*limit=0*, */*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/batch.md#Batch.fillfalsy_backward)[](#static_frame.Batch.fillfalsy_backward "Link to this definition")
:   Return a new [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") after filling backward falsy values with the first observed value.

    Parameters:
    :   * **{limit}** –
        * **{axis}** –

    ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y'))))
    >>> bt.fillfalsy_backward().to_frame()
    <Frame>
    <Index>                  a         b         c         <<U1>
    <IndexHierarchy>
    i                0       10.0      8.0       1.0
    i                1       2.0       3.0       nan
    i                2       nan       8.0       nan
    i                3       nan       nan       nan
    j                0       10.0      8.0       1.0
    j                1       10.0      8.0       1.0
    j                2       10.0      3.0       1.0
    j                3       2.0       8.0       1.0
    <<U1>            <int64> <float64> <float64> <float64>

    ```

Batch.fillfalsy\_forward(*limit=0*, */*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/batch.md#Batch.fillfalsy_forward)[](#static_frame.Batch.fillfalsy_forward "Link to this definition")
:   Return a new [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") after filling forward falsy values with the last observed value.

    Parameters:
    :   * **{limit}** –
        * **{axis}** –

    ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y'))))
    >>> bt.fillfalsy_forward().to_frame()
    <Frame>
    <Index>                  a         b         c         <<U1>
    <IndexHierarchy>
    i                0       10.0      8.0       1.0
    i                1       2.0       3.0       1.0
    i                2       2.0       8.0       1.0
    i                3       2.0       8.0       1.0
    j                0       nan       nan       nan
    j                1       nan       8.0       nan
    j                2       10.0      3.0       nan
    j                3       2.0       8.0       1.0
    <<U1>            <int64> <float64> <float64> <float64>

    ```

Batch.fillfalsy\_leading(*value*, */*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/batch.md#Batch.fillfalsy_leading)[](#static_frame.Batch.fillfalsy_leading "Link to this definition")
:   Return a new [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") after filling leading (and only leading) falsy values with the provided `value`.

    Parameters:
    :   * **{value}** –
        * **{axis}** –

    ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y'))))
    >>> bt.fillfalsy_leading(-1).to_frame()
    <Frame>
    <Index>                  a         b         c         <<U1>
    <IndexHierarchy>
    i                0       10.0      8.0       1.0
    i                1       2.0       3.0       nan
    i                2       nan       8.0       nan
    i                3       nan       nan       nan
    j                0       -1.0      -1.0      -1.0
    j                1       -1.0      8.0       -1.0
    j                2       10.0      3.0       -1.0
    j                3       2.0       8.0       1.0
    <<U1>            <int64> <float64> <float64> <float64>

    ```

Batch.fillfalsy\_trailing(*value*, */*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/batch.md#Batch.fillfalsy_trailing)[](#static_frame.Batch.fillfalsy_trailing "Link to this definition")
:   Return a new [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") after filling trailing (and only trailing) falsy values with the provided `value`.

    Parameters:
    :   * **{value}** –
        * **{axis}** –

    ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y'))))
    >>> bt.fillfalsy_trailing(-1).to_frame()
    <Frame>
    <Index>                  a         b         c         <<U1>
    <IndexHierarchy>
    i                0       10.0      8.0       1.0
    i                1       2.0       3.0       -1.0
    i                2       -1.0      8.0       -1.0
    i                3       -1.0      -1.0      -1.0
    j                0       nan       nan       nan
    j                1       nan       8.0       nan
    j                2       10.0      3.0       nan
    j                3       2.0       8.0       1.0
    <<U1>            <int64> <float64> <float64> <float64>

    ```

Batch.fillna(*value*, */*)[[source]](../_modules/static_frame/core/batch.md#Batch.fillna)[](#static_frame.Batch.fillna "Link to this definition")
:   Return a new [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") after filling null (NaN or None) with the provided `value`.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt.fillna(-1).to_frame()
    <Frame>
    <Index>                   a         b        c          <<U1>
    <IndexHierarchy>
    i                p        0.0       1        nan
    i                q        2.0       3        nan
    i                r        4.0       5        nan
    j                0        10.0      qrs      1517-01-01
    j                1        2.0       XYZ      1517-04-01
    j                2        -1.0               -1
    j                3        2.0       123      1517-04-01
    <<U1>            <object> <float64> <object> <object>

    ```

Batch.fillna\_backward(*limit=0*, */*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/batch.md#Batch.fillna_backward)[](#static_frame.Batch.fillna_backward "Link to this definition")
:   Return a new [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") after filling backward null (NaN or None) with the first observed value.

    Parameters:
    :   * **{limit}** –
        * **{axis}** –

    ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y'))))
    >>> bt.fillna_backward().to_frame()
    <Frame>
    <Index>                  a         b         c         <<U1>
    <IndexHierarchy>
    i                0       10.0      8.0       1.0
    i                1       2.0       3.0       nan
    i                2       nan       8.0       nan
    i                3       nan       nan       nan
    j                0       10.0      8.0       1.0
    j                1       10.0      8.0       1.0
    j                2       10.0      3.0       1.0
    j                3       2.0       8.0       1.0
    <<U1>            <int64> <float64> <float64> <float64>

    ```

Batch.fillna\_forward(*limit=0*, */*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/batch.md#Batch.fillna_forward)[](#static_frame.Batch.fillna_forward "Link to this definition")
:   Return a new [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") after filling forward null (NaN or None) with the last observed value.

    Parameters:
    :   * **{limit}** –
        * **{axis}** –

    ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y'))))
    >>> bt.fillna_forward().to_frame()
    <Frame>
    <Index>                  a         b         c         <<U1>
    <IndexHierarchy>
    i                0       10.0      8.0       1.0
    i                1       2.0       3.0       1.0
    i                2       2.0       8.0       1.0
    i                3       2.0       8.0       1.0
    j                0       nan       nan       nan
    j                1       nan       8.0       nan
    j                2       10.0      3.0       nan
    j                3       2.0       8.0       1.0
    <<U1>            <int64> <float64> <float64> <float64>

    ```

Batch.fillna\_leading(*value*, */*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/batch.md#Batch.fillna_leading)[](#static_frame.Batch.fillna_leading "Link to this definition")
:   Return a new [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") after filling leading (and only leading) null (NaN or None) with the provided `value`.

    Parameters:
    :   * **{value}** –
        * **{axis}** –

    ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y'))))
    >>> bt.fillna_leading(-1).to_frame()
    <Frame>
    <Index>                  a         b         c         <<U1>
    <IndexHierarchy>
    i                0       10.0      8.0       1.0
    i                1       2.0       3.0       nan
    i                2       nan       8.0       nan
    i                3       nan       nan       nan
    j                0       -1.0      -1.0      -1.0
    j                1       -1.0      8.0       -1.0
    j                2       10.0      3.0       -1.0
    j                3       2.0       8.0       1.0
    <<U1>            <int64> <float64> <float64> <float64>

    ```

Batch.fillna\_trailing(*value*, */*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/batch.md#Batch.fillna_trailing)[](#static_frame.Batch.fillna_trailing "Link to this definition")
:   Return a new [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") after filling trailing (and only trailing) null (NaN or None) with the provided `value`.

    Parameters:
    :   * **{value}** –
        * **{axis}** –

    ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y'))))
    >>> bt.fillna_trailing(-1).to_frame()
    <Frame>
    <Index>                  a         b         c         <<U1>
    <IndexHierarchy>
    i                0       10.0      8.0       1.0
    i                1       2.0       3.0       -1.0
    i                2       -1.0      8.0       -1.0
    i                3       -1.0      -1.0      -1.0
    j                0       nan       nan       nan
    j                1       nan       8.0       nan
    j                2       10.0      3.0       nan
    j                3       2.0       8.0       1.0
    <<U1>            <int64> <float64> <float64> <float64>

    ```

Batch.head(*count=5*, */*)[[source]](../_modules/static_frame/core/batch.md#Batch.head)[](#static_frame.Batch.head "Link to this definition")
:   Return a [`Batch`](batch-selector.md#Batch "Batch") consisting only of the top elements as specified by `count`.

    Parameters:
    :   **count** – Number of elements to be returned from the top of the [`Batch`](batch-selector.md#Batch "Batch")

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.head(2).to_frame()
    <Frame>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    i                p     0       1
    i                q     2       3
    j                p     40      41
    j                q     42      43
    <<U1>            <<U1> <int64> <int64>

    ```

Batch.iloc\_max(*\**, *skipna=True*, *axis=0*)[[source]](../_modules/static_frame/core/batch.md#Batch.iloc_max)[](#static_frame.Batch.iloc_max "Link to this definition")
:   Return the integer indices corresponding to the maximum values found.

    Parameters:
    :   * **skipna** – if True, NaN or None values will be ignored; if False, a found NaN will propagate.
        * **axis** – Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).

    ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y'))))
    >>> bt.iloc_max().to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    i       0       0       0
    j       2       1       3
    <<U1>   <int64> <int64> <int64>

    ```

Batch.iloc\_min(*\**, *skipna=True*, *axis=0*)[[source]](../_modules/static_frame/core/batch.md#Batch.iloc_min)[](#static_frame.Batch.iloc_min "Link to this definition")
:   Return the integer indices corresponding to the minimum values found.

    Parameters:
    :   * **skipna** – if True, NaN or None values will be ignored; if False, a found NaN will propagate.
        * **axis** – Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).

    ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y'))))
    >>> bt.iloc_min().to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    i       1       1       0
    j       3       2       3
    <<U1>   <int64> <int64> <int64>

    ```

Batch.isfalsy()[[source]](../_modules/static_frame/core/batch.md#Batch.isfalsy)[](#static_frame.Batch.isfalsy "Link to this definition")
:   Return a [`Batch`](batch-selector.md#Batch "Batch") with contained, same-indexed [`Frame`](frame-selector.md#Frame "Frame") indicating True which values are Falsy.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt.isfalsy().to_frame(fill_value=False)
    <Frame>
    <Index>                   a      b      c      <<U1>
    <IndexHierarchy>
    i                p        True   False  False
    i                q        False  False  False
    i                r        False  False  False
    j                0        False  False  False
    j                1        False  False  False
    j                2        True   True   True
    j                3        False  False  False
    <<U1>            <object> <bool> <bool> <bool>

    ```

Batch.isin(*other*, */*)[[source]](../_modules/static_frame/core/batch.md#Batch.isin)[](#static_frame.Batch.isin "Link to this definition")
:   Return a new [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") as a same-sized Boolean [`Frame`](frame-selector.md#Frame "Frame") that shows if the same-positioned element is in the passed iterable.

    ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y'))))
    >>> bt.isin((3, 10)).to_frame()
    <Frame>
    <Index>                  a      b      c      <<U1>
    <IndexHierarchy>
    i                0       True   False  False
    i                1       False  True   False
    i                2       False  False  False
    i                3       False  False  False
    j                0       False  False  False
    j                1       False  False  False
    j                2       True   True   False
    j                3       False  False  False
    <<U1>            <int64> <bool> <bool> <bool>

    ```

Batch.isna()[[source]](../_modules/static_frame/core/batch.md#Batch.isna)[](#static_frame.Batch.isna "Link to this definition")
:   Return a [`Batch`](batch-selector.md#Batch "Batch") with contained, same-indexed [`Frame`](frame-selector.md#Frame "Frame") indicating True which values are NaN or None.

    ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y'))))
    >>> bt.isna().to_frame()
    <Frame>
    <Index>                  a      b      c      <<U1>
    <IndexHierarchy>
    i                0       False  False  False
    i                1       False  False  True
    i                2       True   False  True
    i                3       True   True   True
    j                0       True   True   True
    j                1       True   False  True
    j                2       False  False  True
    j                3       False  False  False
    <<U1>            <int64> <bool> <bool> <bool>

    ```

Batch.loc\_max(*\**, *skipna=True*, *axis=0*)[[source]](../_modules/static_frame/core/batch.md#Batch.loc_max)[](#static_frame.Batch.loc_max "Link to this definition")
:   Return the labels corresponding to the maximum values found.

    Parameters:
    :   * **skipna** – if True, NaN or None values will be ignored; if False, a found NaN will propagate.
        * **axis** – Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).

    ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y'))))
    >>> bt.loc_max().to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    i       0       0       0
    j       2       1       3
    <<U1>   <int64> <int64> <int64>

    ```

Batch.loc\_min(*\**, *skipna=True*, *axis=0*)[[source]](../_modules/static_frame/core/batch.md#Batch.loc_min)[](#static_frame.Batch.loc_min "Link to this definition")
:   Return the labels corresponding to the minimum value found.

    Parameters:
    :   * **skipna** – if True, NaN or None values will be ignored; if False, a found NaN will propagate.
        * **axis** – Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).

    ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y'))))
    >>> bt.loc_min().to_frame()
    <Frame>
    <Index> a       b       c       <<U1>
    <Index>
    i       1       1       0
    j       3       2       3
    <<U1>   <int64> <int64> <int64>

    ```

Batch.max(*\**, *axis=0*, *skipna=True*, *out=None*)[](#static_frame.Batch.max "Link to this definition")
:   Return the maximum along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.max().to_frame()
    <Frame>
    <Index> a       b       <<U1>
    <Index>
    i       4       5
    j       44      45
    <<U1>   <int64> <int64>

    ```

Batch.mean(*\**, *axis=0*, *skipna=True*, *out=None*)[](#static_frame.Batch.mean "Link to this definition")
:   Return the mean along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.mean().to_frame()
    <Frame>
    <Index> a         b         <<U1>
    <Index>
    i       2.0       3.0
    j       42.0      43.0
    <<U1>   <float64> <float64>

    ```

Batch.median(*\**, *axis=0*, *skipna=True*, *out=None*)[](#static_frame.Batch.median "Link to this definition")
:   Return the median along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.median().to_frame()
    <Frame>
    <Index> a         b         <<U1>
    <Index>
    i       2.0       3.0
    j       42.0      43.0
    <<U1>   <float64> <float64>

    ```

Batch.min(*\**, *axis=0*, *skipna=True*, *out=None*)[](#static_frame.Batch.min "Link to this definition")
:   Return the minimum along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.min().to_frame()
    <Frame>
    <Index> a       b       <<U1>
    <Index>
    i       0       1
    j       40      41
    <<U1>   <int64> <int64>

    ```

Batch.notfalsy()[[source]](../_modules/static_frame/core/batch.md#Batch.notfalsy)[](#static_frame.Batch.notfalsy "Link to this definition")
:   Return a [`Batch`](batch-selector.md#Batch "Batch") with contained, same-indexed [`Frame`](frame-selector.md#Frame "Frame") indicating True which values are not Falsy.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt.notfalsy().to_frame(fill_value=False)
    <Frame>
    <Index>                   a      b      c      <<U1>
    <IndexHierarchy>
    i                p        False  True   False
    i                q        True   True   False
    i                r        True   True   False
    j                0        True   True   True
    j                1        True   True   True
    j                2        False  False  False
    j                3        True   True   True
    <<U1>            <object> <bool> <bool> <bool>

    ```

Batch.notna()[[source]](../_modules/static_frame/core/batch.md#Batch.notna)[](#static_frame.Batch.notna "Link to this definition")
:   Return a [`Batch`](batch-selector.md#Batch "Batch") with contained, same-indexed [`Frame`](frame-selector.md#Frame "Frame") indicating True which values are not NaN or None.

    ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y'))))
    >>> bt.notna().to_frame()
    <Frame>
    <Index>                  a      b      c      <<U1>
    <IndexHierarchy>
    i                0       True   True   True
    i                1       True   True   False
    i                2       False  True   False
    i                3       False  False  False
    j                0       False  False  False
    j                1       False  True   False
    j                2       True   True   False
    j                3       True   True   True
    <<U1>            <int64> <bool> <bool> <bool>

    ```

Batch.prod(*\**, *axis=0*, *skipna=True*, *allna=1*, *out=None*)[](#static_frame.Batch.prod "Link to this definition")
:   Return the product along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.prod().to_frame()
    <Frame>
    <Index> a       b       <<U1>
    <Index>
    i       0       15
    j       73920   79335
    <<U1>   <int64> <int64>

    ```

Batch.rank\_dense(*\**, *axis=0*, *skipna=True*, *ascending=True*, *start=0*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/batch.md#Batch.rank_dense)[](#static_frame.Batch.rank_dense "Link to this definition")
:   ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((0, 0, 10, 2), (20, 18, -3, 18), (0, 0, 0, 1)), columns=('a', 'b', 'c'), name='x'))))
    >>> bt.rank_dense().to_frame()
    <Frame>
    <Index>                  a       b       c       <<U1>
    <IndexHierarchy>
    i                0       3       0       0
    i                1       1       2       1
    i                2       2       1       0
    i                3       0       2       1
    j                0       0       2       0
    j                1       0       1       0
    j                2       2       0       0
    j                3       1       1       1
    <<U1>            <int64> <int64> <int64> <int64>

    ```

Batch.rank\_max(*\**, *axis=0*, *skipna=True*, *ascending=True*, *start=0*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/batch.md#Batch.rank_max)[](#static_frame.Batch.rank_max "Link to this definition")
:   ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((0, 0, 10, 2), (20, 18, -3, 18), (0, 0, 0, 1)), columns=('a', 'b', 'c'), name='x'))))
    >>> bt.rank_max().to_frame()
    <Frame>
    <Index>                  a       b       c       <<U1>
    <IndexHierarchy>
    i                0       3       0       1
    i                1       1       3       3
    i                2       2       1       1
    i                3       0       3       3
    j                0       1       3       2
    j                1       1       2       2
    j                2       3       0       2
    j                3       2       2       3
    <<U1>            <int64> <int64> <int64> <int64>

    ```

Batch.rank\_mean(*\**, *axis=0*, *skipna=True*, *ascending=True*, *start=0*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/batch.md#Batch.rank_mean)[](#static_frame.Batch.rank_mean "Link to this definition")
:   ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((0, 0, 10, 2), (20, 18, -3, 18), (0, 0, 0, 1)), columns=('a', 'b', 'c'), name='x'))))
    >>> bt.rank_mean().to_frame()
    <Frame>
    <Index>                  a         b         c         <<U1>
    <IndexHierarchy>
    i                0       3.0       0.0       0.5
    i                1       1.0       2.5       2.5
    i                2       2.0       1.0       0.5
    i                3       0.0       2.5       2.5
    j                0       0.5       3.0       1.0
    j                1       0.5       1.5       1.0
    j                2       3.0       0.0       1.0
    j                3       2.0       1.5       3.0
    <<U1>            <int64> <float64> <float64> <float64>

    ```

Batch.rank\_min(*\**, *axis=0*, *skipna=True*, *ascending=True*, *start=0*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/batch.md#Batch.rank_min)[](#static_frame.Batch.rank_min "Link to this definition")
:   ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((0, 0, 10, 2), (20, 18, -3, 18), (0, 0, 0, 1)), columns=('a', 'b', 'c'), name='x'))))
    >>> bt.rank_min().to_frame()
    <Frame>
    <Index>                  a       b       c       <<U1>
    <IndexHierarchy>
    i                0       3       0       0
    i                1       1       2       2
    i                2       2       1       0
    i                3       0       2       2
    j                0       0       3       0
    j                1       0       1       0
    j                2       3       0       0
    j                3       2       1       3
    <<U1>            <int64> <int64> <int64> <int64>

    ```

Batch.rank\_ordinal(*\**, *axis=0*, *skipna=True*, *ascending=True*, *start=0*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/batch.md#Batch.rank_ordinal)[](#static_frame.Batch.rank_ordinal "Link to this definition")
:   ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')), ('j', sf.Frame.from_fields(((0, 0, 10, 2), (20, 18, -3, 18), (0, 0, 0, 1)), columns=('a', 'b', 'c'), name='x'))))
    >>> bt.rank_ordinal().to_frame()
    <Frame>
    <Index>                  a       b       c       <<U1>
    <IndexHierarchy>
    i                0       3       0       0
    i                1       1       2       2
    i                2       2       1       1
    i                3       0       3       3
    j                0       0       3       0
    j                1       1       1       1
    j                2       3       0       2
    j                3       2       2       3
    <<U1>            <int64> <int64> <int64> <int64>

    ```

Batch.reindex(*index=None*, *columns=None*, *\**, *fill\_value=nan*, *own\_index=False*, *own\_columns=False*, *check\_equals=True*)[[source]](../_modules/static_frame/core/batch.md#Batch.reindex)[](#static_frame.Batch.reindex "Link to this definition")
:   ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.reindex(('q', 'p', 'a'), fill_value=sf.FillValueAuto).to_frame()
    <Frame>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    i                q     2       3
    i                p     0       1
    i                a     0       0
    j                q     42      43
    j                p     40      41
    j                a     0       0
    <<U1>            <<U1> <int64> <int64>

    ```

Batch.relabel(*index=None*, *columns=None*, *\**, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/batch.md#Batch.relabel)[](#static_frame.Batch.relabel "Link to this definition")
:   ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt.relabel({'q':'x', 'p':'y', 0:'x', 1:'y'}).to_frame()
    <Frame>
    <Index>                   a         b        c          <<U1>
    <IndexHierarchy>
    i                y        0.0       1        nan
    i                x        2.0       3        nan
    i                r        4.0       5        nan
    j                x        10.0      qrs      1517-01-01
    j                y        2.0       XYZ      1517-04-01
    j                2        nan                None
    j                3        2.0       123      1517-04-01
    <<U1>            <object> <float64> <object> <object>
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt.relabel(lambda l: f'+{str(l).upper()}+').to_frame()
    <Frame>
    <Index>                a         b        c          <<U1>
    <IndexHierarchy>
    i                +P+   0.0       1        nan
    i                +Q+   2.0       3        nan
    i                +R+   4.0       5        nan
    j                +0+   10.0      qrs      1517-01-01
    j                +1+   2.0       XYZ      1517-04-01
    j                +2+   nan                None
    j                +3+   2.0       123      1517-04-01
    <<U1>            <<U3> <float64> <object> <object>

    ```

Batch.relabel\_flat(*index=False*, *columns=False*)[[source]](../_modules/static_frame/core/batch.md#Batch.relabel_flat)[](#static_frame.Batch.relabel_flat "Link to this definition")
:   ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')), ('j', sf.Frame.from_fields(((23, 83, 19, 87), (True, True, False, False), ('2022-01-01', '2023-04-01', '2022-12-31', '2024-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt.relabel_flat(index=True).to_frame()
    <Frame>
    <Index>                               a       b      c               <<U1>
    <IndexHierarchy>
    i                (np.int64(0), np.... 10      False  1517-01-01
    i                (np.int64(0), np.... 2       True   1517-04-01
    i                (np.int64(1), np.... 8       True   1517-12-31
    i                (np.int64(1), np.... 3       False  1517-06-30
    j                (np.int64(0), np.... 23      True   2022-01-01
    j                (np.int64(0), np.... 83      True   2023-04-01
    j                (np.int64(1), np.... 19      False  2022-12-31
    j                (np.int64(1), np.... 87      False  2024-06-30
    <<U1>            <object>             <int64> <bool> <datetime64[D]>

    ```

Batch.relabel\_level\_add(*index=None*, *columns=None*, *\**, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/batch.md#Batch.relabel_level_add)[](#static_frame.Batch.relabel_level_add "Link to this definition")
:   ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> tuple(bt.relabel_level_add('I').values)
    (<Frame: x>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    I                p     0       1
    I                q     2       3
    I                r     4       5
    <<U1>            <<U1> <int64> <int64>, <Frame: v>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    I                p     40      41
    I                q     42      43
    I                r     44      45
    <<U1>            <<U1> <int64> <int64>)

    ```

Batch.relabel\_level\_drop(*index=0*, *columns=0*)[[source]](../_modules/static_frame/core/batch.md#Batch.relabel_level_drop)[](#static_frame.Batch.relabel_level_drop "Link to this definition")
:   ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')), ('j', sf.Frame.from_fields(((23, 83, 19, 87), (True, True, False, False), ('2022-01-01', '2023-04-01', '2022-12-31', '2024-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt.iloc[:2].relabel_level_drop(1).to_frame()
    <Frame>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    i                p     10      False  1517-01-01
    i                q     2       True   1517-04-01
    j                p     23      True   2022-01-01
    j                q     83      True   2023-04-01
    <<U1>            <<U1> <int64> <bool> <datetime64[D]>

    ```

Batch.relabel\_shift\_in(*key*, */*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/batch.md#Batch.relabel_shift_in)[](#static_frame.Batch.relabel_shift_in "Link to this definition")
:   ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')), ('j', sf.Frame.from_fields(((23, 83, 19, 87), (True, True, False, False), ('2022-01-01', '2023-04-01', '2022-12-31', '2024-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> tuple(bt.relabel_shift_in('a').values)
    (<Frame: x>
    <Index>                                            b      c               <<U1>
    <IndexHierarchy: ('__index0__', '...
    0                                    p     10      False  1517-01-01
    0                                    q     2       True   1517-04-01
    1                                    p     8       True   1517-12-31
    1                                    q     3       False  1517-06-30
    <int64>                              <<U1> <int64> <bool> <datetime64[D]>, <Frame: x>
    <Index>                                            b      c               <<U1>
    <IndexHierarchy: ('__index0__', '...
    0                                    p     23      True   2022-01-01
    0                                    q     83      True   2023-04-01
    1                                    p     19      False  2022-12-31
    1                                    q     87      False  2024-06-30
    <int64>                              <<U1> <int64> <bool> <datetime64[D]>)

    ```

Batch.rename(*name=<object object>*, */*, *\**, *index=<object object>*, *columns=<object object>*)[[source]](../_modules/static_frame/core/batch.md#Batch.rename)[](#static_frame.Batch.rename "Link to this definition")
:   Return a new Batch with an updated name attribute.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.rename('y').to_bus()
    <Bus>
    <Index>
    i       Frame
    j       Frame
    <<U1>   <object>

    ```

Batch.roll(*index=0*, *columns=0*, *\**, *include\_index=False*, *include\_columns=False*)[[source]](../_modules/static_frame/core/batch.md#Batch.roll)[](#static_frame.Batch.roll "Link to this definition")
:   Roll columns and/or rows by positive or negative integer counts, where columns and/or rows roll around the axis.

    Parameters:
    :   * **include\_index** – Determine if index is included in index-wise rotation.
        * **include\_columns** – Determine if column index is included in index-wise rotation.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.roll(1, include_index=True).to_frame()
    <Frame>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    i                r     4       5
    i                p     0       1
    i                q     2       3
    j                r     44      45
    j                p     40      41
    j                q     42      43
    <<U1>            <<U1> <int64> <int64>

    ```

Batch.sample(*index=None*, *columns=None*, *\**, *seed=None*)[[source]](../_modules/static_frame/core/batch.md#Batch.sample)[](#static_frame.Batch.sample "Link to this definition")
:   Apply sample on contained Frames.

    Parameters:
    :   * **index.** (*Number* *of* *labels to select from the*) –
        * **columns.** (*Number* *of* *labels to select from the*) –
        * **selection.** (*Initial state* *of* *random*) –

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.sample(2, 2, seed=0).to_frame()
    <Frame>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    i                q     2       3
    i                r     4       5
    j                q     42      43
    j                r     44      45
    <<U1>            <<U1> <int64> <int64>

    ```

Batch.shift(*index=0*, *columns=0*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/batch.md#Batch.shift)[](#static_frame.Batch.shift "Link to this definition")
:   Shift columns and/or rows by positive or negative integer counts, where columns and/or rows fall of the axis and introduce missing values, filled by fill\_value.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.shift(1, fill_value=sf.FillValueAuto).to_frame()
    <Frame>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    i                p     0       0
    i                q     0       1
    i                r     2       3
    j                p     0       0
    j                q     40      41
    j                r     42      43
    <<U1>            <<U1> <int64> <int64>

    ```

Batch.sort\_columns(*\**, *ascending=True*, *kind='mergesort'*)[[source]](../_modules/static_frame/core/batch.md#Batch.sort_columns)[](#static_frame.Batch.sort_columns "Link to this definition")
:   Return a new [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") ordered by the sorted `columns`.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.sort_columns(ascending=False).to_frame()
    <Frame>
    <Index>                b       a       <<U1>
    <IndexHierarchy>
    i                p     1       0
    i                q     3       2
    i                r     5       4
    j                p     41      40
    j                q     43      42
    j                r     45      44
    <<U1>            <<U1> <int64> <int64>

    ```

Batch.sort\_index(*\**, *ascending=True*, *kind='mergesort'*)[[source]](../_modules/static_frame/core/batch.md#Batch.sort_index)[](#static_frame.Batch.sort_index "Link to this definition")
:   Return a new [`Batch`](batch-selector.md#Batch "Batch") with contained :obj;`Frame` ordered by the sorted `index`.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.sort_index(ascending=False).to_frame()
    <Frame>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    i                r     4       5
    i                q     2       3
    i                p     0       1
    j                r     44      45
    j                q     42      43
    j                p     40      41
    <<U1>            <<U1> <int64> <int64>

    ```

Batch.sort\_values(*label*, */*, *\**, *ascending=True*, *axis=1*, *kind='mergesort'*)[[source]](../_modules/static_frame/core/batch.md#Batch.sort_values)[](#static_frame.Batch.sort_values "Link to this definition")
:   Return a new [`Batch`](batch-selector.md#Batch "Batch") with contained [`Frame`](frame-selector.md#Frame "Frame") ordered by the sorted values, where values are given by single column or iterable of columns.

    Parameters:
    :   **label** – a label or iterable of keys.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.sort_values('a', ascending=False).to_frame()
    <Frame>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    i                r     4       5
    i                q     2       3
    i                p     0       1
    j                r     44      45
    j                q     42      43
    j                p     40      41
    <<U1>            <<U1> <int64> <int64>

    ```

Batch.std(*\**, *axis=0*, *skipna=True*, *ddof=0*, *out=None*)[](#static_frame.Batch.std "Link to this definition")
:   Return the standard deviaton along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.std().to_frame()
    <Frame>
    <Index> a                 b                 <<U1>
    <Index>
    i       1.632993161855452 1.632993161855452
    j       1.632993161855452 1.632993161855452
    <<U1>   <float64>         <float64>

    ```

Batch.sum(*\**, *axis=0*, *skipna=True*, *allna=0*, *out=None*)[](#static_frame.Batch.sum "Link to this definition")
:   Sum values along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.sum().to_frame()
    <Frame>
    <Index> a       b       <<U1>
    <Index>
    i       6       9
    j       126     129
    <<U1>   <int64> <int64>

    ```

Batch.tail(*count=5*, */*)[[source]](../_modules/static_frame/core/batch.md#Batch.tail)[](#static_frame.Batch.tail "Link to this definition")
:   Return a [`Batch`](batch-selector.md#Batch "Batch") consisting only of the bottom elements as specified by `count`.

    Parameters:
    :   **count** – Number of elements to be returned from the bottom of the [`Batch`](batch-selector.md#Batch "Batch")

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.tail(2).to_frame()
    <Frame>
    <Index>                a       b       <<U1>
    <IndexHierarchy>
    i                q     2       3
    i                r     4       5
    j                q     42      43
    j                r     44      45
    <<U1>            <<U1> <int64> <int64>

    ```

Batch.transpose()[[source]](../_modules/static_frame/core/batch.md#Batch.transpose)[](#static_frame.Batch.transpose "Link to this definition")
:   Transpose. Return a [`Frame`](frame-selector.md#Frame "Frame") with `index` as `columns` and vice versa.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.transpose().to_frame()
    <Frame>
    <Index>                p       q       r       <<U1>
    <IndexHierarchy>
    i                a     0       2       4
    i                b     1       3       5
    j                a     40      42      44
    j                b     41      43      45
    <<U1>            <<U1> <int64> <int64> <int64>

    ```

Batch.unique(*\**, *axis=None*)[[source]](../_modules/static_frame/core/batch.md#Batch.unique)[](#static_frame.Batch.unique "Link to this definition")
:   Return a NumPy array of unqiue values. If the axis argument is provied, uniqueness is determined by columns or row.

    ```
    >>> bt = sf.Batch((('i', sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), ('j', sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w'))))
    >>> bt.unique().to_frame()
    <Frame>
    <Index> 0      1      <int64>
    <Index>
    i       False  True
    j       False  True
    <<U1>   <bool> <bool>

    ```

Batch.unset\_index(*\**, *names=()*, *consolidate\_blocks=False*, *columns\_constructors=None*)[[source]](../_modules/static_frame/core/batch.md#Batch.unset_index)[](#static_frame.Batch.unset_index "Link to this definition")
:   ```
    >>> bt = sf.Batch((('i', sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')), ('j', sf.Frame.from_fields(((23, 83, 19, 87), (True, True, False, False), ('2022-01-01', '2023-04-01', '2022-12-31', '2024-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x'))))
    >>> bt.rename(index=('d', 'e')).unset_index().to_frame()
    <Frame>
    <Index>                  d       e     a       b      c               <<U1>
    <IndexHierarchy>
    i                0       0       p     10      False  1517-01-01
    i                1       0       q     2       True   1517-04-01
    i                2       1       p     8       True   1517-12-31
    i                3       1       q     3       False  1517-06-30
    j                0       0       p     23      True   2022-01-01
    j                1       0       q     83      True   2023-04-01
    j                2       1       p     19      False  2022-12-31
    j                3       1       q     87      False  2024-06-30
    <<U1>            <int64> <int64> <<U1> <int64> <bool> <datetime64[D]>

    ```

Batch.var(*\**, *axis=0*, *skipna=True*, *ddof=0*, *out=None*)[](#static_frame.Batch.var "Link to this definition")
:   Return the variance along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> bt = sf.Batch((('i', sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')), ('j', sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'))))
    >>> bt.var().to_frame()
    <Frame>
    <Index> a                  b                  <<U1>
    <Index>
    i       2.6666666666666665 2.6666666666666665
    j       2.6666666666666665 2.6666666666666665
    <<U1>   <float64>          <float64>

    ```

[Batch](batch.md#api-detail-batch): [Constructor](batch-constructor.md#api-detail-batch-constructor) | [Exporter](batch-exporter.md#api-detail-batch-exporter) | [Attribute](batch-attribute.md#api-detail-batch-attribute) | [Method](#api-detail-batch-method) | [Dictionary-Like](batch-dictionary_like.md#api-detail-batch-dictionary-like) | [Display](batch-display.md#api-detail-batch-display) | [Selector](batch-selector.md#api-detail-batch-selector) | [Operator Binary](batch-operator_binary.md#api-detail-batch-operator-binary) | [Operator Unary](batch-operator_unary.md#api-detail-batch-operator-unary) | [Accessor Values](batch-accessor_values.md#api-detail-batch-accessor-values) | [Accessor Datetime](batch-accessor_datetime.md#api-detail-batch-accessor-datetime) | [Accessor String](batch-accessor_string.md#api-detail-batch-accessor-string) | [Accessor Transpose](batch-accessor_transpose.md#api-detail-batch-accessor-transpose) | [Accessor Fill Value](batch-accessor_fill_value.md#api-detail-batch-accessor-fill-value) | [Accessor Regular Expression](batch-accessor_regular_expression.md#api-detail-batch-accessor-regular-expression) | [Accessor Hashlib](batch-accessor_hashlib.md#api-detail-batch-accessor-hashlib) | [Accessor Type Clinic](batch-accessor_type_clinic.md#api-detail-batch-accessor-type-clinic) | [Accessor Reduce](batch-accessor_reduce.md#api-detail-batch-accessor-reduce)

[Previous](batch-attribute.md "Detail: Batch: Attribute")
[Next](batch-dictionary_like.md "Detail: Batch: Dictionary-Like")

---

© Copyright 2025, Christopher Ariza.
Last updated on May 17, 2025.

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme)
provided by [Read the Docs](https://readthedocs.org).