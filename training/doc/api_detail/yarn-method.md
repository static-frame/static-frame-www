[![Logo](../_static/sf-logo-web_icon-small.png)](../index.md)

Quick Start

* [static-frame](../readme.md)
* [License](../license.md)

Introduction

* [About StaticFrame](../intro.md)
* [Media](../intro.md#media)
* [What is New in StaticFrame](../new.md)
* [Contributing](../contributing.md)

Articles

* [Improving Code Quality with Array and DataFrame Type Hints](../articles/guard.md)
* [Type-Hinting DataFrames for Static Analysis and Runtime Validation](../articles/ftyping.md)
* [Faster DataFrame Serialization](../articles/serialize.md)
* [The Performance Advantage of No-Copy DataFrame Operations](../articles/no_copy.md)
* [Memoizing DataFrame Functions: Using Hashable DataFrames and Message Digests to Optimize Repeated Calculations](../articles/hash.md)
* [Using Higher-Order Containers to Efficiently Process 7,163 (or More) DataFrames](../articles/uhoc.md)
* [One Fill Value Is Not Enough: Preserving Columnar Types When Reindexing DataFrames](../articles/fill_value.md)
* [Ten Reasons to Use StaticFrame Instead of Pandas](../articles/upgrade.md)
* [Boring Indices & Where to Find Them: The Auto-Incremented Integer Index in StaticFrame](../articles/aiii.md)

API Overview

* [Overview: Series](../api_overview/series.md)
* [Overview: SeriesHE](../api_overview/series_he.md)
* [Overview: Frame](../api_overview/frame.md)
* [Overview: FrameGO](../api_overview/frame_go.md)
* [Overview: FrameHE](../api_overview/frame_he.md)
* [Overview: Bus](../api_overview/bus.md)
* [Overview: Batch](../api_overview/batch.md)
* [Overview: Yarn](../api_overview/yarn.md)
* [Overview: Quilt](../api_overview/quilt.md)
* [Overview: Index](../api_overview/index.md)
* [Overview: IndexGO](../api_overview/index_go.md)
* [Overview: IndexHierarchy](../api_overview/index_hierarchy.md)
* [Overview: IndexHierarchyGO](../api_overview/index_hierarchy_go.md)
* [Overview: IndexYear](../api_overview/index_year.md)
* [Overview: IndexYearGO](../api_overview/index_year_go.md)
* [Overview: IndexYearMonth](../api_overview/index_year_month.md)
* [Overview: IndexYearMonthGO](../api_overview/index_year_month_go.md)
* [Overview: IndexDate](../api_overview/index_date.md)
* [Overview: IndexDateGO](../api_overview/index_date_go.md)
* [Overview: IndexMinute](../api_overview/index_minute.md)
* [Overview: IndexMinuteGO](../api_overview/index_minute_go.md)
* [Overview: IndexHour](../api_overview/index_hour.md)
* [Overview: IndexHourGO](../api_overview/index_hour_go.md)
* [Overview: IndexSecond](../api_overview/index_second.md)
* [Overview: IndexSecondGO](../api_overview/index_second_go.md)
* [Overview: IndexMillisecond](../api_overview/index_millisecond.md)
* [Overview: IndexMillisecondGO](../api_overview/index_millisecond_go.md)
* [Overview: IndexMicrosecond](../api_overview/index_microsecond.md)
* [Overview: IndexMicrosecondGO](../api_overview/index_microsecond_go.md)
* [Overview: IndexNanosecond](../api_overview/index_nanosecond.md)
* [Overview: IndexNanosecondGO](../api_overview/index_nanosecond_go.md)
* [Overview: HLoc](../api_overview/hloc.md)
* [Overview: ILoc](../api_overview/iloc.md)
* [Overview: TypeClinic](../api_overview/type_clinic.md)
* [Overview: CallGuard](../api_overview/call_guard.md)
* [Overview: ClinicResult](../api_overview/clinic_result.md)
* [Overview: Require](../api_overview/require.md)
* [Overview: WWW](../api_overview/www.md)
* [Overview: FillValueAuto](../api_overview/fill_value_auto.md)
* [Overview: DisplayActive](../api_overview/display_active.md)
* [Overview: DisplayConfig](../api_overview/display_config.md)
* [Overview: StoreConfig](../api_overview/store_config.md)
* [Overview: StoreFilter](../api_overview/store_filter.md)
* [Overview: IndexAutoFactory](../api_overview/index_auto_factory.md)
* [Overview: IndexDefaultConstructorFactory](../api_overview/index_default_constructor_factory.md)
* [Overview: IndexAutoConstructorFactory](../api_overview/index_auto_constructor_factory.md)
* [Overview: NPZ](../api_overview/npz.md)
* [Overview: NPY](../api_overview/npy.md)
* [Overview: MemoryDisplay](../api_overview/memory_display.md)
* [Overview: Platform](../api_overview/platform.md)

API Detail

* [Detail: Series](series.md)
* [Detail: SeriesHE](series_he.md)
* [Detail: Frame](frame.md)
* [Detail: FrameGO](frame_go.md)
* [Detail: FrameHE](frame_he.md)
* [Detail: Bus](bus.md)
* [Detail: Batch](batch.md)
* [Detail: Yarn](yarn.md)
* [Detail: Quilt](quilt.md)
* [Detail: Index](index.md)
* [Detail: IndexGO](index_go.md)
* [Detail: IndexHierarchy](index_hierarchy.md)
* [Detail: IndexHierarchyGO](index_hierarchy_go.md)
* [Detail: IndexYear](index_year.md)
* [Detail: IndexYearGO](index_year_go.md)
* [Detail: IndexYearMonth](index_year_month.md)
* [Detail: IndexYearMonthGO](index_year_month_go.md)
* [Detail: IndexDate](index_date.md)
* [Detail: IndexDateGO](index_date_go.md)
* [Detail: IndexMinute](index_minute.md)
* [Detail: IndexMinuteGO](index_minute_go.md)
* [Detail: IndexHour](index_hour.md)
* [Detail: IndexHourGO](index_hour_go.md)
* [Detail: IndexSecond](index_second.md)
* [Detail: IndexSecondGO](index_second_go.md)
* [Detail: IndexMillisecond](index_millisecond.md)
* [Detail: IndexMillisecondGO](index_millisecond_go.md)
* [Detail: IndexMicrosecond](index_microsecond.md)
* [Detail: IndexMicrosecondGO](index_microsecond_go.md)
* [Detail: IndexNanosecond](index_nanosecond.md)
* [Detail: IndexNanosecondGO](index_nanosecond_go.md)
* [Detail: HLoc](hloc.md)
* [Detail: ILoc](iloc.md)
* [Detail: TypeClinic](type_clinic.md)
* [Detail: CallGuard](call_guard.md)
* [Detail: ClinicResult](clinic_result.md)
* [Detail: Require](require.md)
* [Detail: WWW](www.md)
* [Detail: FillValueAuto](fill_value_auto.md)
* [Detail: DisplayActive](display_active.md)
* [Detail: DisplayConfig](display_config.md)
* [Detail: StoreConfig](store_config.md)
* [Detail: StoreFilter](store_filter.md)
* [Detail: IndexAutoFactory](index_auto_factory.md)
* [Detail: IndexDefaultConstructorFactory](index_default_constructor_factory.md)
* [Detail: IndexAutoConstructorFactory](index_auto_constructor_factory.md)
* [Detail: NPZ](npz.md)
* [Detail: NPY](npy.md)
* [Detail: MemoryDisplay](memory_display.md)
* [Detail: Platform](platform.md)

[StaticFrame](../index.md)

* Detail: Yarn: Method
* [View page source](../_sources/api_detail/yarn-method.rst.txt)

[Previous](yarn-attribute.md "Detail: Yarn: Attribute")
[Next](yarn-dictionary_like.md "Detail: Yarn: Dictionary-Like")

---

# Detail: Yarn: Method[](#detail-yarn-method "Link to this heading")

[Overview: Yarn: Method](../api_overview/yarn-method.md#api-overview-yarn-method)

Yarn.\_\_bool\_\_()[](#static_frame.Yarn.__bool__ "Link to this definition")
:   Raises ValueError to prohibit ambiguous use of truthy evaluation.

    ```
    >>> b1 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i')
    >>> b2 = sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')
    >>> y = sf.Yarn.from_buses((b1, b2), retain_labels=False)
    >>> y
    <Yarn>
    <Index>
    x       Frame
    y       Frame
    v       Frame
    w       Frame
    <<U1>   <object>
    >>> bool(y)
    ErrorNotTruthy('The truth value of a container is ambiguous. For a truthy indicator of non-empty status, use the `size` attribute.')

    ```

Yarn.\_\_len\_\_()[[source]](../_modules/static_frame/core/yarn.md#Yarn.__len__)[](#static_frame.Yarn.__len__ "Link to this definition")
:   Length of values.

    ```
    >>> b1 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i')
    >>> b2 = sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')
    >>> y = sf.Yarn.from_buses((b1, b2), retain_labels=False)
    >>> y
    <Yarn>
    <Index>
    x       Frame
    y       Frame
    v       Frame
    w       Frame
    <<U1>   <object>
    >>> len(y)
    4

    ```

Yarn.equals(*other*, */*, *\**, *compare\_name=False*, *compare\_dtype=False*, *compare\_class=False*, *skipna=True*)[[source]](../_modules/static_frame/core/yarn.md#Yarn.equals)[](#static_frame.Yarn.equals "Link to this definition")
:   Return a `bool` from comparison to any other object.

    Note: this will attempt to load and compare all Frame managed by the Bus.

    Parameters:
    :   * **compare\_name** – Include equality of the container’s name (and all composed containers) in the comparison.
        * **compare\_dtype** – Include equality of the container’s dtype (and all composed containers) in the comparison.
        * **compare\_class** – Include equality of the container’s class (and all composed containers) in the comparison.
        * **skipna** – If True, comparisons between missing values are equal.

    ```
    >>> b1 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i')
    >>> b2 = sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')
    >>> b3 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y'), sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='k')
    >>> y1 = sf.Yarn.from_buses((b1, b2), retain_labels=False)
    >>> y1
    <Yarn>
    <Index>
    x       Frame
    y       Frame
    v       Frame
    w       Frame
    <<U1>   <object>
    >>> y2 = sf.Yarn.from_buses((b3,), retain_labels=False)
    >>> y2
    <Yarn>
    <Index>
    x       Frame
    y       Frame
    v       Frame
    w       Frame
    <<U1>   <object>
    >>> y1.equals(y2)
    True

    ```

Yarn.head(*count=5*, */*)[[source]](../_modules/static_frame/core/yarn.md#Yarn.head)[](#static_frame.Yarn.head "Link to this definition")
:   Return a [`Yarn`](yarn-selector.md#Yarn "Yarn") consisting only of the top elements as specified by `count`.

    Parameters:
    :   **count** – Number of elements to be returned from the top of the [`Yarn`](yarn-selector.md#Yarn "Yarn")

    Returns:
    :   [`Yarn`](yarn-selector.md#Yarn "Yarn")

    ```
    >>> b1 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i')
    >>> b2 = sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')
    >>> y = sf.Yarn.from_buses((b1, b2), retain_labels=False)
    >>> y
    <Yarn>
    <Index>
    x       Frame
    y       Frame
    v       Frame
    w       Frame
    <<U1>   <object>
    >>> y.head(2)
    <Yarn>
    <Index>
    x       Frame
    y       Frame
    <<U1>   <object>

    ```

Yarn.persist[*key*]
:   persist
    :   Interface for selectively (or completely) pre-load Frame from a store to optimize subsequent single Frame extraction.

    InterfacePersist.\_\_getitem\_\_ *= <function InterfacePersist.\_\_getitem\_\_>*[[source]](../_modules/static_frame/core/node_selector.md#InterfacePersist.__getitem__)

    ```
    >>> b1 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i')
    >>> b1.to_zip_npz('/tmp/b1.zip')
    >>> b2 = sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')
    >>> b2.to_zip_npz('/tmp/b2.zip')
    >>> b1 = sf.Bus.from_zip_npz('/tmp/b1.zip').rename('a')
    >>> b1
    <Bus: a>
    <Index>
    x        <FrameDeferred>
    y        <FrameDeferred>
    <<U1>    <object>
    >>> b2 = sf.Bus.from_zip_npz('/tmp/b2.zip').rename('b')
    >>> b2
    <Bus: b>
    <Index>
    v        <FrameDeferred>
    w        <FrameDeferred>
    <<U1>    <object>
    >>> y1 = sf.Yarn.from_buses((b1, b2), retain_labels=False)
    >>> y1.status
    <Frame>
    <Index> loaded size      nbytes    shape    <<U6>
    <Index>
    x       False  nan       nan       None
    y       False  nan       nan       None
    v       False  nan       nan       None
    w       False  nan       nan       None
    <<U1>   <bool> <float64> <float64> <object>
    >>> y1.persist['y']
    >>> y1.status
    <Frame>
    <Index> loaded size      nbytes    shape    <<U6>
    <Index>
    x       False  nan       nan       None
    y       True   6.0       6.0       (3, 2)
    v       False  nan       nan       None
    w       False  nan       nan       None
    <<U1>   <bool> <float64> <float64> <object>

    ```

Yarn.persist.iloc[*key*]
:   Yarn.persist
    :   Interface for selectively (or completely) pre-load Frame from a store to optimize subsequent single Frame extraction.

    InterfacePersist.iloc
    :   Integer-position based selection.

    ```
    >>> b1 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i')
    >>> b1.to_zip_npz('/tmp/b1.zip')
    >>> b2 = sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')
    >>> b2.to_zip_npz('/tmp/b2.zip')
    >>> b1 = sf.Bus.from_zip_npz('/tmp/b1.zip').rename('a')
    >>> b1
    <Bus: a>
    <Index>
    x        <FrameDeferred>
    y        <FrameDeferred>
    <<U1>    <object>
    >>> b2 = sf.Bus.from_zip_npz('/tmp/b2.zip').rename('b')
    >>> b2
    <Bus: b>
    <Index>
    v        <FrameDeferred>
    w        <FrameDeferred>
    <<U1>    <object>
    >>> y1 = sf.Yarn.from_buses((b1, b2), retain_labels=False)
    >>> y1.status
    <Frame>
    <Index> loaded size      nbytes    shape    <<U6>
    <Index>
    x       False  nan       nan       None
    y       False  nan       nan       None
    v       False  nan       nan       None
    w       False  nan       nan       None
    <<U1>   <bool> <float64> <float64> <object>
    >>> y1.persist.iloc[-1]
    >>> y1.status
    <Frame>
    <Index> loaded size      nbytes    shape    <<U6>
    <Index>
    x       False  nan       nan       None
    y       False  nan       nan       None
    v       False  nan       nan       None
    w       True   6.0       6.0       (3, 2)
    <<U1>   <bool> <float64> <float64> <object>

    ```

Yarn.persist.loc[*key*]
:   Yarn.persist
    :   Interface for selectively (or completely) pre-load Frame from a store to optimize subsequent single Frame extraction.

    InterfacePersist.loc
    :   Label-based selection.

    ```
    >>> b1 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i')
    >>> b1.to_zip_npz('/tmp/b1.zip')
    >>> b2 = sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')
    >>> b2.to_zip_npz('/tmp/b2.zip')
    >>> b1 = sf.Bus.from_zip_npz('/tmp/b1.zip').rename('a')
    >>> b1
    <Bus: a>
    <Index>
    x        <FrameDeferred>
    y        <FrameDeferred>
    <<U1>    <object>
    >>> b2 = sf.Bus.from_zip_npz('/tmp/b2.zip').rename('b')
    >>> b2
    <Bus: b>
    <Index>
    v        <FrameDeferred>
    w        <FrameDeferred>
    <<U1>    <object>
    >>> y1 = sf.Yarn.from_buses((b1, b2), retain_labels=False)
    >>> y1.status
    <Frame>
    <Index> loaded size      nbytes    shape    <<U6>
    <Index>
    x       False  nan       nan       None
    y       False  nan       nan       None
    v       False  nan       nan       None
    w       False  nan       nan       None
    <<U1>   <bool> <float64> <float64> <object>
    >>> y1.persist.loc['y']
    >>> y1.status
    <Frame>
    <Index> loaded size      nbytes    shape    <<U6>
    <Index>
    x       False  nan       nan       None
    y       True   6.0       6.0       (3, 2)
    v       False  nan       nan       None
    w       False  nan       nan       None
    <<U1>   <bool> <float64> <float64> <object>

    ```

Yarn.persist
:   persist
    :   Interface for selectively (or completely) pre-load Frame from a store to optimize subsequent single Frame extraction.

    InterfacePersist.\_\_call\_\_()[[source]](../_modules/static_frame/core/node_selector.md#InterfacePersist.__call__)
    :   Persist all Frame.

    ```
    >>> b1 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i')
    >>> b1.to_zip_npz('/tmp/b1.zip')
    >>> b2 = sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')
    >>> b2.to_zip_npz('/tmp/b2.zip')
    >>> b1 = sf.Bus.from_zip_npz('/tmp/b1.zip').rename('a')
    >>> b1
    <Bus: a>
    <Index>
    x        <FrameDeferred>
    y        <FrameDeferred>
    <<U1>    <object>
    >>> b2 = sf.Bus.from_zip_npz('/tmp/b2.zip').rename('b')
    >>> b2
    <Bus: b>
    <Index>
    v        <FrameDeferred>
    w        <FrameDeferred>
    <<U1>    <object>
    >>> y1 = sf.Yarn.from_buses((b1, b2), retain_labels=False)
    >>> y1.status
    <Frame>
    <Index> loaded size      nbytes    shape    <<U6>
    <Index>
    x       False  nan       nan       None
    y       False  nan       nan       None
    v       False  nan       nan       None
    w       False  nan       nan       None
    <<U1>   <bool> <float64> <float64> <object>
    >>> y1.persist()
    >>> y1.status
    <Frame>
    <Index> loaded size      nbytes    shape    <<U6>
    <Index>
    x       True   6.0       48.0      (3, 2)
    y       True   6.0       6.0       (3, 2)
    v       True   6.0       48.0      (3, 2)
    w       True   6.0       6.0       (3, 2)
    <<U1>   <bool> <float64> <float64> <object>

    ```

Yarn.rehierarch(*depth\_map*, */*, *\**, *index\_constructors=None*)[[source]](../_modules/static_frame/core/yarn.md#Yarn.rehierarch)[](#static_frame.Yarn.rehierarch "Link to this definition")
:   Return a new [`Series`](series-selector.md#Series "Series") with new a hierarchy based on the supplied `depth_map`.

    ```
    >>> b1 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i')
    >>> b2 = sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')
    >>> y = sf.Yarn.from_buses((b1, b2), retain_labels=True)
    >>> y
    <Yarn>
    <IndexHierarchy>
    i                x     Frame
    i                y     Frame
    j                v     Frame
    j                w     Frame
    <<U1>            <<U1> <object>
    >>> y.rehierarch((1, 0))
    <Yarn>
    <IndexHierarchy>
    x                i     Frame
    y                i     Frame
    v                j     Frame
    w                j     Frame
    <<U1>            <<U1> <object>

    ```

Yarn.reindex(*index*, *\**, *fill\_value=None*, *own\_index=False*, *check\_equals=True*)[[source]](../_modules/static_frame/core/yarn.md#Yarn.reindex)[](#static_frame.Yarn.reindex "Link to this definition")
:   Return a new [`Bus`](bus-selector.md#Bus "Bus") with labels defined by the provided index. The size and ordering of the data is determined by the newly provided index, where data will continue to be aligned under labels found in both the new and the old index. Labels found only in the new index will be filled with `fill_value`.

    Parameters:
    :   * **index** – An iterable of unique, hashable values, or another `Index` or `IndexHierarchy`, to be used as the labels of the index.
        * **columns** – An iterable of unique, hashable values, or another `Index` or `IndexHierarchy`, to be used as the labels of the index.
        * **fill\_value** – A value to be used to fill space created by a new index that has values not found in the previous index.
        * **own\_index** – Flag the passed index as ownable by this [`static_frame.Bus`](bus.md#static_frame.Bus "static_frame.Bus"). Primarily used by internal clients.

    ```
    >>> y1 = sf.Yarn.from_buses((sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i'), sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')), retain_labels=False)
    >>> y1
    <Yarn>
    <Index>
    x       Frame
    y       Frame
    v       Frame
    w       Frame
    <<U1>   <object>
    >>> y1.reindex(('y', 'x', 'v'))
    <Yarn>
    <Index>
    y       Frame
    x       Frame
    v       Frame
    <<U1>   <object>

    ```

Yarn.relabel(*index*)[[source]](../_modules/static_frame/core/yarn.md#Yarn.relabel)[](#static_frame.Yarn.relabel "Link to this definition")
:   Return a new [`Yarn`](yarn-selector.md#Yarn "Yarn") with transformed labels on the index. The size and ordering of the data is never changed in a relabeling operation. The resulting index must be unique.

    Parameters:
    :   **index** – One of the following types, used to create new index labels with the same size as the previous index. (a) A mapping (as a dictionary or `Series`), used to lookup and transform the labels in the previous index. Labels not found in the mapping will be reused. (b) A function, returning a hashable, that is applied to each label in the previous index. (c) The `IndexAutoFactory` type, to apply auto-incremented integer labels. (d) An `Index` initializer, i.e., either an iterable of hashables or an `Index` instance.

    ```
    >>> b1 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i')
    >>> b2 = sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')
    >>> y = sf.Yarn.from_buses((b1, b2), retain_labels=True)
    >>> y
    <Yarn>
    <IndexHierarchy>
    i                x     Frame
    i                y     Frame
    j                v     Frame
    j                w     Frame
    <<U1>            <<U1> <object>
    >>> y.relabel(('A', 'B', 'C', 'D'))
    <Yarn>
    <Index>
    A       Frame
    B       Frame
    C       Frame
    D       Frame
    <<U1>   <object>
    >>> y.relabel({('j', 'v'):('A', 'x')})
    <Yarn>
    <IndexHierarchy>
    i                x     Frame
    i                y     Frame
    A                x     Frame
    j                w     Frame
    <<U1>            <<U1> <object>

    ```

Yarn.relabel\_flat()[[source]](../_modules/static_frame/core/yarn.md#Yarn.relabel_flat)[](#static_frame.Yarn.relabel_flat "Link to this definition")
:   Return a new [`Yarn`](yarn-selector.md#Yarn "Yarn"), where an `IndexHierarchy` (if defined) is replaced with a flat, one-dimension index of tuples.

    ```
    >>> b1 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i')
    >>> b2 = sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')
    >>> y = sf.Yarn.from_buses((b1, b2), retain_labels=True)
    >>> y
    <Yarn>
    <IndexHierarchy>
    i                x     Frame
    i                y     Frame
    j                v     Frame
    j                w     Frame
    <<U1>            <<U1> <object>
    >>> y.relabel_flat()
    <Yarn>
    <Index>
    (np.str_('i'), np.str_('x')) Frame
    (np.str_('i'), np.str_('y')) Frame
    (np.str_('j'), np.str_('v')) Frame
    (np.str_('j'), np.str_('w')) Frame
    <object>                     <object>

    ```

Yarn.relabel\_level\_add(*level*, */*)[[source]](../_modules/static_frame/core/yarn.md#Yarn.relabel_level_add)[](#static_frame.Yarn.relabel_level_add "Link to this definition")
:   Return a new [`Yarn`](yarn-selector.md#Yarn "Yarn"), adding a new root level to an existing `IndexHierarchy`, or creating an `IndexHierarchy` if one is not yet defined.

    Parameters:
    :   **level** – A hashable value to be used as a new root level, extending or creating an `IndexHierarchy`

    ```
    >>> b1 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i')
    >>> b2 = sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')
    >>> y = sf.Yarn.from_buses((b1, b2), retain_labels=True)
    >>> y
    <Yarn>
    <IndexHierarchy>
    i                x     Frame
    i                y     Frame
    j                v     Frame
    j                w     Frame
    <<U1>            <<U1> <object>
    >>> y.relabel_level_add('A')
    <Yarn>
    <IndexHierarchy>
    A                i     x     Frame
    A                i     y     Frame
    A                j     v     Frame
    A                j     w     Frame
    <<U1>            <<U1> <<U1> <object>

    ```

Yarn.relabel\_level\_drop(*count=1*, */*)[[source]](../_modules/static_frame/core/yarn.md#Yarn.relabel_level_drop)[](#static_frame.Yarn.relabel_level_drop "Link to this definition")
:   Return a new [`Yarn`](yarn-selector.md#Yarn "Yarn"), dropping one or more levels from a either the root or the leaves of an `IndexHierarchy`. The resulting index must be unique.

    Parameters:
    :   **count** – A positive integer drops that many outer-most (root) levels; a negative integer drops that many inner-most (leaf)levels.

    ```
    >>> b1 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i')
    >>> b2 = sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')
    >>> y = sf.Yarn.from_buses((b1, b2), retain_labels=True)
    >>> y
    <Yarn>
    <IndexHierarchy>
    i                x     Frame
    i                y     Frame
    j                v     Frame
    j                w     Frame
    <<U1>            <<U1> <object>
    >>> y.relabel_level_drop()
    <Yarn>
    <Index>
    x       Frame
    y       Frame
    v       Frame
    w       Frame
    <<U1>   <object>

    ```

Yarn.rename(*name*, */*)[[source]](../_modules/static_frame/core/yarn.md#Yarn.rename)[](#static_frame.Yarn.rename "Link to this definition")
:   Return a new [`Yarn`](yarn-selector.md#Yarn "Yarn") with an updated name attribute.

    Parameters:
    :   **name** –

    ```
    >>> b1 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i')
    >>> b2 = sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')
    >>> y = sf.Yarn.from_buses((b1, b2), retain_labels=True)
    >>> y
    <Yarn>
    <IndexHierarchy>
    i                x     Frame
    i                y     Frame
    j                v     Frame
    j                w     Frame
    <<U1>            <<U1> <object>
    >>> y.rename('j')
    <Yarn: j>
    <IndexHierarchy>
    i                x     Frame
    i                y     Frame
    j                v     Frame
    j                w     Frame
    <<U1>            <<U1> <object>

    ```

Yarn.roll(*shift*, */*, *\**, *include\_index=False*)[[source]](../_modules/static_frame/core/yarn.md#Yarn.roll)[](#static_frame.Yarn.roll "Link to this definition")
:   Return a Yarn with values rotated forward and wrapped around the index (with a positive shift) or backward and wrapped around the index (with a negative shift).

    Parameters:
    :   * **shift** – Positive or negative integer shift.
        * **include\_index** – Determine if the Index is shifted with the underlying data.

    Returns:
    :   [`Yarn`](yarn-selector.md#Yarn "Yarn")

    ```
    >>> y1 = sf.Yarn.from_buses((sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i'), sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')), retain_labels=False)
    >>> y1
    <Yarn>
    <Index>
    x       Frame
    y       Frame
    v       Frame
    w       Frame
    <<U1>   <object>
    >>> y1.roll(1)
    <Yarn>
    <Index>
    x       Frame
    y       Frame
    v       Frame
    w       Frame
    <<U1>   <object>
    >>> y1.roll(1, include_index=True)
    <Yarn>
    <Index>
    w       Frame
    x       Frame
    y       Frame
    v       Frame
    <<U1>   <object>

    ```

Yarn.shift(*shift*, */*, *\**, *fill\_value*)[[source]](../_modules/static_frame/core/yarn.md#Yarn.shift)[](#static_frame.Yarn.shift "Link to this definition")
:   Return a [`Yarn`](yarn-selector.md#Yarn "Yarn") with values shifted forward on the index (with a positive shift) or backward on the index (with a negative shift).

    Parameters:
    :   * **shift** – Positive or negative integer shift.
        * **fill\_value** – Value to be used to fill data missing after the shift.

    Returns:
    :   [`Yarn`](yarn-selector.md#Yarn "Yarn")

    ```
    >>> y1 = sf.Yarn.from_buses((sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i'), sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')), retain_labels=False)
    >>> y1
    <Yarn>
    <Index>
    x       Frame
    y       Frame
    v       Frame
    w       Frame
    <<U1>   <object>
    >>> y1.shift(1, fill_value=None)
    NotImplementedError('A `Yarn` cannot be shifted as newly created missing values cannot be filled without replacing stored `Bus`.')

    ```

Yarn.sort\_index(*\**, *ascending=True*, *kind='mergesort'*, *key=None*)[[source]](../_modules/static_frame/core/yarn.md#Yarn.sort_index)[](#static_frame.Yarn.sort_index "Link to this definition")
:   Return a new Yarn ordered by the sorted Index.

    Parameters:
    :   * **\*** –
        * **ascendings** – Boolean, or iterable of Booleans; if `True`, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is `True`.
        * **kind** – Name of the sort algorithm as passed to NumPy.
        * **key** – A function that is used to pre-process the selected columns or rows and derive new values to sort by.

    Returns:
    :   [`Yarn`](yarn-selector.md#Yarn "Yarn")

    ```
    >>> y1 = sf.Yarn.from_buses((sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i'), sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')), retain_labels=False)
    >>> y1
    <Yarn>
    <Index>
    x       Frame
    y       Frame
    v       Frame
    w       Frame
    <<U1>   <object>
    >>> y2 = y1.sort_index()
    >>> y2
    <Yarn>
    <Index>
    v       Frame
    w       Frame
    x       Frame
    y       Frame
    <<U1>   <object>

    ```

Yarn.sort\_values(*\**, *ascending=True*, *kind='mergesort'*, *key*)[[source]](../_modules/static_frame/core/yarn.md#Yarn.sort_values)[](#static_frame.Yarn.sort_values "Link to this definition")
:   Return a new Yarn ordered by the sorted values. Note that as a Yarn contains Frames, a key argument must be provided to extract a sortable value, and this key function will process a [`Series`](series-selector.md#Series "Series") of [`Frame`](frame-selector.md#Frame "Frame").

    Parameters:
    :   * **\*** –
        * **ascending** – If True, sort in ascending order; if False, sort in descending order.
        * **kind** – Name of the sort algorithm as passed to NumPy.
        * **key** – A function that is used to pre-process the selected columns or rows and derive new values to sort by.

    Returns:
    :   [`Yarn`](yarn-selector.md#Yarn "Yarn")

    ```
    >>> y1 = sf.Yarn.from_buses((sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i'), sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')), retain_labels=False)
    >>> y1
    <Yarn>
    <Index>
    x       Frame
    y       Frame
    v       Frame
    w       Frame
    <<U1>   <object>
    >>> y1.sort_values(key=lambda y: np.array([f.size for f in y.iter_element()]))
    <Yarn>
    <Index>
    x       Frame
    y       Frame
    v       Frame
    w       Frame
    <<U1>   <object>

    ```

Yarn.tail(*count=5*, */*)[[source]](../_modules/static_frame/core/yarn.md#Yarn.tail)[](#static_frame.Yarn.tail "Link to this definition")
:   Return a [`Yarn`](yarn-selector.md#Yarn "Yarn") consisting only of the bottom elements as specified by `count`.
    :   s

    Parameters:
    :   **count** – Number of elements to be returned from the bottom of the [`Yarn`](yarn-selector.md#Yarn "Yarn")

    Returns:
    :   [`Yarn`](yarn-selector.md#Yarn "Yarn")

    ```
    >>> b1 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i')
    >>> b2 = sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')
    >>> y = sf.Yarn.from_buses((b1, b2), retain_labels=False)
    >>> y
    <Yarn>
    <Index>
    x       Frame
    y       Frame
    v       Frame
    w       Frame
    <<U1>   <object>
    >>> y.tail(2)
    <Yarn>
    <Index>
    v       Frame
    w       Frame
    <<U1>   <object>

    ```

Yarn.unpersist()[[source]](../_modules/static_frame/core/yarn.md#Yarn.unpersist)[](#static_frame.Yarn.unpersist "Link to this definition")
:   For the [`Bus`](bus-selector.md#Bus "Bus") contained in this object, replace all loaded [`Frame`](frame-selector.md#Frame "Frame") with `FrameDeferred`.

    ```
    >>> b1 = sf.Bus.from_frames((sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x'), sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')), name='i')
    >>> b1.to_zip_npz('/tmp/b1.zip')
    >>> b2 = sf.Bus.from_frames((sf.Frame(np.arange(40, 46).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='v'), sf.Frame((np.arange(6).reshape(3,2) % 3).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='w')), name='j')
    >>> b2.to_zip_npz('/tmp/b2.zip')
    >>> b1 = sf.Bus.from_zip_npz('/tmp/b1.zip').rename('a')
    >>> b1
    <Bus: a>
    <Index>
    x        <FrameDeferred>
    y        <FrameDeferred>
    <<U1>    <object>
    >>> b2 = sf.Bus.from_zip_npz('/tmp/b2.zip').rename('b')
    >>> b2
    <Bus: b>
    <Index>
    v        <FrameDeferred>
    w        <FrameDeferred>
    <<U1>    <object>
    >>> y = sf.Yarn.from_buses((b1, b2), retain_labels=False)
    >>> y
    <Yarn>
    <Index>
    x       <FrameDeferred>
    y       <FrameDeferred>
    v       <FrameDeferred>
    w       <FrameDeferred>
    <<U1>   <object>
    >>> tuple(y.values)
    (<Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>, <Frame: y>
    <Index>    c      d      <<U1>
    <Index>
    p          False  True
    q          False  True
    r          False  True
    <<U1>      <bool> <bool>, <Frame: v>
    <Index>    a       b       <<U1>
    <Index>
    p          40      41
    q          42      43
    r          44      45
    <<U1>      <int64> <int64>, <Frame: w>
    <Index>    c      d      <<U1>
    <Index>
    p          False  True
    q          True   False
    r          True   True
    <<U1>      <bool> <bool>)
    >>> y
    <Yarn>
    <Index>
    x       Frame
    y       Frame
    v       Frame
    w       Frame
    <<U1>   <object>
    >>> y.unpersist()
    >>> y
    <Yarn>
    <Index>
    x       <FrameDeferred>
    y       <FrameDeferred>
    v       <FrameDeferred>
    w       <FrameDeferred>
    <<U1>   <object>

    ```

[Yarn](yarn.md#api-detail-yarn): [Constructor](yarn-constructor.md#api-detail-yarn-constructor) | [Exporter](yarn-exporter.md#api-detail-yarn-exporter) | [Attribute](yarn-attribute.md#api-detail-yarn-attribute) | [Method](#api-detail-yarn-method) | [Dictionary-Like](yarn-dictionary_like.md#api-detail-yarn-dictionary-like) | [Display](yarn-display.md#api-detail-yarn-display) | [Selector](yarn-selector.md#api-detail-yarn-selector) | [Iterator](yarn-iterator.md#api-detail-yarn-iterator) | [Accessor Hashlib](yarn-accessor_hashlib.md#api-detail-yarn-accessor-hashlib) | [Accessor Type Clinic](yarn-accessor_type_clinic.md#api-detail-yarn-accessor-type-clinic)

[Previous](yarn-attribute.md "Detail: Yarn: Attribute")
[Next](yarn-dictionary_like.md "Detail: Yarn: Dictionary-Like")

---

© Copyright 2025, Christopher Ariza.
Last updated on Apr 29, 2025.

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme)
provided by [Read the Docs](https://readthedocs.org).