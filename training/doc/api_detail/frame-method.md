[![Logo](../_static/sf-logo-web_icon-small.png)](../index.md)

Quick Start

* [static-frame](../readme.md)
* [License](../license.md)

Introduction

* [About StaticFrame](../intro.md)
* [Media](../intro.md#media)
* [What is New in StaticFrame](../new.md)
* [Contributing](../contributing.md)

Articles

* [Improving Code Quality with Array and DataFrame Type Hints](../articles/guard.md)
* [Type-Hinting DataFrames for Static Analysis and Runtime Validation](../articles/ftyping.md)
* [Faster DataFrame Serialization](../articles/serialize.md)
* [The Performance Advantage of No-Copy DataFrame Operations](../articles/no_copy.md)
* [Memoizing DataFrame Functions: Using Hashable DataFrames and Message Digests to Optimize Repeated Calculations](../articles/hash.md)
* [Using Higher-Order Containers to Efficiently Process 7,163 (or More) DataFrames](../articles/uhoc.md)
* [One Fill Value Is Not Enough: Preserving Columnar Types When Reindexing DataFrames](../articles/fill_value.md)
* [Ten Reasons to Use StaticFrame Instead of Pandas](../articles/upgrade.md)
* [Boring Indices & Where to Find Them: The Auto-Incremented Integer Index in StaticFrame](../articles/aiii.md)

API Overview

* [Overview: Series](../api_overview/series.md)
* [Overview: SeriesHE](../api_overview/series_he.md)
* [Overview: Frame](../api_overview/frame.md)
* [Overview: FrameGO](../api_overview/frame_go.md)
* [Overview: FrameHE](../api_overview/frame_he.md)
* [Overview: Bus](../api_overview/bus.md)
* [Overview: Batch](../api_overview/batch.md)
* [Overview: Yarn](../api_overview/yarn.md)
* [Overview: Quilt](../api_overview/quilt.md)
* [Overview: Index](../api_overview/index.md)
* [Overview: IndexGO](../api_overview/index_go.md)
* [Overview: IndexHierarchy](../api_overview/index_hierarchy.md)
* [Overview: IndexHierarchyGO](../api_overview/index_hierarchy_go.md)
* [Overview: IndexYear](../api_overview/index_year.md)
* [Overview: IndexYearGO](../api_overview/index_year_go.md)
* [Overview: IndexYearMonth](../api_overview/index_year_month.md)
* [Overview: IndexYearMonthGO](../api_overview/index_year_month_go.md)
* [Overview: IndexDate](../api_overview/index_date.md)
* [Overview: IndexDateGO](../api_overview/index_date_go.md)
* [Overview: IndexMinute](../api_overview/index_minute.md)
* [Overview: IndexMinuteGO](../api_overview/index_minute_go.md)
* [Overview: IndexHour](../api_overview/index_hour.md)
* [Overview: IndexHourGO](../api_overview/index_hour_go.md)
* [Overview: IndexSecond](../api_overview/index_second.md)
* [Overview: IndexSecondGO](../api_overview/index_second_go.md)
* [Overview: IndexMillisecond](../api_overview/index_millisecond.md)
* [Overview: IndexMillisecondGO](../api_overview/index_millisecond_go.md)
* [Overview: IndexMicrosecond](../api_overview/index_microsecond.md)
* [Overview: IndexMicrosecondGO](../api_overview/index_microsecond_go.md)
* [Overview: IndexNanosecond](../api_overview/index_nanosecond.md)
* [Overview: IndexNanosecondGO](../api_overview/index_nanosecond_go.md)
* [Overview: HLoc](../api_overview/hloc.md)
* [Overview: ILoc](../api_overview/iloc.md)
* [Overview: TypeClinic](../api_overview/type_clinic.md)
* [Overview: CallGuard](../api_overview/call_guard.md)
* [Overview: ClinicResult](../api_overview/clinic_result.md)
* [Overview: Require](../api_overview/require.md)
* [Overview: WWW](../api_overview/www.md)
* [Overview: FillValueAuto](../api_overview/fill_value_auto.md)
* [Overview: DisplayActive](../api_overview/display_active.md)
* [Overview: DisplayConfig](../api_overview/display_config.md)
* [Overview: StoreConfig](../api_overview/store_config.md)
* [Overview: StoreFilter](../api_overview/store_filter.md)
* [Overview: IndexAutoFactory](../api_overview/index_auto_factory.md)
* [Overview: IndexDefaultConstructorFactory](../api_overview/index_default_constructor_factory.md)
* [Overview: IndexAutoConstructorFactory](../api_overview/index_auto_constructor_factory.md)
* [Overview: NPZ](../api_overview/npz.md)
* [Overview: NPY](../api_overview/npy.md)
* [Overview: MemoryDisplay](../api_overview/memory_display.md)
* [Overview: Platform](../api_overview/platform.md)

API Detail

* [Detail: Series](series.md)
* [Detail: SeriesHE](series_he.md)
* [Detail: Frame](frame.md)
* [Detail: FrameGO](frame_go.md)
* [Detail: FrameHE](frame_he.md)
* [Detail: Bus](bus.md)
* [Detail: Batch](batch.md)
* [Detail: Yarn](yarn.md)
* [Detail: Quilt](quilt.md)
* [Detail: Index](index.md)
* [Detail: IndexGO](index_go.md)
* [Detail: IndexHierarchy](index_hierarchy.md)
* [Detail: IndexHierarchyGO](index_hierarchy_go.md)
* [Detail: IndexYear](index_year.md)
* [Detail: IndexYearGO](index_year_go.md)
* [Detail: IndexYearMonth](index_year_month.md)
* [Detail: IndexYearMonthGO](index_year_month_go.md)
* [Detail: IndexDate](index_date.md)
* [Detail: IndexDateGO](index_date_go.md)
* [Detail: IndexMinute](index_minute.md)
* [Detail: IndexMinuteGO](index_minute_go.md)
* [Detail: IndexHour](index_hour.md)
* [Detail: IndexHourGO](index_hour_go.md)
* [Detail: IndexSecond](index_second.md)
* [Detail: IndexSecondGO](index_second_go.md)
* [Detail: IndexMillisecond](index_millisecond.md)
* [Detail: IndexMillisecondGO](index_millisecond_go.md)
* [Detail: IndexMicrosecond](index_microsecond.md)
* [Detail: IndexMicrosecondGO](index_microsecond_go.md)
* [Detail: IndexNanosecond](index_nanosecond.md)
* [Detail: IndexNanosecondGO](index_nanosecond_go.md)
* [Detail: HLoc](hloc.md)
* [Detail: ILoc](iloc.md)
* [Detail: TypeClinic](type_clinic.md)
* [Detail: CallGuard](call_guard.md)
* [Detail: ClinicResult](clinic_result.md)
* [Detail: Require](require.md)
* [Detail: WWW](www.md)
* [Detail: FillValueAuto](fill_value_auto.md)
* [Detail: DisplayActive](display_active.md)
* [Detail: DisplayConfig](display_config.md)
* [Detail: StoreConfig](store_config.md)
* [Detail: StoreFilter](store_filter.md)
* [Detail: IndexAutoFactory](index_auto_factory.md)
* [Detail: IndexDefaultConstructorFactory](index_default_constructor_factory.md)
* [Detail: IndexAutoConstructorFactory](index_auto_constructor_factory.md)
* [Detail: NPZ](npz.md)
* [Detail: NPY](npy.md)
* [Detail: MemoryDisplay](memory_display.md)
* [Detail: Platform](platform.md)

[StaticFrame](../index.md)

* Detail: Frame: Method
* [View page source](../_sources/api_detail/frame-method.rst.txt)

[Previous](frame-attribute.md "Detail: Frame: Attribute")
[Next](frame-dictionary_like.md "Detail: Frame: Dictionary-Like")

---

# Detail: Frame: Method[](#detail-frame-method "Link to this heading")

[Overview: Frame: Method](../api_overview/frame-method.md#api-overview-frame-method)

Frame.\_\_array\_\_(*dtype=None*)[](#static_frame.Frame.__array__ "Link to this definition")
:   Support the \_\_array\_\_ interface, returning an array of values.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f.__array__()
    [[0 1]
     [2 3]
     [4 5]]

    ```

Frame.\_\_array\_ufunc\_\_(*ufunc*, *method*, *\*args*, *\*\*kwargs*)[](#static_frame.Frame.__array_ufunc__ "Link to this definition")
:   Support for NumPy elements or arrays on the left hand of binary operators.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> np.array((1, 0)) * f
    <Frame>
    <Index> a       b       <<U1>
    <Index>
    p       0       0
    q       2       0
    r       4       0
    <<U1>   <int64> <int64>

    ```

Frame.\_\_bool\_\_()[](#static_frame.Frame.__bool__ "Link to this definition")
:   Raises ValueError to prohibit ambiguous use of truthy evaluation.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> bool(f)
    ErrorNotTruthy('The truth value of a container is ambiguous. For a truthy indicator of non-empty status, use the `size` attribute.')

    ```

Frame.\_\_dataframe\_\_(*nan\_as\_null=False*, *allow\_copy=True*)[[source]](../_modules/static_frame/core/frame.md#Frame.__dataframe__)[](#static_frame.Frame.__dataframe__ "Link to this definition")
:   Return a data-frame interchange protocol compliant object. See <https://data-apis.org/dataframe-protocol/latest> for more information.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> dfi = f.__dataframe__()
    >>> tuple(dfi.get_columns())
    (<DFIColumn: shape=(3,) dtype=<i8>, <DFIColumn: shape=(3,) dtype=<i8>)

    ```

Frame.\_\_deepcopy\_\_(*memo*)[[source]](../_modules/static_frame/core/frame.md#Frame.__deepcopy__)[](#static_frame.Frame.__deepcopy__ "Link to this definition")
:   ```
    >>> import copy
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> copy.deepcopy(f)
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>

    ```

Frame.\_\_len\_\_()[[source]](../_modules/static_frame/core/frame.md#Frame.__len__)[](#static_frame.Frame.__len__ "Link to this definition")
:   Length of rows in values.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> len(f)
    3

    ```

Frame.\_\_round\_\_(*decimals=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.__round__)[](#static_frame.Frame.__round__ "Link to this definition")
:   Return a [`Frame`](frame-selector.md#Frame "Frame") rounded to the given decimals. Negative decimals round to the left of the decimal point.

    Parameters:
    :   **decimals** – number of decimals to round to.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f = sf.Frame((np.arange(6).reshape(3,2) * 4/3), index=('p', 'q', 'r'), columns=('a', 'b'), name='y')
    >>> f
    <Frame: y>
    <Index>    a                  b                  <<U1>
    <Index>
    p          0.0                1.3333333333333333
    q          2.6666666666666665 4.0
    r          5.333333333333333  6.666666666666667
    <<U1>      <float64>          <float64>
    >>> round(f, 1)
    <Frame: y>
    <Index>    a         b         <<U1>
    <Index>
    p          0.0       1.3
    q          2.7       4.0
    r          5.3       6.7
    <<U1>      <float64> <float64>

    ```

Frame.all(*axis=0*, *skipna=True*, *out=None*)[](#static_frame.Frame.all "Link to this definition")
:   Logical `and` over values along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> f = sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')
    >>> f
    <Frame: y>
    <Index>    c      d      <<U1>
    <Index>
    p          False  True
    q          False  True
    r          False  True
    <<U1>      <bool> <bool>
    >>> f.all()
    <Series>
    <Index>
    c        False
    d        True
    <<U1>    <bool>

    ```

Frame.any(*axis=0*, *skipna=True*, *out=None*)[](#static_frame.Frame.any "Link to this definition")
:   Logical `or` over values along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> f = sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')
    >>> f
    <Frame: y>
    <Index>    c      d      <<U1>
    <Index>
    p          False  True
    q          False  True
    r          False  True
    <<U1>      <bool> <bool>
    >>> f.any()
    <Series>
    <Index>
    c        False
    d        True
    <<U1>    <bool>

    ```

Frame.astype[*key*](*dtypes*, *\**, *consolidate\_blocks*)
:   astype
    :   Retype one or more columns. When used as a function, can be used to retype the entire `Frame`. Alternatively, when used as a `__getitem__` interface, loc-style column selection can be used to type one or more coloumns.

        Parameters:
        :   **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    InterfaceFrameAsType.\_\_getitem\_\_(*key*)[[source]](../_modules/static_frame/core/node_selector.md#InterfaceFrameAsType.__getitem__)
    :   Selector of columns by label.

        Parameters:
        :   **key** – A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    0          10      False  1517-01-01
    1          2       True   1517-04-01
    2          8       True   1517-12-31
    3          3       False  1517-06-30
    <int64>    <int64> <bool> <datetime64[D]>
    >>> f.astype['c'](object)
    <Frame: x>
    <Index>    a       b      c          <<U1>
    <Index>
    0          10      False  1517-01-01
    1          2       True   1517-04-01
    2          8       True   1517-12-31
    3          3       False  1517-06-30
    <int64>    <int64> <bool> <object>

    ```

Frame.astype(*dtype*, *\**, *consolidate\_blocks*)
:   astype
    :   Retype one or more columns. When used as a function, can be used to retype the entire `Frame`. Alternatively, when used as a `__getitem__` interface, loc-style column selection can be used to type one or more coloumns.

        Parameters:
        :   **dtype** – A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings (‘f8’), or a dtype instance.

    InterfaceFrameAsType.\_\_call\_\_(*dtype*, *\**, *consolidate\_blocks=False*)[[source]](../_modules/static_frame/core/node_selector.md#InterfaceFrameAsType.__call__)
    :   Apply a single `dtype` to all columns.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f.astype(float)
    <Frame: x>
    <Index>    a         b         <<U1>
    <Index>
    p          0.0       1.0
    q          2.0       3.0
    r          4.0       5.0
    <<U1>      <float64> <float64>

    ```

Frame.clip(*\**, *lower=None*, *upper=None*, *axis=None*)[[source]](../_modules/static_frame/core/frame.md#Frame.clip)[](#static_frame.Frame.clip "Link to this definition")
:   Apply a clip operation to this [`Frame`](frame-selector.md#Frame "Frame"). Note that clip operations can be applied to object types, but cannot be applied to non-numerical objects (e.g., strings, None)

    Parameters:
    :   * **lower** – value, [`Series`](series-selector.md#Series "Series"), [`Frame`](frame-selector.md#Frame "Frame")
        * **upper** – value, [`Series`](series-selector.md#Series "Series"), [`Frame`](frame-selector.md#Frame "Frame")
        * **axis** – required if `lower` or `upper` are given as a [`Series`](series-selector.md#Series "Series").

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f.clip(lower=2, upper=4)
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          2       2
    q          2       3
    r          4       4
    <<U1>      <int64> <int64>

    ```

Frame.consolidate[*key*]
:   consolidate
    :   Consolidate one or more columns. When used as a function, can be used to retype the entire `Frame`. Alternatively, when used as a `__getitem__` interface, loc-style column selection can be used to consolidate one or more coloumns.

    InterfaceConsolidate.\_\_getitem\_\_(*key*)[[source]](../_modules/static_frame/core/node_selector.md#InterfaceConsolidate.__getitem__)
    :   Return the full `Frame`, selecting with `key` a subset of columns for consolidation.

        Parameters:
        :   **key** – A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.

    ```
    >>> f1 = sf.Frame.from_fields(((0, 0, 10, 2), (20, 18, -3, 18), (0, 0, 0, 1), (False, True, True, False), (True, True, False, True)), columns=('a', 'b', 'c', 'd', 'e'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       c       d      e      <<U1>
    <Index>
    0          0       20      0       False  True
    1          0       18      0       True   True
    2          10      -3      0       True   False
    3          2       18      1       False  True
    <int64>    <int64> <int64> <int64> <bool> <bool>
    >>> f1.consolidate.status
    <Frame>
    <Index> loc   iloc    dtype    shape    ndim    owndata f_contiguous c_contiguous <<U12>
    <Index>
    0       a     0       int64    (4,)     1       True    True         True
    1       b     1       int64    (4,)     1       True    True         True
    2       c     2       int64    (4,)     1       True    True         True
    3       d     3       bool     (4,)     1       True    True         True
    4       e     4       bool     (4,)     1       True    True         True
    <int64> <<U1> <int64> <object> <object> <int64> <bool>  <bool>       <bool>
    >>> f2 = f1.consolidate['a':'c']
    >>> f2.consolidate.status
    <Frame>
    <Index> loc                  iloc              dtype    shape    ndim    owndata f_contiguous c_contiguous <<U12>
    <Index>
    0       slice(np.str_('a'... slice(0, 3, None) int64    (4, 3)   2       True    False        True
    1       d                    3                 bool     (4,)     1       True    True         True
    2       e                    4                 bool     (4,)     1       True    True         True
    <int64> <object>             <object>          <object> <object> <int64> <bool>  <bool>       <bool>

    ```

Frame.consolidate
:   consolidate
    :   Consolidate one or more columns. When used as a function, can be used to retype the entire `Frame`. Alternatively, when used as a `__getitem__` interface, loc-style column selection can be used to consolidate one or more coloumns.

    InterfaceConsolidate.\_\_call\_\_()[[source]](../_modules/static_frame/core/node_selector.md#InterfaceConsolidate.__call__)
    :   Apply consolidation to all columns.

    ```
    >>> f1 = sf.Frame.from_fields(((0, 0, 10, 2), (20, 18, -3, 18), (0, 0, 0, 1), (False, True, True, False), (True, True, False, True)), columns=('a', 'b', 'c', 'd', 'e'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       c       d      e      <<U1>
    <Index>
    0          0       20      0       False  True
    1          0       18      0       True   True
    2          10      -3      0       True   False
    3          2       18      1       False  True
    <int64>    <int64> <int64> <int64> <bool> <bool>
    >>> f1.consolidate.status
    <Frame>
    <Index> loc   iloc    dtype    shape    ndim    owndata f_contiguous c_contiguous <<U12>
    <Index>
    0       a     0       int64    (4,)     1       True    True         True
    1       b     1       int64    (4,)     1       True    True         True
    2       c     2       int64    (4,)     1       True    True         True
    3       d     3       bool     (4,)     1       True    True         True
    4       e     4       bool     (4,)     1       True    True         True
    <int64> <<U1> <int64> <object> <object> <int64> <bool>  <bool>       <bool>
    >>> f2 = f1.consolidate()
    >>> f2.consolidate.status
    <Frame>
    <Index> loc                  iloc                 dtype    shape    ndim    owndata f_contiguous c_contiguous <<U12>
    <Index>
    0       slice(np.str_('a'... slice(0, 3, None)    int64    (4, 3)   2       True    False        True
    1       slice(np.str_('d'... slice(3, None, None) bool     (4, 2)   2       True    False        True
    <int64> <object>             <object>             <object> <object> <int64> <bool>  <bool>       <bool>

    ```

Frame.consolidate.status
:   Frame.consolidate
    :   Consolidate one or more columns. When used as a function, can be used to retype the entire `Frame`. Alternatively, when used as a `__getitem__` interface, loc-style column selection can be used to consolidate one or more coloumns.

    InterfaceConsolidate.status
    :   Display consolidation status of this Frame.

    ```
    >>> f1 = sf.Frame.from_fields(((0, 0, 10, 2), (20, 18, -3, 18), (0, 0, 0, 1), (False, True, True, False), (True, True, False, True)), columns=('a', 'b', 'c', 'd', 'e'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       c       d      e      <<U1>
    <Index>
    0          0       20      0       False  True
    1          0       18      0       True   True
    2          10      -3      0       True   False
    3          2       18      1       False  True
    <int64>    <int64> <int64> <int64> <bool> <bool>
    >>> f1.consolidate.status
    <Frame>
    <Index> loc   iloc    dtype    shape    ndim    owndata f_contiguous c_contiguous <<U12>
    <Index>
    0       a     0       int64    (4,)     1       True    True         True
    1       b     1       int64    (4,)     1       True    True         True
    2       c     2       int64    (4,)     1       True    True         True
    3       d     3       bool     (4,)     1       True    True         True
    4       e     4       bool     (4,)     1       True    True         True
    <int64> <<U1> <int64> <object> <object> <int64> <bool>  <bool>       <bool>
    >>> f2 = f1.consolidate()
    >>> f2.consolidate.status
    <Frame>
    <Index> loc                  iloc                 dtype    shape    ndim    owndata f_contiguous c_contiguous <<U12>
    <Index>
    0       slice(np.str_('a'... slice(0, 3, None)    int64    (4, 3)   2       True    False        True
    1       slice(np.str_('d'... slice(3, None, None) bool     (4, 2)   2       True    False        True
    <int64> <object>             <object>             <object> <object> <int64> <bool>  <bool>       <bool>

    ```

Frame.corr(*\**, *axis=1*)[[source]](../_modules/static_frame/core/frame.md#Frame.corr)[](#static_frame.Frame.corr "Link to this definition")
:   Compute a correlation matrix.

    Parameters:
    :   **axis** – if 0, each row represents a variable, with observations as columns; if 1, each column represents a variable, with observations as rows. Defaults to 1.

    ```
    >>> f1 = sf.Frame((np.concatenate((np.arange(8) * 2, np.arange(8) ** 2)).reshape(4,4)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c', 'd'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       c       d       <<U1>
    <Index>
    p          0       2       4       6
    q          8       10      12      14
    r          0       1       4       9
    s          16      25      36      49
    <<U1>      <int64> <int64> <int64> <int64>
    >>> f1.corr()
    <Frame: x>
    <Index>    a                  b                  c                  d                  <<U1>
    <Index>
    a          1.0                0.9888513796308233 0.965581028730576  0.9340437381585037
    b          0.9888513796308233 0.9999999999999999 0.9923448088115435 0.972134396307783
    c          0.9655810287305759 0.9923448088115435 0.9999999999999999 0.9934089501944108
    d          0.9340437381585037 0.9721343963077829 0.9934089501944108 1.0
    <<U1>      <float64>          <float64>          <float64>          <float64>

    ```

Frame.count(*\**, *skipna=True*, *skipfalsy=False*, *unique=False*, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.count)[](#static_frame.Frame.count "Link to this definition")
:   Return the count of non-NA values along the provided `axis`, where 0 provides counts per column, 1 provides counts per row.

    Parameters:
    :   **axis** –

    ```
    >>> f = sf.Frame.from_items((('a', (10, 2, np.nan, 3)), ('b', ('qrs ', 'XYZ', None, None))), index=('p', 'q', 'r', 's'), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b        <<U1>
    <Index>
    p          10.0      qrs
    q          2.0       XYZ
    r          nan       None
    s          3.0       None
    <<U1>      <float64> <object>
    >>> f.count(skipna=True)
    <Series>
    <Index>
    a        3
    b        2
    <<U1>    <int64>
    >>> f.count(unique=True)
    <Series>
    <Index>
    a        3
    b        2
    <<U1>    <int64>

    ```

Frame.cov(*\**, *axis=1*, *ddof=1*)[[source]](../_modules/static_frame/core/frame.md#Frame.cov)[](#static_frame.Frame.cov "Link to this definition")
:   Compute a covariance matrix.

    Parameters:
    :   * **axis** – if 0, each row represents a variable, with observations as columns; if 1, each column represents a variable, with observations as rows. Defaults to 1.
        * **ddof** – Delta degrees of freedom, defaults to 1.

    ```
    >>> f1 = sf.Frame((np.concatenate((np.arange(8) * 2, np.arange(8) ** 2)).reshape(4,4)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c', 'd'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       c       d       <<U1>
    <Index>
    p          0       2       4       6
    q          8       10      12      14
    r          0       1       4       9
    s          16      25      36      49
    <<U1>      <int64> <int64> <int64> <int64>
    >>> f1.cov()
    <Frame: x>
    <Index>    a                  b                  c                  d                  <<U1>
    <Index>
    a          58.666666666666664 84.0               112.0              142.66666666666666
    b          84.0               123.0              166.66666666666666 215.0
    c          112.0              166.66666666666666 229.33333333333331 300.0
    d          142.66666666666666 215.0              300.0              397.66666666666663
    <<U1>      <float64>          <float64>          <float64>          <float64>

    ```

Frame.cumprod(*axis=0*, *skipna=True*)[](#static_frame.Frame.cumprod "Link to this definition")
:   Return the cumulative product over the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f.cumprod()
    <Frame>
    <Index> a       b       <<U1>
    <Index>
    p       0       1
    q       0       3
    r       0       15
    <<U1>   <int64> <int64>

    ```

Frame.cumsum(*axis=0*, *skipna=True*)[](#static_frame.Frame.cumsum "Link to this definition")
:   Return the cumulative sum over the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f.cumsum()
    <Frame>
    <Index> a       b       <<U1>
    <Index>
    p       0       1
    q       2       4
    r       6       9
    <<U1>   <int64> <int64>

    ```

Frame.drop\_duplicated(*\**, *axis=0*, *exclude\_first=False*, *exclude\_last=False*)[[source]](../_modules/static_frame/core/frame.md#Frame.drop_duplicated)[](#static_frame.Frame.drop_duplicated "Link to this definition")
:   Return a [`Frame`](frame-selector.md#Frame "Frame") with duplicated rows (axis 0) or columns (axis 1) removed. All values in the row or column are compared to determine duplication.

    Parameters:
    :   * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
        * **exclude\_first** – Boolean to select if the first duplicated value is excluded.
        * **exclude\_last** – Boolean to select if the last duplicated value is excluded.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, 2), (False, True, None, True), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b        c               <<U1>
    <Index>
    0          10.0      False    1517-01-01
    1          2.0       True     1517-04-01
    2          nan       None     NaT
    3          2.0       True     1517-04-01
    <int64>    <float64> <object> <datetime64[D]>
    >>> f.drop_duplicated()
    <Frame: x>
    <Index>    a         b        c               <<U1>
    <Index>
    0          10.0      False    1517-01-01
    2          nan       None     NaT
    <int64>    <float64> <object> <datetime64[D]>

    ```

Frame.dropfalsy(*axis=0*, *condition=<function all>*)[[source]](../_modules/static_frame/core/frame.md#Frame.dropfalsy)[](#static_frame.Frame.dropfalsy "Link to this definition")
:   Return a new Frame after removing rows (axis 0) or columns (axis 1) where any or all values are falsy. The condition is determined by a NumPy ufunc that process the Boolean array returned by `isfalsy()`; the default is `np.all`.

    Parameters:
    :   * **axis** –
        * **condition** –

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 0, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b     c               <<U1>
    <Index>
    0          10      qrs   1517-01-01
    1          2       XYZ   1517-04-01
    2          0             NaT
    3          2       123   1517-04-01
    <int64>    <int64> <<U4> <datetime64[D]>
    >>> f.dropfalsy()
    <Frame: x>
    <Index>    a       b     c               <<U1>
    <Index>
    0          10      qrs   1517-01-01
    1          2       XYZ   1517-04-01
    3          2       123   1517-04-01
    <int64>    <int64> <<U4> <datetime64[D]>

    ```

Frame.dropna(*axis=0*, *condition=<function all>*)[[source]](../_modules/static_frame/core/frame.md#Frame.dropna)[](#static_frame.Frame.dropna "Link to this definition")
:   Return a new [`Frame`](frame-selector.md#Frame "Frame") after removing rows (axis 0) or columns (axis 1) where any or all values are NA (NaN or None). The condition is determined by a NumPy ufunc that process the Boolean array returned by `isna()`; the default is `np.all`.

    Parameters:
    :   * **axis** –
        * **condition** –

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, 2), (False, True, None, True), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b        c               <<U1>
    <Index>
    0          10.0      False    1517-01-01
    1          2.0       True     1517-04-01
    2          nan       None     NaT
    3          2.0       True     1517-04-01
    <int64>    <float64> <object> <datetime64[D]>
    >>> f.dropna()
    <Frame: x>
    <Index>    a         b        c               <<U1>
    <Index>
    0          10.0      False    1517-01-01
    1          2.0       True     1517-04-01
    3          2.0       True     1517-04-01
    <int64>    <float64> <object> <datetime64[D]>

    ```

Frame.duplicated(*\**, *axis=0*, *exclude\_first=False*, *exclude\_last=False*)[[source]](../_modules/static_frame/core/frame.md#Frame.duplicated)[](#static_frame.Frame.duplicated "Link to this definition")
:   Return an axis-sized Boolean [`Series`](series-selector.md#Series "Series") that shows True for all rows (axis 0) or columns (axis 1) duplicated.

    Parameters:
    :   * **axis** – Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default.
        * **exclude\_first** – Boolean to select if the first duplicated value is excluded.
        * **exclude\_last** – Boolean to select if the last duplicated value is excluded.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, 2), (False, True, None, True), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b        c               <<U1>
    <Index>
    0          10.0      False    1517-01-01
    1          2.0       True     1517-04-01
    2          nan       None     NaT
    3          2.0       True     1517-04-01
    <int64>    <float64> <object> <datetime64[D]>
    >>> f.duplicated()
    <Series>
    <Index>
    0        False
    1        True
    2        False
    3        True
    <int64>  <bool>

    ```

Frame.equals(*other*, *\**, *compare\_name=False*, *compare\_dtype=False*, *compare\_class=False*, *skipna=True*)[[source]](../_modules/static_frame/core/frame.md#Frame.equals)[](#static_frame.Frame.equals "Link to this definition")
:   Return a `bool` from comparison to any other object.

    Parameters:
    :   * **compare\_name** – Include equality of the container’s name (and all composed containers) in the comparison.
        * **compare\_dtype** – Include equality of the container’s dtype (and all composed containers) in the comparison.
        * **compare\_class** – Include equality of the container’s class (and all composed containers) in the comparison.
        * **skipna** – If True, comparisons between missing values are equal.

    ```
    >>> f1 = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f2 = sf.Frame((np.arange(6).reshape(3,2) * 4/3), index=('p', 'q', 'r'), columns=('a', 'b'), name='y')
    >>> f2
    <Frame: y>
    <Index>    a                  b                  <<U1>
    <Index>
    p          0.0                1.3333333333333333
    q          2.6666666666666665 4.0
    r          5.333333333333333  6.666666666666667
    <<U1>      <float64>          <float64>
    >>> f1.equals(f2)
    False

    ```

Frame.fillfalsy(*value*)[[source]](../_modules/static_frame/core/frame.md#Frame.fillfalsy)[](#static_frame.Frame.fillfalsy "Link to this definition")
:   Return a new `Frame` after replacing falsy values with the supplied value.

    Parameters:
    :   **value** – Value to be used to replace missing values (NaN or None).

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 0, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b     c               <<U1>
    <Index>
    0          10      qrs   1517-01-01
    1          2       XYZ   1517-04-01
    2          0             NaT
    3          2       123   1517-04-01
    <int64>    <int64> <<U4> <datetime64[D]>
    >>> f.fillfalsy(dict(a=1, b='abc', c=np.datetime64('2022-01-10')))
    <Frame: x>
    <Index>    a       b     c               <<U1>
    <Index>
    0          10      qrs   1517-01-01
    1          2       XYZ   1517-04-01
    2          1       abc   2022-01-10
    3          2       123   1517-04-01
    <int64>    <int64> <<U4> <datetime64[D]>

    ```

Frame.fillfalsy\_backward(*limit=0*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.fillfalsy_backward)[](#static_frame.Frame.fillfalsy_backward "Link to this definition")
:   Return a new `Frame` after filling backward falsy values with the first observed value.

    Parameters:
    :   * **limit** – Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit.
        * **axis** – Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).

    ```
    >>> f = sf.Frame.from_fields(((0, 0, 10, 2), (20, 18, -3, 18), (0, 0, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          0       20      0
    1          0       18      0
    2          10      -3      0
    3          2       18      1
    <int64>    <int64> <int64> <int64>
    >>> f.fillfalsy_backward()
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          10      20      1
    1          10      18      1
    2          10      -3      1
    3          2       18      1
    <int64>    <int64> <int64> <int64>

    ```

Frame.fillfalsy\_forward(*limit=0*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.fillfalsy_forward)[](#static_frame.Frame.fillfalsy_forward "Link to this definition")
:   Return a new `Frame` after filling forward falsy values with the last observed value.

    Parameters:
    :   * **limit** – Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit.
        * **axis** – Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 0, 0), (8, 3, 8, 0), (1, 0, 0, 0)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          10      8       1
    1          2       3       0
    2          0       8       0
    3          0       0       0
    <int64>    <int64> <int64> <int64>
    >>> f.fillfalsy_forward()
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          10      8       1
    1          2       3       1
    2          2       8       1
    3          2       8       1
    <int64>    <int64> <int64> <int64>

    ```

Frame.fillfalsy\_leading(*value*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.fillfalsy_leading)[](#static_frame.Frame.fillfalsy_leading "Link to this definition")
:   Return a new `Frame` after filling leading (and only leading) falsy values with the provided `value`.

    Parameters:
    :   * **value** – Value to be used to replace missing values (NaN or None).
        * **axis** – Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).

    ```
    >>> f = sf.Frame.from_fields(((0, 0, 10, 2), (20, 18, -3, 18), (0, 0, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          0       20      0
    1          0       18      0
    2          10      -3      0
    3          2       18      1
    <int64>    <int64> <int64> <int64>
    >>> f.fillfalsy_leading(-1)
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          -1      20      -1
    1          -1      18      -1
    2          10      -3      -1
    3          2       18      1
    <int64>    <int64> <int64> <int64>

    ```

Frame.fillfalsy\_trailing(*value*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.fillfalsy_trailing)[](#static_frame.Frame.fillfalsy_trailing "Link to this definition")
:   Return a new `Frame` after filling trailing (and only trailing) falsy values with the provided `value`.

    Parameters:
    :   * **value** – Value to be used to replace missing values (NaN or None).
        * **axis** – Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 0, 0), (8, 3, 8, 0), (1, 0, 0, 0)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          10      8       1
    1          2       3       0
    2          0       8       0
    3          0       0       0
    <int64>    <int64> <int64> <int64>
    >>> f.fillfalsy_trailing(-1)
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          10      8       1
    1          2       3       -1
    2          -1      8       -1
    3          -1      -1      -1
    <int64>    <int64> <int64> <int64>

    ```

Frame.fillna(*value*)[[source]](../_modules/static_frame/core/frame.md#Frame.fillna)[](#static_frame.Frame.fillna "Link to this definition")
:   Return a new `Frame` after replacing null (NaN or None) values with the supplied value.

    Parameters:
    :   **value** – Value to be used to replace missing values (NaN or None).

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b     c               <<U1>
    <Index>
    0          10.0      qrs   1517-01-01
    1          2.0       XYZ   1517-04-01
    2          nan             NaT
    3          2.0       123   1517-04-01
    <int64>    <float64> <<U4> <datetime64[D]>
    >>> f.fillna(-1)
    <Frame: x>
    <Index>    a         b     c          <<U1>
    <Index>
    0          10.0      qrs   1517-01-01
    1          2.0       XYZ   1517-04-01
    2          -1.0            -1
    3          2.0       123   1517-04-01
    <int64>    <float64> <<U4> <object>

    ```

Frame.fillna\_backward(*limit=0*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.fillna_backward)[](#static_frame.Frame.fillna_backward "Link to this definition")
:   Return a new `Frame` after filling backward null (NaN or None) with the first observed value.

    Parameters:
    :   * **limit** – Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit.
        * **axis** – Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).

    ```
    >>> f = sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y')
    >>> f
    <Frame: y>
    <Index>    a         b         c         <<U1>
    <Index>
    0          nan       nan       nan
    1          nan       8.0       nan
    2          10.0      3.0       nan
    3          2.0       8.0       1.0
    <int64>    <float64> <float64> <float64>
    >>> f.fillna_backward()
    <Frame: y>
    <Index>    a         b         c         <<U1>
    <Index>
    0          10.0      8.0       1.0
    1          10.0      8.0       1.0
    2          10.0      3.0       1.0
    3          2.0       8.0       1.0
    <int64>    <float64> <float64> <float64>

    ```

Frame.fillna\_forward(*limit=0*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.fillna_forward)[](#static_frame.Frame.fillna_forward "Link to this definition")
:   Return a new `Frame` after filling forward null (NaN or None) with the last observed value.

    Parameters:
    :   * **limit** – Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit.
        * **axis** – Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b         c         <<U1>
    <Index>
    0          10.0      8.0       1.0
    1          2.0       3.0       nan
    2          nan       8.0       nan
    3          nan       nan       nan
    <int64>    <float64> <float64> <float64>
    >>> f.fillna_forward()
    <Frame: x>
    <Index>    a         b         c         <<U1>
    <Index>
    0          10.0      8.0       1.0
    1          2.0       3.0       1.0
    2          2.0       8.0       1.0
    3          2.0       8.0       1.0
    <int64>    <float64> <float64> <float64>

    ```

Frame.fillna\_leading(*value*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.fillna_leading)[](#static_frame.Frame.fillna_leading "Link to this definition")
:   Return a new `Frame` after filling leading (and only leading) null (NaN or None) with the provided `value`.

    Parameters:
    :   * **value** – Value to be used to replace missing values (NaN or None).
        * **axis** – Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).

    ```
    >>> f = sf.Frame.from_fields(((np.nan, np.nan, 10, 2), (np.nan, 8, 3, 8), (np.nan, np.nan, np.nan, 1)), columns=('a', 'b', 'c'), name='y')
    >>> f
    <Frame: y>
    <Index>    a         b         c         <<U1>
    <Index>
    0          nan       nan       nan
    1          nan       8.0       nan
    2          10.0      3.0       nan
    3          2.0       8.0       1.0
    <int64>    <float64> <float64> <float64>
    >>> f.fillna_leading(-1)
    <Frame: y>
    <Index>    a         b         c         <<U1>
    <Index>
    0          -1.0      -1.0      -1.0
    1          -1.0      8.0       -1.0
    2          10.0      3.0       -1.0
    3          2.0       8.0       1.0
    <int64>    <float64> <float64> <float64>

    ```

Frame.fillna\_trailing(*value*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.fillna_trailing)[](#static_frame.Frame.fillna_trailing "Link to this definition")
:   Return a new `Frame` after filling trailing (and only trailing) null (NaN or None) with the provided `value`.

    Parameters:
    :   * **value** – Value to be used to replace missing values (NaN or None).
        * **axis** – Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b         c         <<U1>
    <Index>
    0          10.0      8.0       1.0
    1          2.0       3.0       nan
    2          nan       8.0       nan
    3          nan       nan       nan
    <int64>    <float64> <float64> <float64>
    >>> f.fillna_trailing(-1)
    <Frame: x>
    <Index>    a         b         c         <<U1>
    <Index>
    0          10.0      8.0       1.0
    1          2.0       3.0       -1.0
    2          -1.0      8.0       -1.0
    3          -1.0      -1.0      -1.0
    <int64>    <float64> <float64> <float64>

    ```

Frame.head(*count=5*)[[source]](../_modules/static_frame/core/frame.md#Frame.head)[](#static_frame.Frame.head "Link to this definition")
:   Return a [`Frame`](frame-selector.md#Frame "Frame") consisting only of the top elements as specified by `count`.

    Parameters:
    :   **count** – Number of elements to be returned from the top of the [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    0          10      False  1517-01-01
    1          2       True   1517-04-01
    2          8       True   1517-12-31
    3          3       False  1517-06-30
    <int64>    <int64> <bool> <datetime64[D]>
    >>> f.head(2)
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    0          10      False  1517-01-01
    1          2       True   1517-04-01
    <int64>    <int64> <bool> <datetime64[D]>

    ```

Frame.iloc\_max(*\**, *skipna=True*, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.iloc_max)[](#static_frame.Frame.iloc_max "Link to this definition")
:   Return the integer indices corresponding to the maximum values found.

    Parameters:
    :   * **skipna** – if True, NaN or None values will be ignored; if False, a found NaN will propagate.
        * **axis** – Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b         c         <<U1>
    <Index>
    0          10.0      8.0       1.0
    1          2.0       3.0       nan
    2          nan       8.0       nan
    3          nan       nan       nan
    <int64>    <float64> <float64> <float64>
    >>> f.iloc_max()
    <Series>
    <Index>
    a        0
    b        0
    c        0
    <<U1>    <int64>

    ```

Frame.iloc\_min(*\**, *skipna=True*, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.iloc_min)[](#static_frame.Frame.iloc_min "Link to this definition")
:   Return the integer indices corresponding to the minimum values found.

    Parameters:
    :   * **skipna** – if True, NaN or None values will be ignored; if False, a found NaN will propagate.
        * **axis** – Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b         c         <<U1>
    <Index>
    0          10.0      8.0       1.0
    1          2.0       3.0       nan
    2          nan       8.0       nan
    3          nan       nan       nan
    <int64>    <float64> <float64> <float64>
    >>> f.iloc_min()
    <Series>
    <Index>
    a        1
    b        1
    c        0
    <<U1>    <int64>

    ```

Frame.iloc\_notfalsy\_first(*\**, *fill\_value=-1*, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.iloc_notfalsy_first)[](#static_frame.Frame.iloc_notfalsy_first "Link to this definition")
:   Return the position corresponding to the first non-falsy (including nan) values along the selected axis.

    Parameters:
    :   * **{skipna}** –
        * **{axis}** –

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iloc_notfalsy_first(axis=0)
    <Series>
    <Index>
    a        0
    b        0
    c        0
    <<U1>    <int64>
    >>> f.iloc_notfalsy_first(axis=1)
    <Series>
    <Index>
    p        0
    q        0
    r        1
    s        2
    <<U1>    <int64>

    ```

Frame.iloc\_notfalsy\_last(*\**, *fill\_value=-1*, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.iloc_notfalsy_last)[](#static_frame.Frame.iloc_notfalsy_last "Link to this definition")
:   Return the position corresponding to the last non-falsy (including nan) values along the selected axis.

    Parameters:
    :   * **{skipna}** –
        * **{axis}** –

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.iloc_notfalsy_last(axis=0)
    <Series>
    <Index>
    a        1
    b        2
    c        3
    <<U1>    <int64>
    >>> f.iloc_notfalsy_last(axis=1)
    <Series>
    <Index>
    p        2
    q        1
    r        2
    s        2
    <<U1>    <int64>

    ```

Frame.iloc\_notna\_first(*\**, *fill\_value=-1*, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.iloc_notna_first)[](#static_frame.Frame.iloc_notna_first "Link to this definition")
:   Return the position corresponding to the first non-missing values along the selected axis.

    Parameters:
    :   * **{skipna}** –
        * **{axis}** –

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b         c         <<U1>
    <Index>
    0          10.0      8.0       1.0
    1          2.0       3.0       nan
    2          nan       8.0       nan
    3          nan       nan       nan
    <int64>    <float64> <float64> <float64>
    >>> f.iloc_notna_first(axis=0)
    <Series>
    <Index>
    a        0
    b        0
    c        0
    <<U1>    <int64>
    >>> f.iloc_notna_first(axis=1)
    <Series>
    <Index>
    0        0
    1        0
    2        1
    3        -1
    <int64>  <int64>

    ```

Frame.iloc\_notna\_last(*\**, *fill\_value=-1*, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.iloc_notna_last)[](#static_frame.Frame.iloc_notna_last "Link to this definition")
:   Return the position corresponding to the last non-missing values along the selected axis.

    Parameters:
    :   * **{skipna}** –
        * **{axis}** –

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b         c         <<U1>
    <Index>
    0          10.0      8.0       1.0
    1          2.0       3.0       nan
    2          nan       8.0       nan
    3          nan       nan       nan
    <int64>    <float64> <float64> <float64>
    >>> f.iloc_notna_last(axis=0)
    <Series>
    <Index>
    a        1
    b        2
    c        0
    <<U1>    <int64>
    >>> f.iloc_notna_last(axis=1)
    <Series>
    <Index>
    0        2
    1        1
    2        1
    3        -1
    <int64>  <int64>

    ```

Frame.insert\_after(*key*, *container*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/frame.md#Frame.insert_after)[](#static_frame.Frame.insert_after "Link to this definition")
:   Create a new [`Frame`](frame-selector.md#Frame "Frame") by inserting a named [`Series`](series-selector.md#Series "Series") or [`Frame`](frame-selector.md#Frame "Frame") at the position after the label specified by `key`.

    Parameters:
    :   * **key** – Label after which the new container will be inserted.
        * **container** – Container to be inserted.
        * **fill\_value** – A value to be used to fill space after reindexing the new container.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f1 = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f2 = sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')
    >>> f2
    <Frame: y>
    <Index>    c      d      <<U1>
    <Index>
    p          False  True
    q          False  True
    r          False  True
    <<U1>      <bool> <bool>
    >>> f1.insert_after('b', f2)
    <Frame: x>
    <Index>    a       b       c      d      <<U1>
    <Index>
    p          0       1       False  True
    q          2       3       False  True
    r          4       5       False  True
    <<U1>      <int64> <int64> <bool> <bool>

    ```

Frame.insert\_before(*key*, *container*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/frame.md#Frame.insert_before)[](#static_frame.Frame.insert_before "Link to this definition")
:   Create a new [`Frame`](frame-selector.md#Frame "Frame") by inserting a named [`Series`](series-selector.md#Series "Series") or [`Frame`](frame-selector.md#Frame "Frame") at the position before the label specified by `key`.

    Parameters:
    :   * **key** – Label before which the new container will be inserted.
        * **container** – Container to be inserted.
        * **fill\_value** – A value to be used to fill space after reindexing the new container.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f1 = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f2 = sf.Frame((np.arange(6).reshape(3,2) % 2).astype(bool), index=('p', 'q', 'r'), columns=('c', 'd'), name='y')
    >>> f2
    <Frame: y>
    <Index>    c      d      <<U1>
    <Index>
    p          False  True
    q          False  True
    r          False  True
    <<U1>      <bool> <bool>
    >>> f1.insert_before('b', f2)
    <Frame: x>
    <Index>    a       c      d      b       <<U1>
    <Index>
    p          0       False  True   1
    q          2       False  True   3
    r          4       False  True   5
    <<U1>      <int64> <bool> <bool> <int64>

    ```

Frame.isfalsy()[[source]](../_modules/static_frame/core/frame.md#Frame.isfalsy)[](#static_frame.Frame.isfalsy "Link to this definition")
:   Return a same-indexed, Boolean Frame indicating True which values are falsy.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 0, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b     c               <<U1>
    <Index>
    0          10      qrs   1517-01-01
    1          2       XYZ   1517-04-01
    2          0             NaT
    3          2       123   1517-04-01
    <int64>    <int64> <<U4> <datetime64[D]>
    >>> f.isfalsy()
    <Frame>
    <Index> a      b      c      <<U1>
    <Index>
    0       False  False  False
    1       False  False  False
    2       True   True   True
    3       False  False  False
    <int64> <bool> <bool> <bool>

    ```

Frame.isin(*other*)[[source]](../_modules/static_frame/core/frame.md#Frame.isin)[](#static_frame.Frame.isin "Link to this definition")
:   Return a same-sized Boolean [`Frame`](frame-selector.md#Frame "Frame") that shows if the same-positioned element is in the passed iterable.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 0, 0), (8, 3, 8, 0), (1, 0, 0, 0)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          10      8       1
    1          2       3       0
    2          0       8       0
    3          0       0       0
    <int64>    <int64> <int64> <int64>
    >>> f.isin((0, 8))
    <Frame: x>
    <Index>    a      b      c      <<U1>
    <Index>
    0          False  True   False
    1          False  False  True
    2          True   True   True
    3          True   True   True
    <int64>    <bool> <bool> <bool>

    ```

Frame.isna()[[source]](../_modules/static_frame/core/frame.md#Frame.isna)[](#static_frame.Frame.isna "Link to this definition")
:   Return a same-indexed, Boolean Frame indicating True which values are NaN or None.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b         c         <<U1>
    <Index>
    0          10.0      8.0       1.0
    1          2.0       3.0       nan
    2          nan       8.0       nan
    3          nan       nan       nan
    <int64>    <float64> <float64> <float64>
    >>> f.isna()
    <Frame>
    <Index> a      b      c      <<U1>
    <Index>
    0       False  False  False
    1       False  False  True
    2       True   False  True
    3       True   True   True
    <int64> <bool> <bool> <bool>

    ```

Frame.join\_inner(*other*, *\**, *left\_depth\_level=None*, *left\_columns=None*, *right\_depth\_level=None*, *right\_columns=None*, *left\_template='{}'*, *right\_template='{}'*, *fill\_value=nan*, *include\_index=False*)[[source]](../_modules/static_frame/core/frame.md#Frame.join_inner)[](#static_frame.Frame.join_inner "Link to this definition")
:   Perform an inner join.

    Parameters:
    :   * **left\_depth\_level** – Specify one or more left index depths to include in the join predicate.
        * **left\_columns** – Specify one or more left columns to include in the join predicate.
        * **right\_depth\_level** – Specify one or more right index depths to include in the join predicate.
        * **right\_columns** – Specify one or more right columns to include in the join predicate.
        * **left\_template** – Provide a format string for naming left columns in the joined result.
        * **right\_template** – Provide a format string for naming right columns in the joined result.
        * **fill\_value** – A value to be used to fill space created in the join.
        * **True** (*If*) –
        * **Frame.** (*and appropriate index will be returned in the resultant*) –

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f1 = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f2 = sf.Frame.from_fields(((2, 7), (3, 8), (1, 0)), columns=('d', 'e', 'f'), name='y')
    >>> f2
    <Frame: y>
    <Index>    d       e       f       <<U1>
    <Index>
    0          2       3       1
    1          7       8       0
    <int64>    <int64> <int64> <int64>
    >>> f1.join_inner(f2, left_columns='c', right_columns='f')
    <Frame>
    <Index> a       b       c       d       e       f       <<U1>
    <Index>
    0       11      0       0       7       8       0
    1       4       8       1       2       3       1
    2       10      3       0       7       8       0
    3       2       8       1       2       3       1
    <int64> <int64> <int64> <int64> <int64> <int64> <int64>

    ```

Frame.join\_left(*other*, *\**, *left\_depth\_level=None*, *left\_columns=None*, *right\_depth\_level=None*, *right\_columns=None*, *left\_template='{}'*, *right\_template='{}'*, *fill\_value=nan*, *include\_index=False*)[[source]](../_modules/static_frame/core/frame.md#Frame.join_left)[](#static_frame.Frame.join_left "Link to this definition")
:   Perform a left outer join.

    Parameters:
    :   * **left\_depth\_level** – Specify one or more left index depths to include in the join predicate.
        * **left\_columns** – Specify one or more left columns to include in the join predicate.
        * **right\_depth\_level** – Specify one or more right index depths to include in the join predicate.
        * **right\_columns** – Specify one or more right columns to include in the join predicate.
        * **left\_template** – Provide a format string for naming left columns in the joined result.
        * **right\_template** – Provide a format string for naming right columns in the joined result.
        * **fill\_value** – A value to be used to fill space created in the join.
        * **True** (*If*) –
        * **Frame.** (*and appropriate index will be returned in the resultant*) –

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f1 = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f2 = sf.Frame.from_fields(((2, 7), (3, 8), (1, 0)), columns=('d', 'e', 'f'), name='y')
    >>> f2
    <Frame: y>
    <Index>    d       e       f       <<U1>
    <Index>
    0          2       3       1
    1          7       8       0
    <int64>    <int64> <int64> <int64>
    >>> f1.join_left(f2, left_columns='c', right_columns='f')
    <Frame>
    <Index> a       b       c       d       e       f       <<U1>
    <Index>
    0       11      0       0       7       8       0
    1       4       8       1       2       3       1
    2       10      3       0       7       8       0
    3       2       8       1       2       3       1
    <int64> <int64> <int64> <int64> <int64> <int64> <int64>

    ```

Frame.join\_outer(*other*, *\**, *left\_depth\_level=None*, *left\_columns=None*, *right\_depth\_level=None*, *right\_columns=None*, *left\_template='{}'*, *right\_template='{}'*, *fill\_value=nan*, *include\_index=False*)[[source]](../_modules/static_frame/core/frame.md#Frame.join_outer)[](#static_frame.Frame.join_outer "Link to this definition")
:   Perform an outer join.

    Parameters:
    :   * **left\_depth\_level** – Specify one or more left index depths to include in the join predicate.
        * **left\_columns** – Specify one or more left columns to include in the join predicate.
        * **right\_depth\_level** – Specify one or more right index depths to include in the join predicate.
        * **right\_columns** – Specify one or more right columns to include in the join predicate.
        * **left\_template** – Provide a format string for naming left columns in the joined result.
        * **right\_template** – Provide a format string for naming right columns in the joined result.
        * **fill\_value** – A value to be used to fill space created in the join.
        * **True** (*If*) –
        * **Frame.** (*and appropriate index will be returned in the resultant*) –

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f1 = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f2 = sf.Frame.from_fields(((2, 7), (3, 8), (1, 0)), columns=('d', 'e', 'f'), name='y')
    >>> f2
    <Frame: y>
    <Index>    d       e       f       <<U1>
    <Index>
    0          2       3       1
    1          7       8       0
    <int64>    <int64> <int64> <int64>
    >>> f1.join_outer(f2, left_columns='c', right_columns='f')
    <Frame>
    <Index> a       b       c       d       e       f       <<U1>
    <Index>
    0       11      0       0       7       8       0
    1       4       8       1       2       3       1
    2       10      3       0       7       8       0
    3       2       8       1       2       3       1
    <int64> <int64> <int64> <int64> <int64> <int64> <int64>

    ```

Frame.join\_right(*other*, *\**, *left\_depth\_level=None*, *left\_columns=None*, *right\_depth\_level=None*, *right\_columns=None*, *left\_template='{}'*, *right\_template='{}'*, *fill\_value=nan*, *include\_index=False*)[[source]](../_modules/static_frame/core/frame.md#Frame.join_right)[](#static_frame.Frame.join_right "Link to this definition")
:   Perform a right outer join.

    Parameters:
    :   * **left\_depth\_level** – Specify one or more left index depths to include in the join predicate.
        * **left\_columns** – Specify one or more left columns to include in the join predicate.
        * **right\_depth\_level** – Specify one or more right index depths to include in the join predicate.
        * **right\_columns** – Specify one or more right columns to include in the join predicate.
        * **left\_template** – Provide a format string for naming left columns in the joined result.
        * **right\_template** – Provide a format string for naming right columns in the joined result.
        * **fill\_value** – A value to be used to fill space created in the join.
        * **True** (*If*) –
        * **Frame.** (*and appropriate index will be returned in the resultant*) –

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f1 = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f2 = sf.Frame.from_fields(((2, 7), (3, 8), (1, 0)), columns=('d', 'e', 'f'), name='y')
    >>> f2
    <Frame: y>
    <Index>    d       e       f       <<U1>
    <Index>
    0          2       3       1
    1          7       8       0
    <int64>    <int64> <int64> <int64>
    >>> f1.join_right(f2, left_columns='c', right_columns='f')
    <Frame>
    <Index> a       b       c       d       e       f       <<U1>
    <Index>
    0       4       8       1       2       3       1
    1       2       8       1       2       3       1
    2       11      0       0       7       8       0
    3       10      3       0       7       8       0
    <int64> <int64> <int64> <int64> <int64> <int64> <int64>

    ```

Frame.loc\_max(*\**, *skipna=True*, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.loc_max)[](#static_frame.Frame.loc_max "Link to this definition")
:   Return the labels corresponding to the maximum values found.

    Parameters:
    :   * **skipna** – if True, NaN or None values will be ignored; if False, a found NaN will propagate.
        * **axis** – Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b         c         <<U1>
    <Index>
    0          10.0      8.0       1.0
    1          2.0       3.0       nan
    2          nan       8.0       nan
    3          nan       nan       nan
    <int64>    <float64> <float64> <float64>
    >>> f.loc_max()
    <Series>
    <Index>
    a        0
    b        0
    c        0
    <<U1>    <int64>

    ```

Frame.loc\_min(*\**, *skipna=True*, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.loc_min)[](#static_frame.Frame.loc_min "Link to this definition")
:   Return the labels corresponding to the minimum value found.

    Parameters:
    :   * **skipna** – if True, NaN or None values will be ignored; if False, a found NaN will propagate.
        * **axis** – Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b         c         <<U1>
    <Index>
    0          10.0      8.0       1.0
    1          2.0       3.0       nan
    2          nan       8.0       nan
    3          nan       nan       nan
    <int64>    <float64> <float64> <float64>
    >>> f.loc_min()
    <Series>
    <Index>
    a        1
    b        1
    c        0
    <<U1>    <int64>

    ```

Frame.loc\_notfalsy\_first(*\**, *fill\_value=nan*, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.loc_notfalsy_first)[](#static_frame.Frame.loc_notfalsy_first "Link to this definition")
:   Return the labels corresponding to the first non-falsy (including nan) values along the selected axis.

    Parameters:
    :   * **{skipna}** –
        * **{axis}** –

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.loc_notfalsy_first(axis=0)
    <Series>
    <Index>
    a        p
    b        p
    c        p
    <<U1>    <<U1>
    >>> f.loc_notfalsy_first(axis=1)
    <Series>
    <Index>
    p        a
    q        a
    r        b
    s        c
    <<U1>    <<U1>

    ```

Frame.loc\_notfalsy\_last(*\**, *fill\_value=nan*, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.loc_notfalsy_last)[](#static_frame.Frame.loc_notfalsy_last "Link to this definition")
:   Return the labels corresponding to the last non-falsy (including nan) values along the selected axis.

    Parameters:
    :   * **{skipna}** –
        * **{axis}** –

    ```
    >>> f = sf.Frame.from_fields(((10, -2, 0, 0), (8, -3, 8, 0), (1, 0, 9, 12)), index=('p', 'q', 'r', 's'), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    p          10      8       1
    q          -2      -3      0
    r          0       8       9
    s          0       0       12
    <<U1>      <int64> <int64> <int64>
    >>> f.loc_notfalsy_last(axis=0)
    <Series>
    <Index>
    a        q
    b        r
    c        s
    <<U1>    <<U1>
    >>> f.loc_notfalsy_last(axis=1)
    <Series>
    <Index>
    p        c
    q        b
    r        c
    s        c
    <<U1>    <<U1>

    ```

Frame.loc\_notna\_first(*\**, *fill\_value=nan*, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.loc_notna_first)[](#static_frame.Frame.loc_notna_first "Link to this definition")
:   Return the labels corresponding to the first non-missing values along the selected axis.

    Parameters:
    :   * **{skipna}** –
        * **{axis}** –

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b         c         <<U1>
    <Index>
    0          10.0      8.0       1.0
    1          2.0       3.0       nan
    2          nan       8.0       nan
    3          nan       nan       nan
    <int64>    <float64> <float64> <float64>
    >>> f.loc_notna_first(axis=0)
    <Series>
    <Index>
    a        0
    b        0
    c        0
    <<U1>    <int64>
    >>> f.loc_notna_first(axis=1)
    <Series>
    <Index>
    0        a
    1        a
    2        b
    3        nan
    <int64>  <object>

    ```

Frame.loc\_notna\_last(*\**, *fill\_value=nan*, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.loc_notna_last)[](#static_frame.Frame.loc_notna_last "Link to this definition")
:   Return the labels corresponding to the last non-missing values along the selected axis.

    Parameters:
    :   * **{skipna}** –
        * **{axis}** –

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b         c         <<U1>
    <Index>
    0          10.0      8.0       1.0
    1          2.0       3.0       nan
    2          nan       8.0       nan
    3          nan       nan       nan
    <int64>    <float64> <float64> <float64>
    >>> f.loc_notna_last(axis=0)
    <Series>
    <Index>
    a        1
    b        2
    c        0
    <<U1>    <int64>
    >>> f.loc_notna_last(axis=1)
    <Series>
    <Index>
    0        c
    1        b
    2        b
    3        nan
    <int64>  <object>

    ```

Frame.max(*axis=0*, *skipna=True*, *out=None*)[](#static_frame.Frame.max "Link to this definition")
:   Return the maximum along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f.max()
    <Series>
    <Index>
    a        4
    b        5
    <<U1>    <int64>

    ```

Frame.mean(*axis=0*, *skipna=True*, *out=None*)[](#static_frame.Frame.mean "Link to this definition")
:   Return the mean along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f.mean()
    <Series>
    <Index>
    a        2.0
    b        3.0
    <<U1>    <float64>

    ```

Frame.median(*axis=0*, *skipna=True*, *out=None*)[](#static_frame.Frame.median "Link to this definition")
:   Return the median along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f.median()
    <Series>
    <Index>
    a        2.0
    b        3.0
    <<U1>    <float64>

    ```

Frame.merge\_inner(*other*, *\**, *left\_depth\_level=None*, *left\_columns=None*, *right\_depth\_level=None*, *right\_columns=None*, *merge\_labels=None*, *left\_template='{}'*, *right\_template='{}'*, *fill\_value=nan*, *include\_index=False*)[[source]](../_modules/static_frame/core/frame.md#Frame.merge_inner)[](#static_frame.Frame.merge_inner "Link to this definition")
:   Perform an inner merge, an inner join where matched columns are coalesced.

    Parameters:
    :   * **left\_depth\_level** – Specify one or more left index depths to include in the join predicate.
        * **left\_columns** – Specify one or more left columns to include in the join predicate.
        * **right\_depth\_level** – Specify one or more right index depths to include in the join predicate.
        * **right\_columns** – Specify one or more right columns to include in the join predicate.
        * **provided** (*Provide a sequence* *of* *labels to be used for the merge fields. Must have a length equal to left and right selections. If not*) –
        * **left.** (*merge fields will be named from the*) –
        * **left\_template** – Provide a format string for naming left columns in the joined result.
        * **right\_template** – Provide a format string for naming right columns in the joined result.
        * **fill\_value** – A value to be used to fill space created in the join.
        * **True** (*If*) –
        * **Frame.** (*and appropriate index will be returned in the resultant*) –

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f1 = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f2 = sf.Frame.from_fields(((2, 7), (3, 8), (1, 0)), columns=('d', 'e', 'f'), name='y')
    >>> f2
    <Frame: y>
    <Index>    d       e       f       <<U1>
    <Index>
    0          2       3       1
    1          7       8       0
    <int64>    <int64> <int64> <int64>
    >>> f1.merge_inner(f2, left_columns='c', right_columns='f')
    <Frame>
    <Index> c       a       b       d       e       <<U1>
    <Index>
    0       0       11      0       7       8
    1       1       4       8       2       3
    2       0       10      3       7       8
    3       1       2       8       2       3
    <int64> <int64> <int64> <int64> <int64> <int64>

    ```

Frame.merge\_left(*other*, *\**, *left\_depth\_level=None*, *left\_columns=None*, *right\_depth\_level=None*, *right\_columns=None*, *merge\_labels=None*, *left\_template='{}'*, *right\_template='{}'*, *fill\_value=nan*, *include\_index=False*)[[source]](../_modules/static_frame/core/frame.md#Frame.merge_left)[](#static_frame.Frame.merge_left "Link to this definition")
:   Perform a left merge, a left join where matched columns are coalesced.

    Parameters:
    :   * **left\_depth\_level** – Specify one or more left index depths to include in the join predicate.
        * **left\_columns** – Specify one or more left columns to include in the join predicate.
        * **right\_depth\_level** – Specify one or more right index depths to include in the join predicate.
        * **right\_columns** – Specify one or more right columns to include in the join predicate.
        * **provided** (*Provide a sequence* *of* *labels to be used for the merge fields. Must have a length equal to left and right selections. If not*) –
        * **left.** (*merge fields will be named from the*) –
        * **left\_template** – Provide a format string for naming left columns in the joined result.
        * **right\_template** – Provide a format string for naming right columns in the joined result.
        * **fill\_value** – A value to be used to fill space created in the join.
        * **True** (*If*) –
        * **Frame.** (*and appropriate index will be returned in the resultant*) –

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f1 = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f2 = sf.Frame.from_fields(((2, 7), (3, 8), (1, 0)), columns=('d', 'e', 'f'), name='y')
    >>> f2
    <Frame: y>
    <Index>    d       e       f       <<U1>
    <Index>
    0          2       3       1
    1          7       8       0
    <int64>    <int64> <int64> <int64>
    >>> f1.merge_left(f2, left_columns='c', right_columns='f', merge_labels='x')
    <Frame>
    <Index> x       a       b       d       e       <<U1>
    <Index>
    0       0       11      0       7       8
    1       1       4       8       2       3
    2       0       10      3       7       8
    3       1       2       8       2       3
    <int64> <int64> <int64> <int64> <int64> <int64>

    ```

Frame.merge\_outer(*other*, *\**, *left\_depth\_level=None*, *left\_columns=None*, *right\_depth\_level=None*, *right\_columns=None*, *merge\_labels=None*, *left\_template='{}'*, *right\_template='{}'*, *fill\_value=nan*, *include\_index=False*)[[source]](../_modules/static_frame/core/frame.md#Frame.merge_outer)[](#static_frame.Frame.merge_outer "Link to this definition")
:   Perform an outer merge, an outer join where matched columns are coalesced.

    Parameters:
    :   * **left\_depth\_level** – Specify one or more left index depths to include in the join predicate.
        * **left\_columns** – Specify one or more left columns to include in the join predicate.
        * **right\_depth\_level** – Specify one or more right index depths to include in the join predicate.
        * **right\_columns** – Specify one or more right columns to include in the join predicate.
        * **provided** (*Provide a sequence* *of* *labels to be used for the merge fields. Must have a length equal to left and right selections. If not*) –
        * **left.** (*merge fields will be named from the*) –
        * **left\_template** – Provide a format string for naming left columns in the joined result.
        * **right\_template** – Provide a format string for naming right columns in the joined result.
        * **fill\_value** – A value to be used to fill space created in the join.
        * **True** (*If*) –
        * **Frame.** (*and appropriate index will be returned in the resultant*) –

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f1 = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f2 = sf.Frame.from_fields(((2, 7), (3, 8), (1, 0)), columns=('d', 'e', 'f'), name='y')
    >>> f2
    <Frame: y>
    <Index>    d       e       f       <<U1>
    <Index>
    0          2       3       1
    1          7       8       0
    <int64>    <int64> <int64> <int64>
    >>> f1.merge_outer(f2, left_columns='c', right_columns='f', merge_labels='x')
    <Frame>
    <Index> x       a       b       d       e       <<U1>
    <Index>
    0       0       11      0       7       8
    1       1       4       8       2       3
    2       0       10      3       7       8
    3       1       2       8       2       3
    <int64> <int64> <int64> <int64> <int64> <int64>

    ```

Frame.merge\_right(*other*, *\**, *left\_depth\_level=None*, *left\_columns=None*, *right\_depth\_level=None*, *right\_columns=None*, *merge\_labels=None*, *left\_template='{}'*, *right\_template='{}'*, *fill\_value=nan*, *include\_index=False*)[[source]](../_modules/static_frame/core/frame.md#Frame.merge_right)[](#static_frame.Frame.merge_right "Link to this definition")
:   Perform a right merge, a right join where matched columns are coalesced.

    Parameters:
    :   * **left\_depth\_level** – Specify one or more left index depths to include in the join predicate.
        * **left\_columns** – Specify one or more left columns to include in the join predicate.
        * **right\_depth\_level** – Specify one or more right index depths to include in the join predicate.
        * **right\_columns** – Specify one or more right columns to include in the join predicate.
        * **provided** (*Provide a sequence* *of* *labels to be used for the merge fields. Must have a length equal to left and right selections. If not*) –
        * **left.** (*merge fields will be named from the*) –
        * **left\_template** – Provide a format string for naming left columns in the joined result.
        * **right\_template** – Provide a format string for naming right columns in the joined result.
        * **fill\_value** – A value to be used to fill space created in the join.
        * **True** (*If*) –
        * **Frame.** (*and appropriate index will be returned in the resultant*) –

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f1 = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f2 = sf.Frame.from_fields(((2, 7), (3, 8), (1, 0)), columns=('d', 'e', 'f'), name='y')
    >>> f2
    <Frame: y>
    <Index>    d       e       f       <<U1>
    <Index>
    0          2       3       1
    1          7       8       0
    <int64>    <int64> <int64> <int64>
    >>> f1.merge_right(f2, left_columns='c', right_columns='f')
    <Frame>
    <Index> f       a       b       d       e       <<U1>
    <Index>
    0       1       4       8       2       3
    1       1       2       8       2       3
    2       0       11      0       7       8
    3       0       10      3       7       8
    <int64> <int64> <int64> <int64> <int64> <int64>

    ```

Frame.min(*axis=0*, *skipna=True*, *out=None*)[](#static_frame.Frame.min "Link to this definition")
:   Return the minimum along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f.min()
    <Series>
    <Index>
    a        0
    b        1
    <<U1>    <int64>

    ```

Frame.notfalsy()[[source]](../_modules/static_frame/core/frame.md#Frame.notfalsy)[](#static_frame.Frame.notfalsy "Link to this definition")
:   Return a same-indexed, Boolean Frame indicating True which values are not falsy.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 0, 2), ('qrs ', 'XYZ', '', '123'), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b     c               <<U1>
    <Index>
    0          10      qrs   1517-01-01
    1          2       XYZ   1517-04-01
    2          0             NaT
    3          2       123   1517-04-01
    <int64>    <int64> <<U4> <datetime64[D]>
    >>> f.notfalsy()
    <Frame>
    <Index> a      b      c      <<U1>
    <Index>
    0       True   True   True
    1       True   True   True
    2       False  False  False
    3       True   True   True
    <int64> <bool> <bool> <bool>

    ```

Frame.notna()[[source]](../_modules/static_frame/core/frame.md#Frame.notna)[](#static_frame.Frame.notna "Link to this definition")
:   Return a same-indexed, Boolean Frame indicating True which values are not NaN or None.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, np.nan), (8, 3, 8, np.nan), (1, np.nan, np.nan, np.nan)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b         c         <<U1>
    <Index>
    0          10.0      8.0       1.0
    1          2.0       3.0       nan
    2          nan       8.0       nan
    3          nan       nan       nan
    <int64>    <float64> <float64> <float64>
    >>> f.notna()
    <Frame>
    <Index> a      b      c      <<U1>
    <Index>
    0       True   True   True
    1       True   True   False
    2       False  True   False
    3       False  False  False
    <int64> <bool> <bool> <bool>

    ```

Frame.pivot(*index\_fields*, *columns\_fields=()*, *data\_fields=()*, *\**, *func=<function nansum>*, *fill\_value=nan*, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/frame.md#Frame.pivot)[](#static_frame.Frame.pivot "Link to this definition")
:   Produce a pivot table, where one or more columns is selected for each of index\_fields, columns\_fields, and data\_fields. Unique values from the provided `index_fields` will be used to create a new index; unique values from the provided `columns_fields` will be used to create a new columns; if one `data_fields` value is selected, that is the value that will be displayed; if more than one values is given, those values will be presented with a hierarchical index on the columns; if `data_fields` is not provided, all unused fields will be displayed.

    Parameters:
    :   * **index\_fields** –
        * **columns\_fields** –
        * **data\_fields** –
        * **\*** –
        * **fill\_value** – If the index expansion produces coordinates that have no existing data value, fill that position with this value.
        * **func** – function to apply to `data_fields`, or a dictionary of labelled functions to apply to data fields, producing an additional hierarchical level.
        * **index\_constructor** –

    ```
    >>> f1 = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f1.pivot(index_fields='b', columns_fields='c')
    <Frame>
    <Index: c> 0         1         <int64>
    <Index: b>
    0          11.0      nan
    3          10.0      nan
    8          nan       6.0
    <int64>    <float64> <float64>

    ```

Frame.pivot\_stack(*depth\_level=-1*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/frame.md#Frame.pivot_stack)[](#static_frame.Frame.pivot_stack "Link to this definition")
:   Move labels from the columns to the index, creating or extending an [`IndexHierarchy`](index_hierarchy-selector.md#IndexHierarchy "IndexHierarchy") on the index.

    Parameters:
    :   **depth\_level** – selection of columns depth or depth to move onto the index.

    ```
    >>> f1 = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f1.pivot_stack()
    <Frame: x>
    <Index>                0       <int64>
    <IndexHierarchy>
    0                a     11
    0                b     0
    0                c     0
    1                a     4
    1                b     8
    1                c     1
    2                a     10
    2                b     3
    2                c     0
    3                a     2
    3                b     8
    3                c     1
    <int64>          <<U1> <int64>

    ```

Frame.pivot\_unstack(*depth\_level=-1*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/frame.md#Frame.pivot_unstack)[](#static_frame.Frame.pivot_unstack "Link to this definition")
:   Move labels from the index to the columns, creating or extending an [`IndexHierarchy`](index_hierarchy-selector.md#IndexHierarchy "IndexHierarchy") on the columns.

    Parameters:
    :   **depth\_level** – selection of index depth or depth to move onto the columns.

    ```
    >>> f1 = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f1
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f2 = f1.pivot_stack()
    >>> f2
    <Frame: x>
    <Index>                0       <int64>
    <IndexHierarchy>
    0                a     11
    0                b     0
    0                c     0
    1                a     4
    1                b     8
    1                c     1
    2                a     10
    2                b     3
    2                c     0
    3                a     2
    3                b     8
    3                c     1
    <int64>          <<U1> <int64>
    >>> f2.pivot_unstack()
    <Frame: x>
    <IndexHierarchy> 0       0       0       <int64>
                     a       b       c       <<U1>
    <Index>
    0                11      0       0
    1                4       8       1
    2                10      3       0
    3                2       8       1
    <int64>          <int64> <int64> <int64>

    ```

Frame.prod(*axis=0*, *skipna=True*, *allna=1*, *out=None*)[](#static_frame.Frame.prod "Link to this definition")
:   Return the product along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f.prod()
    <Series>
    <Index>
    a        0
    b        15
    <<U1>    <int64>

    ```

Frame.rank\_dense(*\**, *axis=0*, *skipna=True*, *ascending=True*, *start=0*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/frame.md#Frame.rank_dense)[](#static_frame.Frame.rank_dense "Link to this definition")
:   Rank values as compactly as possible, where ties get the same value, and ranks are contiguous (potentially non-unique) integers.

    Parameters:
    :   * **axis** – Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row)
        * **skipna** – If `True`, exclude NA values (NaN or None) from ranking, replacing those values with `fill_value`.
        * **ascending** – Boolean, or iterable of Booleans; if `True`, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is `True`.
        * **start** – The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1.
        * **fill\_value** – A value to be used to fill NA values ignored in ranking when `skipna` is `True`. The default is `np.nan` but can be set to any value to force NA values to the “bottom” or “top” of a rank as needed.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.rank_dense()
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          3       0       0
    1          1       2       1
    2          2       1       0
    3          0       2       1
    <int64>    <int64> <int64> <int64>

    ```

Frame.rank\_max(*\**, *axis=0*, *skipna=True*, *ascending=True*, *start=0*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/frame.md#Frame.rank_max)[](#static_frame.Frame.rank_max "Link to this definition")
:   Rank values where tied values are assigned the maximum ordinal rank; ranks are potentially non-contiguous and non-unique integers.

    Parameters:
    :   * **axis** – Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row)
        * **skipna** – If `True`, exclude NA values (NaN or None) from ranking, replacing those values with `fill_value`.
        * **ascending** – Boolean, or iterable of Booleans; if `True`, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is `True`.
        * **start** – The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1.
        * **fill\_value** – A value to be used to fill NA values ignored in ranking when `skipna` is `True`. The default is `np.nan` but can be set to any value to force NA values to the “bottom” or “top” of a rank as needed.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.rank_max()
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          3       0       1
    1          1       3       3
    2          2       1       1
    3          0       3       3
    <int64>    <int64> <int64> <int64>

    ```

Frame.rank\_mean(*\**, *axis=0*, *skipna=True*, *ascending=True*, *start=0*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/frame.md#Frame.rank_mean)[](#static_frame.Frame.rank_mean "Link to this definition")
:   Rank values where tied values are assigned the mean of the ordinal ranks; ranks are potentially non-contiguous and non-unique floats.

    Parameters:
    :   * **axis** – Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row)
        * **skipna** – If `True`, exclude NA values (NaN or None) from ranking, replacing those values with `fill_value`.
        * **ascending** – Boolean, or iterable of Booleans; if `True`, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is `True`.
        * **start** – The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1.
        * **fill\_value** – A value to be used to fill NA values ignored in ranking when `skipna` is `True`. The default is `np.nan` but can be set to any value to force NA values to the “bottom” or “top” of a rank as needed.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.rank_mean()
    <Frame: x>
    <Index>    a         b         c         <<U1>
    <Index>
    0          3.0       0.0       0.5
    1          1.0       2.5       2.5
    2          2.0       1.0       0.5
    3          0.0       2.5       2.5
    <int64>    <float64> <float64> <float64>

    ```

Frame.rank\_min(*\**, *axis=0*, *skipna=True*, *ascending=True*, *start=0*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/frame.md#Frame.rank_min)[](#static_frame.Frame.rank_min "Link to this definition")
:   Rank values where tied values are assigned the minimum ordinal rank; ranks are potentially non-contiguous and non-unique integers.

    Parameters:
    :   * **axis** – Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row)
        * **skipna** – If `True`, exclude NA values (NaN or None) from ranking, replacing those values with `fill_value`.
        * **ascending** – Boolean, or iterable of Booleans; if `True`, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is `True`.
        * **start** – The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1.
        * **fill\_value** – A value to be used to fill NA values ignored in ranking when `skipna` is `True`. The default is `np.nan` but can be set to any value to force NA values to the “bottom” or “top” of a rank as needed.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.rank_min()
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          3       0       0
    1          1       2       2
    2          2       1       0
    3          0       2       2
    <int64>    <int64> <int64> <int64>

    ```

Frame.rank\_ordinal(*\**, *axis=0*, *skipna=True*, *ascending=True*, *start=0*, *fill\_value=nan*)[[source]](../_modules/static_frame/core/frame.md#Frame.rank_ordinal)[](#static_frame.Frame.rank_ordinal "Link to this definition")
:   Rank values distinctly, where ties get distinct values that maintain their ordering, and ranks are contiguous unique integers.

    Parameters:
    :   * **axis** – Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row)
        * **skipna** – If `True`, exclude NA values (NaN or None) from ranking, replacing those values with `fill_value`.
        * **ascending** – Boolean, or iterable of Booleans; if `True`, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is `True`.
        * **start** – The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1.
        * **fill\_value** – A value to be used to fill NA values ignored in ranking when `skipna` is `True`. The default is `np.nan` but can be set to any value to force NA values to the “bottom” or “top” of a rank as needed.

    Returns:
    :   [`Series`](series-selector.md#Series "Series")

    ```
    >>> f = sf.Frame.from_fields(((11, 4, 10, 2), (0, 8, 3, 8), (0, 1, 0, 1)), columns=('a', 'b', 'c'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          11      0       0
    1          4       8       1
    2          10      3       0
    3          2       8       1
    <int64>    <int64> <int64> <int64>
    >>> f.rank_ordinal()
    <Frame: x>
    <Index>    a       b       c       <<U1>
    <Index>
    0          3       0       0
    1          1       2       2
    2          2       1       1
    3          0       3       3
    <int64>    <int64> <int64> <int64>

    ```

Frame.rehierarch(*index=None*, *columns=None*, *\**, *index\_constructors=None*, *columns\_constructors=None*)[[source]](../_modules/static_frame/core/frame.md#Frame.rehierarch)[](#static_frame.Frame.rehierarch "Link to this definition")
:   Produce a new Frame with index and/or columns constructed with a transformed hierarchy.

    Parameters:
    :   * **index** – Depth level specifier
        * **columns** – Depth level specifier

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> f.rehierarch((1, 0))
    <Frame: x>
    <Index>                  a       b      c               <<U1>
    <IndexHierarchy>
    p                0       10      False  1517-01-01
    p                1       8       True   1517-12-31
    q                0       2       True   1517-04-01
    q                1       3       False  1517-06-30
    <<U1>            <int64> <int64> <bool> <datetime64[D]>

    ```

Frame.reindex(*index=None*, *columns=None*, *\**, *fill\_value=nan*, *own\_index=False*, *own\_columns=False*, *check\_equals=True*)[[source]](../_modules/static_frame/core/frame.md#Frame.reindex)[](#static_frame.Frame.reindex "Link to this definition")
:   Return a new [`Frame`](frame-selector.md#Frame "Frame") with labels defined by the provided index. The size and ordering of the data is determined by the newly provided index, where data will continue to be aligned under labels found in both the new and the old index. Labels found only in the new index will be filled with `fill_value`.

    Parameters:
    :   * **index** – An iterable of unique, hashable values, or another `Index` or `IndexHierarchy`, to be used as the labels of the index.
        * **columns** – An iterable of unique, hashable values, or another `Index` or `IndexHierarchy`, to be used as the labels of the index.
        * **fill\_value** – A value to be used to fill space created by a new index that has values not found in the previous index.
        * **own\_index** – Flag the passed index as ownable by this [`static_frame.Frame`](frame.md#static_frame.Frame "static_frame.Frame"). Primarily used by internal clients.
        * **own\_columns** – Flag the passed columns as ownable by this [`static_frame.Frame`](frame.md#static_frame.Frame "static_frame.Frame"). Primarily used by internal clients.
        * **check\_equals** –

    ```
    >>> f = sf.Frame.from_items((('a', (10, 2, 8, 3)), ('b', ('qrs ', 'XYZ', '123', ' wX '))), index=('p', 'q', 'r', 's'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b     <<U1>
    <Index>
    p          10      qrs
    q          2       XYZ
    r          8       123
    s          3        wX
    <<U1>      <int64> <<U4>
    >>> f.reindex(('q', 't', 's', 'r'), fill_value=sf.FillValueAuto(i=-1, U=''))
    <Frame: x>
    <Index>    a       b     <<U1>
    <Index>
    q          2       XYZ
    t          -1
    s          3        wX
    r          8       123
    <<U1>      <int64> <<U4>

    ```

Frame.relabel(*index=None*, *columns=None*, *\**, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/frame.md#Frame.relabel)[](#static_frame.Frame.relabel "Link to this definition")
:   Return a new [`Frame`](frame-selector.md#Frame "Frame") with transformed labels on the index. The size and ordering of the data is never changed in a relabeling operation. The resulting index must be unique.

    Parameters:
    :   * **index** – One of the following types, used to create new index labels with the same size as the previous index. (a) A mapping (as a dictionary or `Series`), used to lookup and transform the labels in the previous index. Labels not found in the mapping will be reused. (b) A function, returning a hashable, that is applied to each label in the previous index. (c) The `IndexAutoFactory` type, to apply auto-incremented integer labels. (d) An `Index` initializer, i.e., either an iterable of hashables or an `Index` instance.
        * **columns** – One of the following types, used to create new columns labels with the same size as the previous columns. (a) A mapping (as a dictionary or `Series`), used to lookup and transform the labels in the previous columns. Labels not found in the mapping will be reused. (b) A function, returning a hashable, that is applied to each label in the previous columns. (c) The `IndexAutoFactory` type, to apply auto-incremented integer labels. (d) An `Index` initializer, i.e., either an iterable of hashables or an `Index` instance.

    ```
    >>> f = sf.Frame.from_records(((10, False, '1517-01-01'), (8, True,'1517-04-01')), index=('p', 'q'), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    p          10      False  1517-01-01
    q          8       True   1517-04-01
    <<U1>      <int64> <bool> <datetime64[D]>
    >>> f.relabel(('y', 'z'))
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    y          10      False  1517-01-01
    z          8       True   1517-04-01
    <<U1>      <int64> <bool> <datetime64[D]>
    >>> f.relabel(dict(q='x', p='y'))
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    y          10      False  1517-01-01
    x          8       True   1517-04-01
    <<U1>      <int64> <bool> <datetime64[D]>
    >>> f.relabel(lambda l: f'+{l.upper()}+')
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    +P+        10      False  1517-01-01
    +Q+        8       True   1517-04-01
    <<U3>      <int64> <bool> <datetime64[D]>

    ```

Frame.relabel\_flat(*index=False*, *columns=False*)[[source]](../_modules/static_frame/core/frame.md#Frame.relabel_flat)[](#static_frame.Frame.relabel_flat "Link to this definition")
:   Return a new [`Frame`](frame-selector.md#Frame "Frame"), where an `IndexHierarchy` (if defined) is replaced with a flat, one-dimension index of tuples.

    Parameters:
    :   * **index** – Boolean to flag flatening on the index.
        * **columns** – Boolean to flag flatening on the columns.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> f.relabel_flat(index=True)
    <Frame: x>
    <Index>                     a       b      c               <<U1>
    <Index>
    (np.int64(0), np.str_('p')) 10      False  1517-01-01
    (np.int64(0), np.str_('q')) 2       True   1517-04-01
    (np.int64(1), np.str_('p')) 8       True   1517-12-31
    (np.int64(1), np.str_('q')) 3       False  1517-06-30
    <object>                    <int64> <bool> <datetime64[D]>

    ```

Frame.relabel\_level\_add(*index=None*, *columns=None*, *\**, *index\_constructor=None*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/frame.md#Frame.relabel_level_add)[](#static_frame.Frame.relabel_level_add "Link to this definition")
:   Return a new [`Frame`](frame-selector.md#Frame "Frame"), adding a new root level to an existing `IndexHierarchy`, or creating an `IndexHierarchy` if one is not yet defined.

    Parameters:
    :   * **index** – A hashable value to be used as a new root level, extending or creating an `IndexHierarchy`
        * **columns** – A hashable value to be used as a new root level, extending or creating an `IndexHierarchy`
        * **\*** –
        * **index\_constructor** –
        * **columns\_constructor** –

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> f.relabel_level_add('I')
    <Frame: x>
    <Index>                        a       b      c               <<U1>
    <IndexHierarchy>
    I                0       p     10      False  1517-01-01
    I                0       q     2       True   1517-04-01
    I                1       p     8       True   1517-12-31
    I                1       q     3       False  1517-06-30
    <<U1>            <int64> <<U1> <int64> <bool> <datetime64[D]>

    ```

Frame.relabel\_level\_drop(*index=0*, *columns=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.relabel_level_drop)[](#static_frame.Frame.relabel_level_drop "Link to this definition")
:   Return a new [`Frame`](frame-selector.md#Frame "Frame"), dropping one or more levels from a either the root or the leaves of an `IndexHierarchy`. The resulting index must be unique.

    Parameters:
    :   * **index** – A positive integer drops that many outer-most (root) levels; a negative integer drops that many inner-most (leaf)levels. Default is zero.
        * **columns** – A positive integer drops that many outer-most (root) levels; a negative integer drops that many inner-most (leaf)levels. Default is zero.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> f.iloc[:2].relabel_level_drop(1)
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    p          10      False  1517-01-01
    q          2       True   1517-04-01
    <<U1>      <int64> <bool> <datetime64[D]>

    ```

Frame.relabel\_shift\_in(*key*, *\**, *axis=0*, *index\_constructors=None*)[[source]](../_modules/static_frame/core/frame.md#Frame.relabel_shift_in)[](#static_frame.Frame.relabel_shift_in "Link to this definition")
:   Create, or augment, an [`IndexHierarchy`](index_hierarchy-selector.md#IndexHierarchy "IndexHierarchy") by providing one or more selections from the Frame (via axis-appropriate `loc` selections) to move into the [`Index`](index-selector.md#Index "Index").

    Parameters:
    :   * **key** – a loc-style selection on the opposite axis.
        * **axis** – 0 modifies the index by selecting columns with `key`; 1 modifies the columns by selecting rows with `key`.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> f.relabel_shift_in('a')
    <Frame: x>
    <Index>                                            b      c               <<U1>
    <IndexHierarchy: ('__index0__', '...
    0                                    p     10      False  1517-01-01
    0                                    q     2       True   1517-04-01
    1                                    p     8       True   1517-12-31
    1                                    q     3       False  1517-06-30
    <int64>                              <<U1> <int64> <bool> <datetime64[D]>

    ```

Frame.relabel\_shift\_out(*depth\_level*, *\**, *axis=0*)[[source]](../_modules/static_frame/core/frame.md#Frame.relabel_shift_out)[](#static_frame.Frame.relabel_shift_out "Link to this definition")
:   Shift values from an index on an axis to the Frame by providing one or more depth level selections.

    Parameters:
    :   * **dpeth\_level** – an iloc-style selection on the [`Index`](index-selector.md#Index "Index") of the specified axis.
        * **axis** – 0 modifies the index by selecting columns with `depth_level`; 1 modifies the columns by selecting rows with `depth_level`.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> f.rename(index=('d', 'e')).relabel_shift_out([1, 0])
    <Frame: x>
    <Index>    e     d       a       b      c               <<U1>
    <Index>
    0          p     0       10      False  1517-01-01
    1          q     0       2       True   1517-04-01
    2          p     1       8       True   1517-12-31
    3          q     1       3       False  1517-06-30
    <int64>    <<U1> <int64> <int64> <bool> <datetime64[D]>

    ```

Frame.rename(*name=<object object>*, *\**, *index=<object object>*, *columns=<object object>*)[[source]](../_modules/static_frame/core/frame.md#Frame.rename)[](#static_frame.Frame.rename "Link to this definition")
:   Return a new Frame with an updated name attribute. Optionally update the name attribute of `index` and `columns`.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> f.rename('y', index='p', columns='q')
    <Frame: y>
    <Index: q>                a       b      c               <<U1>
    <IndexHierarchy: p>
    0                   p     10      False  1517-01-01
    0                   q     2       True   1517-04-01
    1                   p     8       True   1517-12-31
    1                   q     3       False  1517-06-30
    <int64>             <<U1> <int64> <bool> <datetime64[D]>

    ```

Frame.roll(*index=0*, *columns=0*, *\**, *include\_index=False*, *include\_columns=False*)[[source]](../_modules/static_frame/core/frame.md#Frame.roll)[](#static_frame.Frame.roll "Link to this definition")
:   Roll columns and/or rows by positive or negative integer counts, where columns and/or rows roll around the axis.

    Parameters:
    :   * **include\_index** – Determine if index is included in index-wise rotation.
        * **include\_columns** – Determine if column index is included in index-wise rotation.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    0          10      False  1517-01-01
    1          2       True   1517-04-01
    2          8       True   1517-12-31
    3          3       False  1517-06-30
    <int64>    <int64> <bool> <datetime64[D]>
    >>> f.roll(3)
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    0          2       True   1517-04-01
    1          8       True   1517-12-31
    2          3       False  1517-06-30
    3          10      False  1517-01-01
    <int64>    <int64> <bool> <datetime64[D]>

    ```

Frame.sample(*index=None*, *columns=None*, *\**, *seed=None*)[[source]](../_modules/static_frame/core/frame.md#Frame.sample)[](#static_frame.Frame.sample "Link to this definition")
:   Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container.

    Parameters:
    :   * **index.** (*Number* *of* *labels to select from the*) –
        * **columns.** (*Number* *of* *labels to select from the*) –
        * **selection.** (*Initial state* *of* *random*) –

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    0          10      False  1517-01-01
    1          2       True   1517-04-01
    2          8       True   1517-12-31
    3          3       False  1517-06-30
    <int64>    <int64> <bool> <datetime64[D]>
    >>> f.sample(2, 2, seed=0)
    <Frame: x>
    <Index>    b      c               <<U1>
    <Index>
    2          True   1517-12-31
    3          False  1517-06-30
    <int64>    <bool> <datetime64[D]>

    ```

Frame.set\_columns(*index*, *\**, *drop=False*, *columns\_constructor=None*)[[source]](../_modules/static_frame/core/frame.md#Frame.set_columns)[](#static_frame.Frame.set_columns "Link to this definition")
:   Return a new [`Frame`](frame-selector.md#Frame "Frame") produced by setting the given row as the columns, optionally removing that row from the new [`Frame`](frame-selector.md#Frame "Frame").

    Parameters:
    :   * **index** –
        * **\*** –
        * **drop** –
        * **columns\_constructor** –

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> f.set_columns((1, 'p'), drop=True)
    <Frame: x>
    <Index: (1, 'p')>       8       True   1517-12-31      <object>
    <IndexHierarchy>
    0                 p     10      False  1517-01-01
    0                 q     2       True   1517-04-01
    1                 q     3       False  1517-06-30
    <int64>           <<U1> <int64> <bool> <datetime64[D]>

    ```

Frame.set\_columns\_hierarchy(*index*, *\**, *drop=False*, *columns\_constructors=None*, *reorder\_for\_hierarchy=False*)[[source]](../_modules/static_frame/core/frame.md#Frame.set_columns_hierarchy)[](#static_frame.Frame.set_columns_hierarchy "Link to this definition")
:   Given an iterable of index labels, return a new `Frame` with those rows as an `IndexHierarchy` on the columns.

    Parameters:
    :   * **index** – Iterable of index labels.
        * **drop** – Boolean to determine if selected rows should be removed from the data.
        * **columns\_constructors** – Optionally provide a sequence of `Index` constructors, of length equal to depth, to be used in converting row Index components in the `IndexHierarchy`.
        * **reorder\_for\_hierarchy** – reorder the columns to produce a hierarchible Index from the selected columns.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> f.set_columns_hierarchy([(1, 'p'), (1, 'q')], drop=True)
    <Frame: x>
    <IndexHierarchy: ((np.int64(1), n...       8       True   1517-12-31      <object>
                                               3       False  1517-06-30      <object>
    <IndexHierarchy>
    0                                    p     10      False  1517-01-01
    0                                    q     2       True   1517-04-01
    <int64>                              <<U1> <int64> <bool> <datetime64[D]>

    ```

Frame.set\_index(*column*, *\**, *drop=False*, *index\_constructor=None*)[[source]](../_modules/static_frame/core/frame.md#Frame.set_index)[](#static_frame.Frame.set_index "Link to this definition")
:   Return a new [`Frame`](frame-selector.md#Frame "Frame") produced by setting the given column as the index, optionally removing that column from the new [`Frame`](frame-selector.md#Frame "Frame").

    Parameters:
    :   * **column** –
        * **\*** –
        * **drop** –
        * **index\_constructor** –

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    0          10      False  1517-01-01
    1          2       True   1517-04-01
    2          8       True   1517-12-31
    3          3       False  1517-06-30
    <int64>    <int64> <bool> <datetime64[D]>
    >>> f.set_index('c', drop=True, index_constructor=sf.IndexDate)
    <Frame: x>
    <Index>         a       b      <<U1>
    <IndexDate: c>
    1517-01-01      10      False
    1517-04-01      2       True
    1517-12-31      8       True
    1517-06-30      3       False
    <datetime64[D]> <int64> <bool>

    ```

Frame.set\_index\_hierarchy(*columns*, *\**, *drop=False*, *index\_constructors=None*, *reorder\_for\_hierarchy=False*)[[source]](../_modules/static_frame/core/frame.md#Frame.set_index_hierarchy)[](#static_frame.Frame.set_index_hierarchy "Link to this definition")
:   Given an iterable of column labels, return a new `Frame` with those columns as an `IndexHierarchy` on the index.

    Parameters:
    :   * **columns** – Iterable of column labels.
        * **drop** – Boolean to determine if selected columns should be removed from the data.
        * **index\_constructors** – Optionally provide a sequence of `Index` constructors, of length equal to depth, to be used in converting columns Index components in the `IndexHierarchy`.
        * **reorder\_for\_hierarchy** – reorder the rows to produce a hierarchible Index from the selected columns, assuming hierarchability is possible.

    Returns:
    :   [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    0          10      False  1517-01-01
    1          2       True   1517-04-01
    2          8       True   1517-12-31
    3          3       False  1517-06-30
    <int64>    <int64> <bool> <datetime64[D]>
    >>> f.set_index_hierarchy(['b', 'c'], drop=True, index_constructors=(sf.Index, sf.IndexDate))
    <Frame: x>
    <Index>                                              a       <<U1>
    <IndexHierarchy: (np.str_('b'), n...
    False                                1517-01-01      10
    True                                 1517-04-01      2
    True                                 1517-12-31      8
    False                                1517-06-30      3
    <bool>                               <datetime64[D]> <int64>

    ```

Frame.shift(*index=0*, *columns=0*, *\**, *fill\_value=nan*)[[source]](../_modules/static_frame/core/frame.md#Frame.shift)[](#static_frame.Frame.shift "Link to this definition")
:   Shift columns and/or rows by positive or negative integer counts, where columns and/or rows fall of the axis and introduce missing values, filled by fill\_value.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    0          10      False  1517-01-01
    1          2       True   1517-04-01
    2          8       True   1517-12-31
    3          3       False  1517-06-30
    <int64>    <int64> <bool> <datetime64[D]>
    >>> f.shift(3, fill_value=sf.FillValueAuto)
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    0          0       False  NaT
    1          0       False  NaT
    2          0       False  NaT
    3          10      False  1517-01-01
    <int64>    <int64> <bool> <datetime64[D]>

    ```

Frame.sort\_columns(*\**, *ascending=True*, *kind='mergesort'*, *key=None*)[[source]](../_modules/static_frame/core/frame.md#Frame.sort_columns)[](#static_frame.Frame.sort_columns "Link to this definition")
:   Return a new [`Frame`](frame-selector.md#Frame "Frame") ordered by the sorted `columns`.

    Parameters:
    :   * **ascendings** – Boolean, or iterable of Booleans; if `True`, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is `True`.
        * **kind** – Name of the sort algorithm as passed to NumPy.
        * **key** – A function that is used to pre-process the selected columns or rows and derive new values to sort by.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> f.sort_columns(ascending=False)
    <Frame: x>
    <Index>                c               b      a       <<U1>
    <IndexHierarchy>
    0                p     1517-01-01      False  10
    0                q     1517-04-01      True   2
    1                p     1517-12-31      True   8
    1                q     1517-06-30      False  3
    <int64>          <<U1> <datetime64[D]> <bool> <int64>

    ```

Frame.sort\_index(*\**, *ascending=True*, *kind='mergesort'*, *key=None*)[[source]](../_modules/static_frame/core/frame.md#Frame.sort_index)[](#static_frame.Frame.sort_index "Link to this definition")
:   Return a new [`Frame`](frame-selector.md#Frame "Frame") ordered by the sorted Index.

    Parameters:
    :   * **ascendings** – Boolean, or iterable of Booleans; if `True`, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is `True`.
        * **kind** – Name of the sort algorithm as passed to NumPy.
        * **key** – A function that is used to pre-process the selected columns or rows and derive new values to sort by.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> f.sort_index(ascending=False)
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    1                q     3       False  1517-06-30
    1                p     8       True   1517-12-31
    0                q     2       True   1517-04-01
    0                p     10      False  1517-01-01
    <int64>          <<U1> <int64> <bool> <datetime64[D]>

    ```

Frame.sort\_values(*label*, *\**, *ascending=True*, *axis=1*, *kind='mergesort'*, *key=None*)[[source]](../_modules/static_frame/core/frame.md#Frame.sort_values)[](#static_frame.Frame.sort_values "Link to this definition")
:   Return a new [`Frame`](frame-selector.md#Frame "Frame") ordered by the sorted values, where values are given by single column or iterable of columns.

    Parameters:
    :   * **label** – A label or iterable of labels to select the columns (for axis 1) or rows (for axis 0) to sort.
        * **\*** –
        * **ascendings** – Boolean, or iterable of Booleans; if `True`, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is `True`.
        * **axis** – Axis upon which to sort; 0 orders columns based on one or more rows; 1 orders rows based on one or more columns.
        * **kind** – Name of the sort algorithm as passed to NumPy.
        * **key** – A function that is used to pre-process the selected columns or rows and derive new values to sort by.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    0          10      False  1517-01-01
    1          2       True   1517-04-01
    2          8       True   1517-12-31
    3          3       False  1517-06-30
    <int64>    <int64> <bool> <datetime64[D]>
    >>> f.sort_values('c')
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    0          10      False  1517-01-01
    1          2       True   1517-04-01
    3          3       False  1517-06-30
    2          8       True   1517-12-31
    <int64>    <int64> <bool> <datetime64[D]>
    >>> f.sort_values(['c', 'b'], ascending=False)
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    2          8       True   1517-12-31
    3          3       False  1517-06-30
    1          2       True   1517-04-01
    0          10      False  1517-01-01
    <int64>    <int64> <bool> <datetime64[D]>

    ```

Frame.std(*axis=0*, *skipna=True*, *ddof=0*, *out=None*)[](#static_frame.Frame.std "Link to this definition")
:   Return the standard deviaton along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f.std()
    <Series>
    <Index>
    a        1.632993161855452
    b        1.632993161855452
    <<U1>    <float64>

    ```

Frame.sum(*axis=0*, *skipna=True*, *allna=0*, *out=None*)[](#static_frame.Frame.sum "Link to this definition")
:   Sum values along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f.sum()
    <Series>
    <Index>
    a        6
    b        9
    <<U1>    <int64>

    ```

Frame.tail(*count=5*)[[source]](../_modules/static_frame/core/frame.md#Frame.tail)[](#static_frame.Frame.tail "Link to this definition")
:   Return a [`Frame`](frame-selector.md#Frame "Frame") consisting only of the bottom elements as specified by `count`.

    Parameters:
    :   **count** – Number of elements to be returned from the bottom of the [`Frame`](frame-selector.md#Frame "Frame")

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    0          10      False  1517-01-01
    1          2       True   1517-04-01
    2          8       True   1517-12-31
    3          3       False  1517-06-30
    <int64>    <int64> <bool> <datetime64[D]>
    >>> f.tail(2)
    <Frame: x>
    <Index>    a       b      c               <<U1>
    <Index>
    2          8       True   1517-12-31
    3          3       False  1517-06-30
    <int64>    <int64> <bool> <datetime64[D]>

    ```

Frame.transpose()[[source]](../_modules/static_frame/core/frame.md#Frame.transpose)[](#static_frame.Frame.transpose "Link to this definition")
:   Transpose. Return a [`Frame`](frame-selector.md#Frame "Frame") with `index` as `columns` and vice versa.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f.transpose()
    <Frame: x>
    <Index>    p       q       r       <<U1>
    <Index>
    a          0       2       4
    b          1       3       5
    <<U1>      <int64> <int64> <int64>

    ```

Frame.unique(*\**, *axis=None*)[[source]](../_modules/static_frame/core/frame.md#Frame.unique)[](#static_frame.Frame.unique "Link to this definition")
:   Return a NumPy array of unqiue values. If the axis argument is provided, uniqueness is determined by columns or row.

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, 2), (False, True, None, True), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b        c               <<U1>
    <Index>
    0          10.0      False    1517-01-01
    1          2.0       True     1517-04-01
    2          nan       None     NaT
    3          2.0       True     1517-04-01
    <int64>    <float64> <object> <datetime64[D]>
    >>> f.unique()
    [10.0 False datetime.date(1517, 1, 1) 2.0 True datetime.date(1517, 4, 1)
     nan None]

    ```

Frame.unique\_enumerated(*\**, *retain\_order=False*, *func=None*)[[source]](../_modules/static_frame/core/frame.md#Frame.unique_enumerated)[](#static_frame.Frame.unique_enumerated "Link to this definition")
:   {doc}
    {args}

    ```
    >>> f = sf.Frame.from_fields(((10, 2, np.nan, 2), (False, True, None, True), ('1517-01-01', '1517-04-01', 'NaT', '1517-04-01')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>    a         b        c               <<U1>
    <Index>
    0          10.0      False    1517-01-01
    1          2.0       True     1517-04-01
    2          nan       None     NaT
    3          2.0       True     1517-04-01
    <int64>    <float64> <object> <datetime64[D]>
    >>> f.unique_enumerated(retain_order=True, func=sf.isna_element)
    (array([[ 0,  2,  4],
           [ 1,  3,  5],
           [-1, -1, -1],
           [ 1,  3,  5]]), array([10.0, 2.0, False, True, datetime.date(1517, 1, 1),
           datetime.date(1517, 4, 1)], dtype=object))

    ```

Frame.unset\_columns(*\**, *names=()*, *drop=False*, *index\_constructors=None*)[[source]](../_modules/static_frame/core/frame.md#Frame.unset_columns)[](#static_frame.Frame.unset_columns "Link to this definition")
:   Return a new [`Frame`](frame-selector.md#Frame "Frame") where columns are added to the top of the data, and an [`IndexAutoFactory`](index_auto_factory.md#static_frame.IndexAutoFactory "static_frame.IndexAutoFactory") is used to populate new columns. This operation potentially forces a complete copy of all data.

    Parameters:
    :   * **names** – An sequence of hashables to be used to name the unset columns. If an `Index`, a single hashable should be provided; if an `IndexHierarchy`, as many hashables as the depth must be provided.
        * **index\_constructors** –

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f.rename(columns='o').unset_columns()
    <Frame: x>
    <Index>    0        1        <int64>
    <Index>
    o          a        b
    p          0        1
    q          2        3
    r          4        5
    <<U1>      <object> <object>

    ```

Frame.unset\_index(*\**, *names=()*, *drop=False*, *consolidate\_blocks=False*, *columns\_constructors=None*)[[source]](../_modules/static_frame/core/frame.md#Frame.unset_index)[](#static_frame.Frame.unset_index "Link to this definition")
:   Return a new [`Frame`](frame-selector.md#Frame "Frame") where the index is added to the front of the data, and an [`IndexAutoFactory`](index_auto_factory.md#static_frame.IndexAutoFactory "static_frame.IndexAutoFactory") is used to populate a new index. If the [`Index`](index-selector.md#Index "Index") has a `name`, that name will be used for the column name, otherwise a suitable default will be used. As underlying NumPy arrays are immutable, data is not copied.

    Parameters:
    :   * **names** – An iterable of hashables to be used to name the unset index. If an `Index`, a single hashable should be provided; if an `IndexHierarchy`, as many hashables as the depth must be provided.
        * **consolidate\_blocks** –
        * **columns\_constructors** –

    ```
    >>> f = sf.Frame.from_fields(((10, 2, 8, 3), (False, True, True, False), ('1517-01-01', '1517-04-01', '1517-12-31', '1517-06-30')), index=sf.IndexHierarchy.from_product((0, 1), ('p', 'q')), columns=('a', 'b', 'c'), dtypes=dict(c=np.datetime64), name='x')
    >>> f
    <Frame: x>
    <Index>                a       b      c               <<U1>
    <IndexHierarchy>
    0                p     10      False  1517-01-01
    0                q     2       True   1517-04-01
    1                p     8       True   1517-12-31
    1                q     3       False  1517-06-30
    <int64>          <<U1> <int64> <bool> <datetime64[D]>
    >>> f.rename(index=(('d', 'e'))).unset_index()
    <Frame: x>
    <Index>    d       e     a       b      c               <<U1>
    <Index>
    0          0       p     10      False  1517-01-01
    1          0       q     2       True   1517-04-01
    2          1       p     8       True   1517-12-31
    3          1       q     3       False  1517-06-30
    <int64>    <int64> <<U1> <int64> <bool> <datetime64[D]>

    ```

Frame.var(*axis=0*, *skipna=True*, *ddof=0*, *out=None*)[](#static_frame.Frame.var "Link to this definition")
:   Return the variance along the specified axis.

    Parameters:
    :   * **axis** – Axis, defaulting to axis 0.
        * **skipna** – Skip missing (NaN) values, defaulting to True.

    ```
    >>> f = sf.Frame(np.arange(6).reshape(3,2), index=('p', 'q', 'r'), columns=('a', 'b'), name='x')
    >>> f
    <Frame: x>
    <Index>    a       b       <<U1>
    <Index>
    p          0       1
    q          2       3
    r          4       5
    <<U1>      <int64> <int64>
    >>> f.var()
    <Series>
    <Index>
    a        2.6666666666666665
    b        2.6666666666666665
    <<U1>    <float64>

    ```

[Frame](frame.md#api-detail-frame): [Constructor](frame-constructor.md#api-detail-frame-constructor) | [Exporter](frame-exporter.md#api-detail-frame-exporter) | [Attribute](frame-attribute.md#api-detail-frame-attribute) | [Method](#api-detail-frame-method) | [Dictionary-Like](frame-dictionary_like.md#api-detail-frame-dictionary-like) | [Display](frame-display.md#api-detail-frame-display) | [Assignment](frame-assignment.md#api-detail-frame-assignment) | [Selector](frame-selector.md#api-detail-frame-selector) | [Iterator](frame-iterator.md#api-detail-frame-iterator) | [Operator Binary](frame-operator_binary.md#api-detail-frame-operator-binary) | [Operator Unary](frame-operator_unary.md#api-detail-frame-operator-unary) | [Accessor Values](frame-accessor_values.md#api-detail-frame-accessor-values) | [Accessor Datetime](frame-accessor_datetime.md#api-detail-frame-accessor-datetime) | [Accessor String](frame-accessor_string.md#api-detail-frame-accessor-string) | [Accessor Transpose](frame-accessor_transpose.md#api-detail-frame-accessor-transpose) | [Accessor Fill Value](frame-accessor_fill_value.md#api-detail-frame-accessor-fill-value) | [Accessor Regular Expression](frame-accessor_regular_expression.md#api-detail-frame-accessor-regular-expression) | [Accessor Hashlib](frame-accessor_hashlib.md#api-detail-frame-accessor-hashlib) | [Accessor Type Clinic](frame-accessor_type_clinic.md#api-detail-frame-accessor-type-clinic) | [Accessor Reduce](frame-accessor_reduce.md#api-detail-frame-accessor-reduce)

[Previous](frame-attribute.md "Detail: Frame: Attribute")
[Next](frame-dictionary_like.md "Detail: Frame: Dictionary-Like")

---

© Copyright 2025, Christopher Ariza.
Last updated on Apr 29, 2025.

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme)
provided by [Read the Docs](https://readthedocs.org).