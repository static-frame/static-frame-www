{"Series.__init__()": "Initializer. Args: values: An iterable of values to be aligned with the supplied...", "Series.from_concat()": "Concatenate multiple Series into a new Series. Args: containers: Iterable of Ser...", "Series.from_concat_items()": "Produce a Series with a hierarchical index from an iterable of pairs of labels,...", "Series.from_delimited()": "Series construction from a delimited string. Args: dtype: if None, dtype will be...", "Series.from_dict()": "Series construction from a dictionary, where the first pair value is the index a...", "Series.from_element()": "Create a Series from a single element. The size of the resultant container will...", "Series.from_items()": "Series construction from an iterator or generator of pairs, where the first pair...", "Series.from_overlay()": "Return a new Series made by overlaying containers, aligned values are filled wit...", "Series.from_pandas()": "Given a Pandas Series, return a Series. Args: value: Pandas Series. * index_cons...", "Series.to_frame()": "Return a Frame view of this Series. As underlying data is immutable, this is a n...", "Series.to_frame_go()": "Return FrameGO view of this Series. As underlying data is immutable, this is a n...", "Series.to_frame_he()": "Return FrameHE view of this Series. As underlying data is immutable, this is a n...", "Series.to_html()": "Return an HTML table representation of this Series using standard TABLE, TR, and...", "Series.to_html_datatables()": "Return a complete HTML representation of this Series using the DataTables JS lib...", "Series.to_pairs()": "Return a tuple of tuples, where each inner tuple is a pair of index label, value...", "Series.to_pandas()": "Return a Pandas Series. Returns: pandas.Series", "Series.to_series_he()": "Return a SeriesHE from this Series.", "Series.to_visidata()": "Open an interactive VisiData session.", "Series.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "Series.T": "Transpose. For a 1D immutable container, this returns a reference to self. Retur...", "Series.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "Series.index": "The index instance assigned to this container. Returns: Index", "Series.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "Series.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "Series.name": "A hashable label attached to this container. Returns: Hashable", "Series.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "Series.ndim": "Return the number of dimensions, which for a Series is always 1. Returns: int", "Series.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: Tupl...", "Series.size": "Return the size of the underlying NumPy array. Returns: int", "Series.__array__()": "Support the __array__ interface, returning an array of values.", "Series.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "Series.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "Series.__deepcopy__()": "", "Series.__len__()": "Length of values.", "Series.__round__()": "Return a Series rounded to the given decimals. Negative decimals round to the le...", "Series.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "Series.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "Series.astype()": "Return a Series with type determined by dtype argument. Note that for Series, th...", "Series.clip()": "Apply a clip operation to this Series. Note that clip operations can be applied...", "Series.corr()": "Return the index-aligned correlation to the supplied Series. Args: other: Series...", "Series.count()": "Return the count of non-NA, non-falsy, and/or unique elements. Args: skipna: ski...", "Series.cov()": "Return the index-aligned covariance to the supplied Series. Args: ddof: Delta de...", "Series.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "Series.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "Series.drop_duplicated()": "Return a Series with duplicated values removed. Args: exclude_first: Boolean to...", "Series.dropfalsy()": "Return a new Series after removing values of falsy.", "Series.dropna()": "Return a new Series after removing values of NaN or None.", "Series.duplicated()": "Return a same-sized Boolean Series that shows True for all values that are dupli...", "Series.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "Series.fillfalsy()": "Return a new Series after replacing falsy values with the supplied value. The va...", "Series.fillfalsy_backward()": "Return a new Series after feeding backward the last non-falsy observation across...", "Series.fillfalsy_forward()": "Return a new Series after feeding forward the last non-falsy observation across...", "Series.fillfalsy_leading()": "Return a new Series after filling leading (and only leading) falsy values with t...", "Series.fillfalsy_trailing()": "Return a new Series after filling trailing (and only trailing) falsy values with...", "Series.fillna()": "Return a new Series after replacing NA (NaN or None) with the supplied value. Th...", "Series.fillna_backward()": "Return a new Series after feeding backward the last non-null (NaN or None) obser...", "Series.fillna_forward()": "Return a new Series after feeding forward the last non-null (NaN or None) observ...", "Series.fillna_leading()": "Return a new Series after filling leading (and only leading) null (NaN or None)...", "Series.fillna_trailing()": "Return a new Series after filling trailing (and only trailing) null (NaN or None...", "Series.head()": "Return a Series consisting only of the top elements as specified by count. Args:...", "Series.iloc_max()": "Return the integer index corresponding to the maximum value. Args: skipna: if Tr...", "Series.iloc_min()": "Return the integer index corresponding to the minimum value found. Args: skipna:...", "Series.iloc_notfalsy_first()": "Return the position corresponding to the first non-falsy (including nan) value f...", "Series.iloc_notfalsy_last()": "Return the position corresponding to the last non-falsy (including nan) value fo...", "Series.iloc_notna_first()": "Return the position corresponding to the first not NA (None or nan) value found....", "Series.iloc_notna_last()": "Return the position corresponding to the last not NA (None or nan) value found....", "Series.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "Series.insert_after()": "Create a new Series by inserting a Series at the position after the label specif...", "Series.insert_before()": "Create a new Series by inserting a Series at the position before the label speci...", "Series.isfalsy()": "Return a same-indexed, Boolean Series indicating which values are falsy.", "Series.isin()": "Return a same-sized Boolean Series that shows if the same-positioned element is...", "Series.isna()": "Return a same-indexed, Boolean Series indicating which values are NaN or None.", "Series.loc_max()": "Return the label corresponding to the maximum value found. Args: skipna: if True...", "Series.loc_min()": "Return the label corresponding to the minimum value found. Args: skipna: if True...", "Series.loc_notfalsy_first()": "Return the label corresponding to the first non-falsy (including nan) value foun...", "Series.loc_notfalsy_last()": "Return the label corresponding to the last non-falsy (including nan) value found...", "Series.loc_notna_first()": "Return the label corresponding to the first not NA (None or nan) value found. Ar...", "Series.loc_notna_last()": "Return the label corresponding to the last not NA (None or nan) value found. Arg...", "Series.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "Series.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "Series.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "Series.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "Series.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "Series.notfalsy()": "Return a same-indexed, Boolean Series indicating which values are falsy.", "Series.notna()": "Return a same-indexed, Boolean Series indicating which values are NaN or None.", "Series.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "Series.rank_dense()": "Rank values as compactly as possible, where ties get the same value, and ranks a...", "Series.rank_max()": "Rank values where tied values are assigned the maximum ordinal rank; ranks are p...", "Series.rank_mean()": "Rank values where tied values are assigned the mean of the ordinal ranks; ranks...", "Series.rank_min()": "Rank values where tied values are assigned the minimum ordinal rank; ranks are p...", "Series.rank_ordinal()": "Rank values distinctly, where ties get distinct values that maintain their order...", "Series.rehierarch()": "Return a new Series with new a hierarchy based on the supplied depth_map.", "Series.reindex()": "Return a new Series with labels defined by the provided index. The size and orde...", "Series.relabel()": "Return a new Series with transformed labels on the index. The size and ordering...", "Series.relabel_flat()": "Return a new Series, where an IndexHierarchy (if defined) is replaced with a fla...", "Series.relabel_level_add()": "Return a new Series, adding a new root level to an existing IndexHierarchy, or c...", "Series.relabel_level_drop()": "Return a new Series, dropping one or more levels from a either the root or the l...", "Series.rename()": "Return a new Series with an updated name attribute.", "Series.roll()": "Return a Series with values rotated forward and wrapped around the index (with a...", "Series.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "Series.shift()": "Return a Series with values shifted forward on the index (with a positive shift)...", "Series.sort_index()": "Return a new Series ordered by the sorted Index. Args: * ascendings: Boolean, or...", "Series.sort_values()": "Return a new Series ordered by the sorted values. Args: * ascending: If True, so...", "Series.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "Series.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "Series.tail()": "Return a Series consisting only of the bottom elements as specified by count. s...", "Series.transpose()": "Transpose. For a 1D immutable container, this returns a reference to self. Retur...", "Series.unique()": "Return a NumPy array of unique values. Returns: numpy.ndarray", "Series.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "Series.__contains__()": "Inclusion of value in index labels. Returns: bool", "Series.__iter__()": "Iterator of index labels, same as Series.keys. Returns: Iterator[Hashasble]", "Series.__reversed__()": "Returns a reverse iterator on the series' index. Returns: Index", "Series.get()": "Return the value found at the index key, else the default if the key is not foun...", "Series.items()": "Iterator of pairs of index label and value. Returns: Iterator[Tuple[Hashable, An...", "Series.keys()": "Iterator of index labels. Returns: Iterator[Hashable]", "Series.values": "", "Series.interface": "A Frame documenting the interface of this class.", "Series.__repr__()": "", "Series.__str__()": "Return str(self).", "Series.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "Series.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "Series.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "Series.assign[]()": "Assign the value in the position specified by the selector. The name attribute i...", "Series.assign[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "Series.assign[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "Series.assign[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "Series.assign.iloc[]()": "Assign the value in the position specified by the selector. The name attribute i...", "Series.assign.iloc[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "Series.assign.iloc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "Series.assign.iloc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "Series.assign.loc[]()": "Assign the value in the position specified by the selector. The name attribute i...", "Series.assign.loc[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "Series.assign.loc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "Series.assign.loc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "Series.drop[]": "Label-based selection.", "Series.drop.iloc[]": "", "Series.drop.loc[]": "", "Series.mask[]": "Label-based selection.", "Series.mask.iloc[]": "", "Series.mask.loc[]": "", "Series.masked_array[]": "Label-based selection.", "Series.masked_array.iloc[]": "", "Series.masked_array.loc[]": "", "Series.[]": "Selector of values by label. Args: key: A loc selector, either a label, a list o...", "Series.iloc[]": "Interface for position-based selection.", "Series.loc[]": "Interface for label-based selection.", "Series.iter_element()": "Iterator of elements.", "Series.iter_element().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_element().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_element().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_element().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_element().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "Series.iter_element().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "Series.iter_element().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "Series.iter_element().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "Series.iter_element().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "Series.iter_element().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "Series.iter_element().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "Series.iter_element().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "Series.iter_element().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "Series.iter_element_items()": "Iterator of label, element pairs.", "Series.iter_element_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_element_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_element_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_element_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_element_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "Series.iter_element_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "Series.iter_element_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "Series.iter_element_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "Series.iter_element_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "Series.iter_element_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "Series.iter_element_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "Series.iter_element_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "Series.iter_element_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "Series.iter_group()": "Iterator of Series, where each Series matches unique values.", "Series.iter_group().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_group().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_group().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_group().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_group_array()": "Iterator of Series, where each Series matches unique values.", "Series.iter_group_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_group_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_group_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_group_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_group_array_items()": "", "Series.iter_group_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_group_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_group_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_group_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_group_items()": "", "Series.iter_group_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_group_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_group_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_group_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_group_labels()": "", "Series.iter_group_labels().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_group_labels().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_group_labels().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_group_labels().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_group_labels_array()": "", "Series.iter_group_labels_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_group_labels_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_group_labels_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_group_labels_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_group_labels_array_items()": "", "Series.iter_group_labels_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_group_labels_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_group_labels_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_group_labels_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_group_labels_items()": "", "Series.iter_group_labels_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_group_labels_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_group_labels_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_group_labels_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_group_other()": "Iterator of Series, grouped by unique values found in the passed container.", "Series.iter_group_other().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_group_other().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_group_other().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_group_other().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_group_other_array()": "", "Series.iter_group_other_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_group_other_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_group_other_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_group_other_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_group_other_array_items()": "", "Series.iter_group_other_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_group_other_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_group_other_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_group_other_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_group_other_items()": "Iterator of pairs of label, Series, grouped by unique values found in the passed...", "Series.iter_group_other_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_group_other_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_group_other_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_group_other_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_window()": "", "Series.iter_window().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_window().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_window().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_window().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_window_array()": "", "Series.iter_window_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_window_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_window_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_window_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_window_array_items()": "", "Series.iter_window_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_window_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_window_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_window_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.iter_window_items()": "", "Series.iter_window_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Series.iter_window_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Series.iter_window_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Series.iter_window_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Series.__add__()": "", "Series.__and__()": "", "Series.__eq__()": "", "Series.__floordiv__()": "", "Series.__ge__()": "", "Series.__gt__()": "", "Series.__le__()": "", "Series.__lt__()": "", "Series.__matmul__()": "", "Series.__mod__()": "", "Series.__mul__()": "", "Series.__ne__()": "", "Series.__or__()": "", "Series.__pow__()": "", "Series.__radd__()": "", "Series.__rfloordiv__()": "", "Series.__rmatmul__()": "", "Series.__rmul__()": "", "Series.__rshift__()": "", "Series.__rsub__()": "", "Series.__rtruediv__()": "", "Series.__sub__()": "", "Series.__truediv__()": "", "Series.__xor__()": "", "Series.__abs__()": "", "Series.__invert__()": "", "Series.__neg__()": "", "Series.__pos__()": "", "Series.via_values.apply()": "", "Series.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "Series.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "Series.via_dt.year": "Return the year of each element.", "Series.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "Series.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "Series.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "Series.via_dt.hour": "Return the hour of each element, between 0 and 24.", "Series.via_dt.minute": "Return the minute of each element, between 0 and 60.", "Series.via_dt.second": "Return the second of each element, between 0 and 60.", "Series.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "Series.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "Series.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "Series.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "Series.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "Series.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "Series.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "Series.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "Series.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "Series.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "Series.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "Series.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "Series.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "Series.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "Series.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "Series.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "Series.via_str.center()": "Return a container with its elements centered in a string of length width.", "Series.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "Series.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "Series.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "Series.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "Series.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "Series.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "Series.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "Series.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "Series.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "Series.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "Series.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "Series.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "Series.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "Series.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "Series.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "Series.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "Series.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "Series.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "Series.via_str.len()": "Return the length of the string.", "Series.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "Series.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "Series.via_str.partition()": "Partition each element around sep.", "Series.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "Series.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "Series.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "Series.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "Series.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "Series.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "Series.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "Series.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "Series.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "Series.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "Series.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "Series.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "Series.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "Series.via_str.zfill()": "Return the string left-filled with zeros.", "Series.via_fill_value().loc": "Label-based selection where labels not specified will define a new container con...", "Series.via_fill_value().__getitem__()": "Label-based selection where labels not specified will define a new container con...", "Series.via_fill_value().via_T": "Interface for using binary operators with one-dimensional sequences, where the o...", "Series.via_fill_value().__add__()": "", "Series.via_fill_value().__sub__()": "", "Series.via_fill_value().__mul__()": "", "Series.via_fill_value().__truediv__()": "", "Series.via_fill_value().__floordiv__()": "", "Series.via_fill_value().__mod__()": "", "Series.via_fill_value().__pow__()": "", "Series.via_fill_value().__lshift__()": "", "Series.via_fill_value().__rshift__()": "", "Series.via_fill_value().__and__()": "", "Series.via_fill_value().__xor__()": "", "Series.via_fill_value().__or__()": "", "Series.via_fill_value().__lt__()": "", "Series.via_fill_value().__le__()": "", "Series.via_fill_value().__eq__()": "", "Series.via_fill_value().__ne__()": "", "Series.via_fill_value().__gt__()": "", "Series.via_fill_value().__ge__()": "", "Series.via_fill_value().__radd__()": "", "Series.via_fill_value().__rsub__()": "", "Series.via_fill_value().__rmul__()": "", "Series.via_fill_value().__rtruediv__()": "", "Series.via_fill_value().__rfloordiv__()": "", "Series.via_re().search()": "Scan through string looking for the first location where this regular expression...", "Series.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "Series.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "Series.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "Series.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "Series.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "Series.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "Series.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "Series.via_hashlib().md5()": "", "Series.via_hashlib().sha256()": "", "Series.via_hashlib().sha512()": "", "Series.via_hashlib().sha3_256()": "", "Series.via_hashlib().sha3_512()": "", "Series.via_hashlib().shake_128()": "", "Series.via_hashlib().shake_256()": "", "Series.via_hashlib().blake2b()": "", "Series.via_hashlib().blake2s()": "", "SeriesHE.__init__()": "Initializer. Args: values: An iterable of values to be aligned with the supplied...", "SeriesHE.from_concat()": "Concatenate multiple Series into a new Series. Args: containers: Iterable of Ser...", "SeriesHE.from_concat_items()": "Produce a Series with a hierarchical index from an iterable of pairs of labels,...", "SeriesHE.from_delimited()": "Series construction from a delimited string. Args: dtype: if None, dtype will be...", "SeriesHE.from_dict()": "Series construction from a dictionary, where the first pair value is the index a...", "SeriesHE.from_element()": "Create a Series from a single element. The size of the resultant container will...", "SeriesHE.from_items()": "Series construction from an iterator or generator of pairs, where the first pair...", "SeriesHE.from_overlay()": "Return a new Series made by overlaying containers, aligned values are filled wit...", "SeriesHE.from_pandas()": "Given a Pandas Series, return a Series. Args: value: Pandas Series. * index_cons...", "SeriesHE.to_frame()": "Return a Frame view of this Series. As underlying data is immutable, this is a n...", "SeriesHE.to_frame_go()": "Return FrameGO view of this Series. As underlying data is immutable, this is a n...", "SeriesHE.to_frame_he()": "Return FrameHE view of this Series. As underlying data is immutable, this is a n...", "SeriesHE.to_html()": "Return an HTML table representation of this Series using standard TABLE, TR, and...", "SeriesHE.to_html_datatables()": "Return a complete HTML representation of this Series using the DataTables JS lib...", "SeriesHE.to_pairs()": "Return a tuple of tuples, where each inner tuple is a pair of index label, value...", "SeriesHE.to_pandas()": "Return a Pandas Series. Returns: pandas.Series", "SeriesHE.to_series()": "Return a Series from this SeriesHE.", "SeriesHE.to_series_he()": "Return a SeriesHE from this Series.", "SeriesHE.to_visidata()": "Open an interactive VisiData session.", "SeriesHE.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "SeriesHE.T": "Transpose. For a 1D immutable container, this returns a reference to self. Retur...", "SeriesHE.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "SeriesHE.index": "The index instance assigned to this container. Returns: Index", "SeriesHE.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "SeriesHE.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "SeriesHE.name": "A hashable label attached to this container. Returns: Hashable", "SeriesHE.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "SeriesHE.ndim": "Return the number of dimensions, which for a Series is always 1. Returns: int", "SeriesHE.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: Tupl...", "SeriesHE.size": "Return the size of the underlying NumPy array. Returns: int", "SeriesHE.__array__()": "Support the __array__ interface, returning an array of values.", "SeriesHE.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "SeriesHE.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "SeriesHE.__deepcopy__()": "", "SeriesHE.__len__()": "Length of values.", "SeriesHE.__round__()": "Return a Series rounded to the given decimals. Negative decimals round to the le...", "SeriesHE.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "SeriesHE.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "SeriesHE.astype()": "Return a Series with type determined by dtype argument. Note that for Series, th...", "SeriesHE.clip()": "Apply a clip operation to this Series. Note that clip operations can be applied...", "SeriesHE.corr()": "Return the index-aligned correlation to the supplied Series. Args: other: Series...", "SeriesHE.count()": "Return the count of non-NA, non-falsy, and/or unique elements. Args: skipna: ski...", "SeriesHE.cov()": "Return the index-aligned covariance to the supplied Series. Args: ddof: Delta de...", "SeriesHE.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "SeriesHE.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "SeriesHE.drop_duplicated()": "Return a Series with duplicated values removed. Args: exclude_first: Boolean to...", "SeriesHE.dropfalsy()": "Return a new Series after removing values of falsy.", "SeriesHE.dropna()": "Return a new Series after removing values of NaN or None.", "SeriesHE.duplicated()": "Return a same-sized Boolean Series that shows True for all values that are dupli...", "SeriesHE.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "SeriesHE.fillfalsy()": "Return a new Series after replacing falsy values with the supplied value. The va...", "SeriesHE.fillfalsy_backward()": "Return a new Series after feeding backward the last non-falsy observation across...", "SeriesHE.fillfalsy_forward()": "Return a new Series after feeding forward the last non-falsy observation across...", "SeriesHE.fillfalsy_leading()": "Return a new Series after filling leading (and only leading) falsy values with t...", "SeriesHE.fillfalsy_trailing()": "Return a new Series after filling trailing (and only trailing) falsy values with...", "SeriesHE.fillna()": "Return a new Series after replacing NA (NaN or None) with the supplied value. Th...", "SeriesHE.fillna_backward()": "Return a new Series after feeding backward the last non-null (NaN or None) obser...", "SeriesHE.fillna_forward()": "Return a new Series after feeding forward the last non-null (NaN or None) observ...", "SeriesHE.fillna_leading()": "Return a new Series after filling leading (and only leading) null (NaN or None)...", "SeriesHE.fillna_trailing()": "Return a new Series after filling trailing (and only trailing) null (NaN or None...", "SeriesHE.head()": "Return a Series consisting only of the top elements as specified by count. Args:...", "SeriesHE.iloc_max()": "Return the integer index corresponding to the maximum value. Args: skipna: if Tr...", "SeriesHE.iloc_min()": "Return the integer index corresponding to the minimum value found. Args: skipna:...", "SeriesHE.iloc_notfalsy_first()": "Return the position corresponding to the first non-falsy (including nan) value f...", "SeriesHE.iloc_notfalsy_last()": "Return the position corresponding to the last non-falsy (including nan) value fo...", "SeriesHE.iloc_notna_first()": "Return the position corresponding to the first not NA (None or nan) value found....", "SeriesHE.iloc_notna_last()": "Return the position corresponding to the last not NA (None or nan) value found....", "SeriesHE.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "SeriesHE.insert_after()": "Create a new Series by inserting a Series at the position after the label specif...", "SeriesHE.insert_before()": "Create a new Series by inserting a Series at the position before the label speci...", "SeriesHE.isfalsy()": "Return a same-indexed, Boolean Series indicating which values are falsy.", "SeriesHE.isin()": "Return a same-sized Boolean Series that shows if the same-positioned element is...", "SeriesHE.isna()": "Return a same-indexed, Boolean Series indicating which values are NaN or None.", "SeriesHE.loc_max()": "Return the label corresponding to the maximum value found. Args: skipna: if True...", "SeriesHE.loc_min()": "Return the label corresponding to the minimum value found. Args: skipna: if True...", "SeriesHE.loc_notfalsy_first()": "Return the label corresponding to the first non-falsy (including nan) value foun...", "SeriesHE.loc_notfalsy_last()": "Return the label corresponding to the last non-falsy (including nan) value found...", "SeriesHE.loc_notna_first()": "Return the label corresponding to the first not NA (None or nan) value found. Ar...", "SeriesHE.loc_notna_last()": "Return the label corresponding to the last not NA (None or nan) value found. Arg...", "SeriesHE.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "SeriesHE.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "SeriesHE.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "SeriesHE.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "SeriesHE.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "SeriesHE.notfalsy()": "Return a same-indexed, Boolean Series indicating which values are falsy.", "SeriesHE.notna()": "Return a same-indexed, Boolean Series indicating which values are NaN or None.", "SeriesHE.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "SeriesHE.rank_dense()": "Rank values as compactly as possible, where ties get the same value, and ranks a...", "SeriesHE.rank_max()": "Rank values where tied values are assigned the maximum ordinal rank; ranks are p...", "SeriesHE.rank_mean()": "Rank values where tied values are assigned the mean of the ordinal ranks; ranks...", "SeriesHE.rank_min()": "Rank values where tied values are assigned the minimum ordinal rank; ranks are p...", "SeriesHE.rank_ordinal()": "Rank values distinctly, where ties get distinct values that maintain their order...", "SeriesHE.rehierarch()": "Return a new Series with new a hierarchy based on the supplied depth_map.", "SeriesHE.reindex()": "Return a new Series with labels defined by the provided index. The size and orde...", "SeriesHE.relabel()": "Return a new Series with transformed labels on the index. The size and ordering...", "SeriesHE.relabel_flat()": "Return a new Series, where an IndexHierarchy (if defined) is replaced with a fla...", "SeriesHE.relabel_level_add()": "Return a new Series, adding a new root level to an existing IndexHierarchy, or c...", "SeriesHE.relabel_level_drop()": "Return a new Series, dropping one or more levels from a either the root or the l...", "SeriesHE.rename()": "Return a new Series with an updated name attribute.", "SeriesHE.roll()": "Return a Series with values rotated forward and wrapped around the index (with a...", "SeriesHE.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "SeriesHE.shift()": "Return a Series with values shifted forward on the index (with a positive shift)...", "SeriesHE.sort_index()": "Return a new Series ordered by the sorted Index. Args: * ascendings: Boolean, or...", "SeriesHE.sort_values()": "Return a new Series ordered by the sorted values. Args: * ascending: If True, so...", "SeriesHE.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "SeriesHE.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "SeriesHE.tail()": "Return a Series consisting only of the bottom elements as specified by count. s...", "SeriesHE.transpose()": "Transpose. For a 1D immutable container, this returns a reference to self. Retur...", "SeriesHE.unique()": "Return a NumPy array of unique values. Returns: numpy.ndarray", "SeriesHE.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "SeriesHE.__contains__()": "Inclusion of value in index labels. Returns: bool", "SeriesHE.__iter__()": "Iterator of index labels, same as Series.keys. Returns: Iterator[Hashasble]", "SeriesHE.__reversed__()": "Returns a reverse iterator on the series' index. Returns: Index", "SeriesHE.get()": "Return the value found at the index key, else the default if the key is not foun...", "SeriesHE.items()": "Iterator of pairs of index label and value. Returns: Iterator[Tuple[Hashable, An...", "SeriesHE.keys()": "Iterator of index labels. Returns: Iterator[Hashable]", "SeriesHE.values": "", "SeriesHE.interface": "A Frame documenting the interface of this class.", "SeriesHE.__repr__()": "", "SeriesHE.__str__()": "Return str(self).", "SeriesHE.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "SeriesHE.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "SeriesHE.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "SeriesHE.assign[]()": "Assign the value in the position specified by the selector. The name attribute i...", "SeriesHE.assign[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "SeriesHE.assign[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "SeriesHE.assign[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "SeriesHE.assign.iloc[]()": "Assign the value in the position specified by the selector. The name attribute i...", "SeriesHE.assign.iloc[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "SeriesHE.assign.iloc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "SeriesHE.assign.iloc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "SeriesHE.assign.loc[]()": "Assign the value in the position specified by the selector. The name attribute i...", "SeriesHE.assign.loc[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "SeriesHE.assign.loc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "SeriesHE.assign.loc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "SeriesHE.drop[]": "Label-based selection.", "SeriesHE.drop.iloc[]": "", "SeriesHE.drop.loc[]": "", "SeriesHE.mask[]": "Label-based selection.", "SeriesHE.mask.iloc[]": "", "SeriesHE.mask.loc[]": "", "SeriesHE.masked_array[]": "Label-based selection.", "SeriesHE.masked_array.iloc[]": "", "SeriesHE.masked_array.loc[]": "", "SeriesHE.[]": "Selector of values by label. Args: key: A loc selector, either a label, a list o...", "SeriesHE.iloc[]": "Interface for position-based selection.", "SeriesHE.loc[]": "Interface for label-based selection.", "SeriesHE.iter_element()": "Iterator of elements.", "SeriesHE.iter_element().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_element().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_element().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_element().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_element().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "SeriesHE.iter_element().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "SeriesHE.iter_element().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "SeriesHE.iter_element().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "SeriesHE.iter_element().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "SeriesHE.iter_element().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "SeriesHE.iter_element().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "SeriesHE.iter_element().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "SeriesHE.iter_element().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "SeriesHE.iter_element_items()": "Iterator of label, element pairs.", "SeriesHE.iter_element_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_element_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_element_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_element_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_element_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "SeriesHE.iter_element_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "SeriesHE.iter_element_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "SeriesHE.iter_element_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "SeriesHE.iter_element_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "SeriesHE.iter_element_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "SeriesHE.iter_element_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "SeriesHE.iter_element_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "SeriesHE.iter_element_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "SeriesHE.iter_group()": "Iterator of Series, where each Series matches unique values.", "SeriesHE.iter_group().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_group().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_group().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_group().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_group_array()": "Iterator of Series, where each Series matches unique values.", "SeriesHE.iter_group_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_group_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_group_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_group_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_group_array_items()": "", "SeriesHE.iter_group_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_group_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_group_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_group_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_group_items()": "", "SeriesHE.iter_group_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_group_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_group_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_group_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_group_labels()": "", "SeriesHE.iter_group_labels().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_group_labels().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_group_labels().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_group_labels().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_group_labels_array()": "", "SeriesHE.iter_group_labels_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_group_labels_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_group_labels_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_group_labels_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_group_labels_array_items()": "", "SeriesHE.iter_group_labels_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_group_labels_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_group_labels_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_group_labels_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_group_labels_items()": "", "SeriesHE.iter_group_labels_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_group_labels_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_group_labels_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_group_labels_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_group_other()": "Iterator of Series, grouped by unique values found in the passed container.", "SeriesHE.iter_group_other().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_group_other().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_group_other().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_group_other().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_group_other_array()": "", "SeriesHE.iter_group_other_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_group_other_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_group_other_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_group_other_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_group_other_array_items()": "", "SeriesHE.iter_group_other_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_group_other_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_group_other_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_group_other_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_group_other_items()": "Iterator of pairs of label, Series, grouped by unique values found in the passed...", "SeriesHE.iter_group_other_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_group_other_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_group_other_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_group_other_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_window()": "", "SeriesHE.iter_window().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_window().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_window().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_window().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_window_array()": "", "SeriesHE.iter_window_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_window_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_window_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_window_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_window_array_items()": "", "SeriesHE.iter_window_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_window_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_window_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_window_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.iter_window_items()": "", "SeriesHE.iter_window_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "SeriesHE.iter_window_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "SeriesHE.iter_window_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "SeriesHE.iter_window_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "SeriesHE.__add__()": "", "SeriesHE.__and__()": "", "SeriesHE.__eq__()": "Return True if other is a Series with the same labels, values, and name. Contain...", "SeriesHE.__floordiv__()": "", "SeriesHE.__ge__()": "", "SeriesHE.__gt__()": "", "SeriesHE.__le__()": "", "SeriesHE.__lt__()": "", "SeriesHE.__matmul__()": "", "SeriesHE.__mod__()": "", "SeriesHE.__mul__()": "", "SeriesHE.__ne__()": "Return False if other is a Series with the same labels, values, and name. Contai...", "SeriesHE.__or__()": "", "SeriesHE.__pow__()": "", "SeriesHE.__radd__()": "", "SeriesHE.__rfloordiv__()": "", "SeriesHE.__rmatmul__()": "", "SeriesHE.__rmul__()": "", "SeriesHE.__rshift__()": "", "SeriesHE.__rsub__()": "", "SeriesHE.__rtruediv__()": "", "SeriesHE.__sub__()": "", "SeriesHE.__truediv__()": "", "SeriesHE.__xor__()": "", "SeriesHE.__abs__()": "", "SeriesHE.__invert__()": "", "SeriesHE.__neg__()": "", "SeriesHE.__pos__()": "", "SeriesHE.via_values.apply()": "", "SeriesHE.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "SeriesHE.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "SeriesHE.via_dt.year": "Return the year of each element.", "SeriesHE.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "SeriesHE.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "SeriesHE.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "SeriesHE.via_dt.hour": "Return the hour of each element, between 0 and 24.", "SeriesHE.via_dt.minute": "Return the minute of each element, between 0 and 60.", "SeriesHE.via_dt.second": "Return the second of each element, between 0 and 60.", "SeriesHE.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "SeriesHE.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "SeriesHE.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "SeriesHE.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "SeriesHE.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "SeriesHE.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "SeriesHE.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "SeriesHE.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "SeriesHE.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "SeriesHE.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "SeriesHE.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "SeriesHE.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "SeriesHE.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "SeriesHE.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "SeriesHE.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "SeriesHE.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "SeriesHE.via_str.center()": "Return a container with its elements centered in a string of length width.", "SeriesHE.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "SeriesHE.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "SeriesHE.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "SeriesHE.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "SeriesHE.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "SeriesHE.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "SeriesHE.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "SeriesHE.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "SeriesHE.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "SeriesHE.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "SeriesHE.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "SeriesHE.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "SeriesHE.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "SeriesHE.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "SeriesHE.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "SeriesHE.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "SeriesHE.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "SeriesHE.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "SeriesHE.via_str.len()": "Return the length of the string.", "SeriesHE.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "SeriesHE.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "SeriesHE.via_str.partition()": "Partition each element around sep.", "SeriesHE.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "SeriesHE.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "SeriesHE.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "SeriesHE.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "SeriesHE.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "SeriesHE.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "SeriesHE.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "SeriesHE.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "SeriesHE.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "SeriesHE.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "SeriesHE.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "SeriesHE.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "SeriesHE.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "SeriesHE.via_str.zfill()": "Return the string left-filled with zeros.", "SeriesHE.via_fill_value().loc": "Label-based selection where labels not specified will define a new container con...", "SeriesHE.via_fill_value().__getitem__()": "Label-based selection where labels not specified will define a new container con...", "SeriesHE.via_fill_value().via_T": "Interface for using binary operators with one-dimensional sequences, where the o...", "SeriesHE.via_fill_value().__add__()": "", "SeriesHE.via_fill_value().__sub__()": "", "SeriesHE.via_fill_value().__mul__()": "", "SeriesHE.via_fill_value().__truediv__()": "", "SeriesHE.via_fill_value().__floordiv__()": "", "SeriesHE.via_fill_value().__mod__()": "", "SeriesHE.via_fill_value().__pow__()": "", "SeriesHE.via_fill_value().__lshift__()": "", "SeriesHE.via_fill_value().__rshift__()": "", "SeriesHE.via_fill_value().__and__()": "", "SeriesHE.via_fill_value().__xor__()": "", "SeriesHE.via_fill_value().__or__()": "", "SeriesHE.via_fill_value().__lt__()": "", "SeriesHE.via_fill_value().__le__()": "", "SeriesHE.via_fill_value().__eq__()": "", "SeriesHE.via_fill_value().__ne__()": "", "SeriesHE.via_fill_value().__gt__()": "", "SeriesHE.via_fill_value().__ge__()": "", "SeriesHE.via_fill_value().__radd__()": "", "SeriesHE.via_fill_value().__rsub__()": "", "SeriesHE.via_fill_value().__rmul__()": "", "SeriesHE.via_fill_value().__rtruediv__()": "", "SeriesHE.via_fill_value().__rfloordiv__()": "", "SeriesHE.via_re().search()": "Scan through string looking for the first location where this regular expression...", "SeriesHE.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "SeriesHE.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "SeriesHE.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "SeriesHE.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "SeriesHE.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "SeriesHE.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "SeriesHE.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "SeriesHE.via_hashlib().md5()": "", "SeriesHE.via_hashlib().sha256()": "", "SeriesHE.via_hashlib().sha512()": "", "SeriesHE.via_hashlib().sha3_256()": "", "SeriesHE.via_hashlib().sha3_512()": "", "SeriesHE.via_hashlib().shake_128()": "", "SeriesHE.via_hashlib().shake_256()": "", "SeriesHE.via_hashlib().blake2b()": "", "SeriesHE.via_hashlib().blake2s()": "", "Frame.__init__()": "Initializer. Args: data: Default Frame initialization requires typed data such a...", "Frame.from_arrow()": "Realize a Frame from an Arrow Table. Args: value: A pyarrow.Table instance. inde...", "Frame.from_clipboard()": "Create a Frame from the contents of the clipboard (assuming a table is stored as...", "Frame.from_concat()": "Concatenate multiple Frame or Series into a new Frame. If index or columns are p...", "Frame.from_concat_items()": "Produce a Frame with a hierarchical index from an iterable of pairs of labels, F...", "Frame.from_csv()": "Specialized version of Frame.from_delimited for CSV files. Returns: Frame", "Frame.from_delimited()": "Create a Frame from a file path or a file-like object defining a delimited (CSV,...", "Frame.from_dict()": "Create a Frame from a dictionary (or any object that has an items() method) wher...", "Frame.from_dict_fields()": "Frame constructor from an iterable of dictionaries, where each dictionary repres...", "Frame.from_dict_records()": "Frame constructor from an iterable of dictionaries, where each dictionary repres...", "Frame.from_dict_records_items()": "Frame constructor from iterable of pairs of index label, row, where row is a dic...", "Frame.from_element()": "Create a Frame from an element, i.e., a single value stored in a single cell. Bo...", "Frame.from_element_items()": "Create a Frame from an iterable of key, value, where key is a pair of row, colum...", "Frame.from_elements()": "Create a Frame from an iterable of elements, to be formed into a Frame with a si...", "Frame.from_fields()": "Frame constructor from an iterator of columns, where columns are iterables. Seri...", "Frame.from_hdf5()": "Load Frame from the contents of a table in an HDF5 file.", "Frame.from_items()": "Frame constructor from an iterator of pairs, where the first value is the column...", "Frame.from_json()": "Frame constructor from an in-memory JSON document. Args: json_data: a string of...", "Frame.from_json_columns()": "Frame constructor from an in-memory JSON document in the following format: A JSO...", "Frame.from_json_index()": "Frame constructor from an in-memory JSON document in the following format: A JSO...", "Frame.from_json_records()": "Frame constructor from an in-memory JSON document in the following format: A JSO...", "Frame.from_json_split()": "Frame constructor from an in-memory JSON document in the following format: A JSO...", "Frame.from_json_url()": "Frame constructor from a JSON documenst provided via a URL. Args: url: URL to th...", "Frame.from_json_values()": "Frame constructor from an in-memory JSON document in the following format: A JSO...", "Frame.from_msgpack()": "Frame constructor from an in-memory binary object formatted as a msgpack. Args:...", "Frame.from_npy()": "Create a Frame from an directory of npy files. Args: fp: The path to the NPY dir...", "Frame.from_npy_mmap()": "Create a Frame from an directory of npy files using memory maps. Args: fp: The p...", "Frame.from_npz()": "Create a Frame from an npz file.", "Frame.from_overlay()": "Return a new Frame made by overlaying containers, filling in values with aligned...", "Frame.from_pandas()": "Given a Pandas DataFrame, return a Frame. Args: value: Pandas DataFrame. index_c...", "Frame.from_parquet()": "Realize a Frame from a Parquet file. Args: fp: A string file path or Path instan...", "Frame.from_pickle()": "Create a Frame from a pickle file. The pickle module is not secure. Only unpickl...", "Frame.from_records()": "Construct a Frame from an iterable of rows, where rows are defined as iterables,...", "Frame.from_records_items()": "Frame constructor from iterable of pairs of index value, row (where row is an it...", "Frame.from_series()": "Frame constructor from a Series: Args: series: A Series instance, to be realized...", "Frame.from_sql()": "Frame constructor from an SQL query and a database connection object. Args: quer...", "Frame.from_sqlite()": "Load Frame from the contents of a table in an SQLite database file.", "Frame.from_structured_array()": "Convert a NumPy structed array into a Frame. Args: array: Structured NumPy array...", "Frame.from_tsv()": "Specialized version of Frame.from_delimited for TSV files. Returns: Frame", "Frame.from_xlsx()": "Load Frame from the contents of a sheet in an XLSX workbook. Args: label: Option...", "Frame.to_arrow()": "Return a pyarrow.Table from this Frame.", "Frame.to_clipboard()": "Given a file path or file-like object, write the Frame as delimited text. The de...", "Frame.to_csv()": "Given a file path or file-like object, write the Frame as delimited text. The de...", "Frame.to_delimited()": "Given a file path or file-like object, write the Frame as delimited text. A deli...", "Frame.to_frame()": "Return Frame instance from this Frame. If this Frame is immutable the same insta...", "Frame.to_frame_go()": "Return a FrameGO instance from this Frame.", "Frame.to_frame_he()": "Return a FrameHE instance from this Frame. If this Frame is immutable the same i...", "Frame.to_hdf5()": "Write the Frame as single-table SQLite file.", "Frame.to_html()": "Return an HTML table representation of this Frame using standard TABLE, TR, and...", "Frame.to_html_datatables()": "Return a complete HTML representation of this Frame using the DataTables JS libr...", "Frame.to_json_columns()": "Export a Frame as a JSON string constructored as follows: A JSON object keyed by...", "Frame.to_json_index()": "Export a Frame as a JSON string constructored as follows: A JSON object keyed by...", "Frame.to_json_records()": "Export a Frame as a JSON string constructored as follows: A JSON array of row ob...", "Frame.to_json_split()": "Export a Frame as a JSON string constructored as follows: A JSON object with a k...", "Frame.to_json_values()": "Export a Frame as a JSON string constructored as follows: A JSON array of arrays...", "Frame.to_latex()": "Display the Frame as a LaTeX formatted table.", "Frame.to_markdown()": "Display the Frame as a Markdown formatted table.", "Frame.to_msgpack()": "Return msgpack bytes.", "Frame.to_npy()": "Write a Frame as a directory of npy file.", "Frame.to_npz()": "Write a Frame as an npz file.", "Frame.to_pairs()": "Return a tuple of major axis key, minor axis key vlaue pairs, where major axis i...", "Frame.to_pandas()": "Return a Pandas DataFrame.", "Frame.to_parquet()": "Write an Arrow Parquet binary file.", "Frame.to_pickle()": "Write a Frame as a Python pickle. The pickle module is not secure. Only unpickle...", "Frame.to_rst()": "Display the Frame as an RST formatted table.", "Frame.to_series()": "Return a Series representation of this Frame, where the index is extended with c...", "Frame.to_sqlite()": "Write the Frame as single-table SQLite file.", "Frame.to_tsv()": "Given a file path or file-like object, write the Frame as delimited text. The de...", "Frame.to_visidata()": "Open an interactive VisiData session.", "Frame.to_xarray()": "Return an xarray Dataset. In order to preserve columnar types, and following the...", "Frame.to_xlsx()": "Write the Frame as single-sheet XLSX file.", "Frame.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "Frame.T": "Transpose. Return a Frame with index as columns and vice versa.", "Frame.columns": "The IndexBase instance assigned for column labels.", "Frame.dtypes": "Return a Series of dytpes for each realizable column. Returns: Series", "Frame.index": "The IndexBase instance assigned for row labels.", "Frame.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "Frame.mloc": "The memory locations, represented as an array of integers, of the underlying Num...", "Frame.name": "A hashable label attached to this container. Returns: Hashable", "Frame.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "Frame.ndim": "Return the number of dimensions, which for a Frame is always 2. Returns: int", "Frame.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "Frame.size": "Return the size of the underlying NumPy array. Returns: int", "Frame.__array__()": "Support the __array__ interface, returning an array of values.", "Frame.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "Frame.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "Frame.__dataframe__()": "Return a data-frame interchange protocol compliant object. See https://data-apis...", "Frame.__deepcopy__()": "", "Frame.__len__()": "Length of rows in values.", "Frame.__round__()": "Return a Frame rounded to the given decimals. Negative decimals round to the lef...", "Frame.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "Frame.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "Frame.astype[]()": "Selector of columns by label. Args: key: A loc selector, either a label, a list...", "Frame.astype()": "Apply a single dtype to all columns.", "Frame.clip()": "Apply a clip operation to this Frame. Note that clip operations can be applied t...", "Frame.corr()": "Compute a correlation matrix. Args: axis: if 0, each row represents a variable,...", "Frame.count()": "Return the count of non-NA values along the provided axis, where 0 provides coun...", "Frame.cov()": "Compute a covariance matrix. Args: axis: if 0, each row represents a variable, w...", "Frame.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "Frame.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "Frame.drop_duplicated()": "Return a Frame with duplicated rows (axis 0) or columns (axis 1) removed. All va...", "Frame.dropfalsy()": "Return a new Frame after removing rows (axis 0) or columns (axis 1) where any or...", "Frame.dropna()": "Return a new Frame after removing rows (axis 0) or columns (axis 1) where any or...", "Frame.duplicated()": "Return an axis-sized Boolean Series that shows True for all rows (axis 0) or col...", "Frame.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "Frame.fillfalsy()": "Return a new Frame after replacing falsy values with the supplied value. Args: v...", "Frame.fillfalsy_backward()": "Return a new Frame after filling backward falsy values with the first observed v...", "Frame.fillfalsy_forward()": "Return a new Frame after filling forward falsy values with the last observed val...", "Frame.fillfalsy_leading()": "Return a new Frame after filling leading (and only leading) falsy values with th...", "Frame.fillfalsy_trailing()": "Return a new Frame after filling trailing (and only trailing) falsy values with...", "Frame.fillna()": "Return a new Frame after replacing null (NaN or None) values with the supplied v...", "Frame.fillna_backward()": "Return a new Frame after filling backward null (NaN or None) with the first obse...", "Frame.fillna_forward()": "Return a new Frame after filling forward null (NaN or None) with the last observ...", "Frame.fillna_leading()": "Return a new Frame after filling leading (and only leading) null (NaN or None) w...", "Frame.fillna_trailing()": "Return a new Frame after filling trailing (and only trailing) null (NaN or None)...", "Frame.head()": "Return a Frame consisting only of the top elements as specified by count. Args:...", "Frame.iloc_max()": "Return the integer indices corresponding to the maximum values found. Args: skip...", "Frame.iloc_min()": "Return the integer indices corresponding to the minimum values found. Args: skip...", "Frame.iloc_notfalsy_first()": "Return the position corresponding to the first non-falsy (including nan) values...", "Frame.iloc_notfalsy_last()": "Return the position corresponding to the last non-falsy (including nan) values a...", "Frame.iloc_notna_first()": "Return the position corresponding to the first non-missing values along the sele...", "Frame.iloc_notna_last()": "Return the position corresponding to the last non-missing values along the selec...", "Frame.insert_after()": "Create a new Frame by inserting a named Series or Frame at the position after th...", "Frame.insert_before()": "Create a new Frame by inserting a named Series or Frame at the position before t...", "Frame.isfalsy()": "Return a same-indexed, Boolean Frame indicating True which values are falsy.", "Frame.isin()": "Return a same-sized Boolean Frame that shows if the same-positioned element is i...", "Frame.isna()": "Return a same-indexed, Boolean Frame indicating True which values are NaN or Non...", "Frame.join_inner()": "Perform an inner join. Args: left_depth_level: Specify one or more left index de...", "Frame.join_left()": "Perform a left outer join. Args: left_depth_level: Specify one or more left inde...", "Frame.join_outer()": "Perform an outer join. Args: left_depth_level: Specify one or more left index de...", "Frame.join_right()": "Perform a right outer join. Args: left_depth_level: Specify one or more left ind...", "Frame.loc_max()": "Return the labels corresponding to the maximum values found. Args: skipna: if Tr...", "Frame.loc_min()": "Return the labels corresponding to the minimum value found. Args: skipna: if Tru...", "Frame.loc_notfalsy_first()": "Return the labels corresponding to the first non-falsy (including nan) values al...", "Frame.loc_notfalsy_last()": "Return the labels corresponding to the last non-falsy (including nan) values alo...", "Frame.loc_notna_first()": "Return the labels corresponding to the first non-missing values along the select...", "Frame.loc_notna_last()": "Return the labels corresponding to the last non-missing values along the selecte...", "Frame.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "Frame.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "Frame.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "Frame.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "Frame.notfalsy()": "Return a same-indexed, Boolean Frame indicating True which values are not falsy.", "Frame.notna()": "Return a same-indexed, Boolean Frame indicating True which values are not NaN or...", "Frame.pivot()": "Produce a pivot table, where one or more columns is selected for each of index_f...", "Frame.pivot_stack()": "Move labels from the columns to the index, creating or extending an IndexHierarc...", "Frame.pivot_unstack()": "Move labels from the index to the columns, creating or extending an IndexHierarc...", "Frame.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "Frame.rank_dense()": "Rank values as compactly as possible, where ties get the same value, and ranks a...", "Frame.rank_max()": "Rank values where tied values are assigned the maximum ordinal rank; ranks are p...", "Frame.rank_mean()": "Rank values where tied values are assigned the mean of the ordinal ranks; ranks...", "Frame.rank_min()": "Rank values where tied values are assigned the minimum ordinal rank; ranks are p...", "Frame.rank_ordinal()": "Rank values distinctly, where ties get distinct values that maintain their order...", "Frame.rehierarch()": "Produce a new Frame with index and/or columns constructed with a transformed hie...", "Frame.reindex()": "Return a new Frame with labels defined by the provided index. The size and order...", "Frame.relabel()": "Return a new Frame with transformed labels on the index. The size and ordering o...", "Frame.relabel_flat()": "Return a new Frame, where an IndexHierarchy (if defined) is replaced with a flat...", "Frame.relabel_level_add()": "Return a new Frame, adding a new root level to an existing IndexHierarchy, or cr...", "Frame.relabel_level_drop()": "Return a new Frame, dropping one or more levels from a either the root or the le...", "Frame.relabel_shift_in()": "Create, or augment, an IndexHierarchy by providing one or more selections from t...", "Frame.relabel_shift_out()": "Shift values from an index on an axis to the Frame by providing one or more dept...", "Frame.rename()": "Return a new Frame with an updated name attribute. Optionally update the name at...", "Frame.roll()": "Roll columns and/or rows by positive or negative integer counts, where columns a...", "Frame.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "Frame.set_columns()": "Return a new Frame produced by setting the given row as the columns, optionally...", "Frame.set_columns_hierarchy()": "Given an iterable of index labels, return a new Frame with those rows as an Inde...", "Frame.set_index()": "Return a new Frame produced by setting the given column as the index, optionally...", "Frame.set_index_hierarchy()": "Given an iterable of column labels, return a new Frame with those columns as an...", "Frame.shift()": "Shift columns and/or rows by positive or negative integer counts, where columns...", "Frame.sort_columns()": "Return a new Frame ordered by the sorted columns. Args: ascendings: Boolean, or...", "Frame.sort_index()": "Return a new Frame ordered by the sorted Index. Args: ascendings: Boolean, or it...", "Frame.sort_values()": "Return a new Frame ordered by the sorted values, where values are given by singl...", "Frame.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "Frame.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "Frame.tail()": "Return a Frame consisting only of the bottom elements as specified by count. Arg...", "Frame.transpose()": "Transpose. Return a Frame with index as columns and vice versa.", "Frame.unique()": "Return a NumPy array of unqiue values. If the axis argument is provied, uniquene...", "Frame.unset_columns()": "Return a new Frame where columns are added to the top of the data, and an IndexA...", "Frame.unset_index()": "Return a new Frame where the index is added to the front of the data, and an Ind...", "Frame.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "Frame.__contains__()": "Inclusion of value in column labels.", "Frame.__iter__()": "Iterator of column labels, same as Frame.keys.", "Frame.__reversed__()": "Returns a reverse iterator on the frame's columns.", "Frame.get()": "Return the value found at the columns key, else the default if the key is not fo...", "Frame.items()": "Iterator of pairs of column label and corresponding column Series.", "Frame.keys()": "Iterator of column labels.", "Frame.values": "A 2D NumPy array of all values in the Frame. As this is a single array, heteroge...", "Frame.interface": "A Frame documenting the interface of this class.", "Frame.__repr__()": "", "Frame.__str__()": "Return str(self).", "Frame.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "Frame.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "Frame.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "Frame.assign[]()": "Assign the value in the position specified by the selector. The name attribute i...", "Frame.assign[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "Frame.assign[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "Frame.assign[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "Frame.assign.iloc[]()": "Assign the value in the position specified by the selector. The name attribute i...", "Frame.assign.iloc[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "Frame.assign.iloc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "Frame.assign.iloc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "Frame.assign.loc[]()": "Assign the value in the position specified by the selector. The name attribute i...", "Frame.assign.loc[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "Frame.assign.loc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "Frame.assign.loc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "Frame.assign.bloc[]()": "Assign the value in the position specified by the selector. The name attribute i...", "Frame.assign.bloc[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "Frame.assign.bloc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "Frame.assign.bloc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "Frame.bloc[]": "", "Frame.drop[]": "Label-based selection.", "Frame.drop.iloc[]": "", "Frame.drop.loc[]": "", "Frame.mask[]": "Label-based selection.", "Frame.mask.iloc[]": "", "Frame.mask.loc[]": "", "Frame.masked_array[]": "Label-based selection.", "Frame.masked_array.iloc[]": "", "Frame.masked_array.loc[]": "", "Frame.[]": "Selector of columns by label. Args: key: A loc selector, either a label, a list...", "Frame.iloc[]": "", "Frame.loc[]": "", "Frame.iter_array()": "Iterator of np.array, where arrays are drawn from columns (axis=0) or rows (axis...", "Frame.iter_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_array_items()": "Iterator of pairs of label, np.array, where arrays are drawn from columns (axis=...", "Frame.iter_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_element()": "Iterator of elements, ordered by row then column.", "Frame.iter_element().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_element().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_element().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_element().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_element().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "Frame.iter_element().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "Frame.iter_element().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "Frame.iter_element().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "Frame.iter_element().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "Frame.iter_element().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "Frame.iter_element().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "Frame.iter_element().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "Frame.iter_element().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "Frame.iter_element_items()": "Iterator of pairs of label, element, where labels are pairs of index, columns la...", "Frame.iter_element_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_element_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_element_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_element_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_element_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "Frame.iter_element_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "Frame.iter_element_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "Frame.iter_element_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "Frame.iter_element_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "Frame.iter_element_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "Frame.iter_element_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "Frame.iter_element_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "Frame.iter_element_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "Frame.iter_group()": "Iterator of Frame grouped by unique values found in one or more columns (axis=0)...", "Frame.iter_group().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_group().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_group().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_group().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_group_array()": "Iterator of np.ndarray grouped by unique values found in one or more columns (ax...", "Frame.iter_group_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_group_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_group_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_group_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_group_array_items()": "Iterator of pairs of label, np.ndarray grouped by unique values found in one or...", "Frame.iter_group_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_group_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_group_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_group_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_group_items()": "Iterator of pairs of label, Frame grouped by unique values found in one or more...", "Frame.iter_group_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_group_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_group_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_group_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_group_labels()": "Iterator of Frame grouped by unique labels found in one or more index depths (ax...", "Frame.iter_group_labels().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_group_labels().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_group_labels().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_group_labels().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_group_labels_array()": "Iterator of np.ndarray grouped by unique labels found in one or more index depth...", "Frame.iter_group_labels_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_group_labels_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_group_labels_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_group_labels_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_group_labels_array_items()": "Iterator of pairs of label, np.ndarray grouped by unique labels found in one or...", "Frame.iter_group_labels_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_group_labels_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_group_labels_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_group_labels_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_group_labels_items()": "Iterator of pairs of label, Frame grouped by unique labels found in one or more...", "Frame.iter_group_labels_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_group_labels_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_group_labels_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_group_labels_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_group_other()": "Iterator of Frame grouped by unique values found in a supplied container.", "Frame.iter_group_other().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_group_other().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_group_other().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_group_other().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_group_other_array()": "Iterator of Frame grouped by unique values found in a supplied container.", "Frame.iter_group_other_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_group_other_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_group_other_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_group_other_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_group_other_array_items()": "Iterator of Frame grouped by unique values found in a supplied container.", "Frame.iter_group_other_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_group_other_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_group_other_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_group_other_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_group_other_items()": "Iterator of Frame grouped by unique values found in a supplied container.", "Frame.iter_group_other_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_group_other_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_group_other_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_group_other_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_series()": "Iterator of Series, where Series are drawn from columns (axis=0) or rows (axis=1...", "Frame.iter_series().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_series().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_series().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_series().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_series_items()": "Iterator of pairs of label, Series, where Series are drawn from columns (axis=0)...", "Frame.iter_series_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_series_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_series_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_series_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_tuple()": "Iterator of NamedTuple, where tuples are drawn from columns (axis=0) or rows (ax...", "Frame.iter_tuple().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_tuple().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_tuple().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_tuple().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_tuple().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "Frame.iter_tuple().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "Frame.iter_tuple().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "Frame.iter_tuple().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "Frame.iter_tuple().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "Frame.iter_tuple().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "Frame.iter_tuple().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "Frame.iter_tuple().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "Frame.iter_tuple().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "Frame.iter_tuple_items()": "Iterator of pairs of label, NamedTuple, where tuples are drawn from columns (axi...", "Frame.iter_tuple_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_tuple_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_tuple_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_tuple_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_tuple_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "Frame.iter_tuple_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "Frame.iter_tuple_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "Frame.iter_tuple_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "Frame.iter_tuple_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "Frame.iter_tuple_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "Frame.iter_tuple_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "Frame.iter_tuple_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "Frame.iter_tuple_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "Frame.iter_window()": "Iterator of windowed values, where values are given as a Frame. Args: size: Elem...", "Frame.iter_window().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_window().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_window().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_window().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_window_array()": "Iterator of windowed values, where values are given as a np.array. Args: size: E...", "Frame.iter_window_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_window_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_window_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_window_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_window_array_items()": "Iterator of pairs of label, windowed values, where values are given as a np.arra...", "Frame.iter_window_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_window_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_window_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_window_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.iter_window_items()": "Iterator of pairs of label, windowed values, where values are given as a Frame....", "Frame.iter_window_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Frame.iter_window_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Frame.iter_window_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Frame.iter_window_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Frame.__add__()": "", "Frame.__and__()": "", "Frame.__eq__()": "", "Frame.__floordiv__()": "", "Frame.__ge__()": "", "Frame.__gt__()": "", "Frame.__le__()": "", "Frame.__lt__()": "", "Frame.__matmul__()": "", "Frame.__mod__()": "", "Frame.__mul__()": "", "Frame.__ne__()": "", "Frame.__or__()": "", "Frame.__pow__()": "", "Frame.__radd__()": "", "Frame.__rfloordiv__()": "", "Frame.__rmatmul__()": "", "Frame.__rmul__()": "", "Frame.__rshift__()": "", "Frame.__rsub__()": "", "Frame.__rtruediv__()": "", "Frame.__sub__()": "", "Frame.__truediv__()": "", "Frame.__xor__()": "", "Frame.__abs__()": "", "Frame.__invert__()": "", "Frame.__neg__()": "", "Frame.__pos__()": "", "Frame.via_values.apply()": "", "Frame.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "Frame.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "Frame.via_dt.year": "Return the year of each element.", "Frame.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "Frame.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "Frame.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "Frame.via_dt.hour": "Return the hour of each element, between 0 and 24.", "Frame.via_dt.minute": "Return the minute of each element, between 0 and 60.", "Frame.via_dt.second": "Return the second of each element, between 0 and 60.", "Frame.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "Frame.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "Frame.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "Frame.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "Frame.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "Frame.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "Frame.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "Frame.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "Frame.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "Frame.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "Frame.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "Frame.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "Frame.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "Frame.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "Frame.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "Frame.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "Frame.via_str.center()": "Return a container with its elements centered in a string of length width.", "Frame.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "Frame.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "Frame.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "Frame.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "Frame.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "Frame.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "Frame.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "Frame.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "Frame.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "Frame.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "Frame.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "Frame.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "Frame.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "Frame.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "Frame.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "Frame.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "Frame.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "Frame.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "Frame.via_str.len()": "Return the length of the string.", "Frame.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "Frame.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "Frame.via_str.partition()": "Partition each element around sep.", "Frame.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "Frame.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "Frame.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "Frame.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "Frame.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "Frame.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "Frame.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "Frame.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "Frame.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "Frame.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "Frame.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "Frame.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "Frame.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "Frame.via_str.zfill()": "Return the string left-filled with zeros.", "Frame.via_T.via_fill_value()": "Interface for using binary operators and methods with a pre-defined fill value.", "Frame.via_T.__add__()": "", "Frame.via_T.__sub__()": "", "Frame.via_T.__mul__()": "", "Frame.via_T.__truediv__()": "", "Frame.via_T.__floordiv__()": "", "Frame.via_T.__mod__()": "", "Frame.via_T.__pow__()": "", "Frame.via_T.__lshift__()": "", "Frame.via_T.__rshift__()": "", "Frame.via_T.__and__()": "", "Frame.via_T.__xor__()": "", "Frame.via_T.__or__()": "", "Frame.via_T.__lt__()": "", "Frame.via_T.__le__()": "", "Frame.via_T.__eq__()": "", "Frame.via_T.__ne__()": "", "Frame.via_T.__gt__()": "", "Frame.via_T.__ge__()": "", "Frame.via_T.__radd__()": "", "Frame.via_T.__rsub__()": "", "Frame.via_T.__rmul__()": "", "Frame.via_T.__rtruediv__()": "", "Frame.via_T.__rfloordiv__()": "", "Frame.via_fill_value().loc": "Label-based selection where labels not specified will define a new container con...", "Frame.via_fill_value().__getitem__()": "Label-based selection where labels not specified will define a new container con...", "Frame.via_fill_value().via_T": "Interface for using binary operators with one-dimensional sequences, where the o...", "Frame.via_fill_value().__add__()": "", "Frame.via_fill_value().__sub__()": "", "Frame.via_fill_value().__mul__()": "", "Frame.via_fill_value().__truediv__()": "", "Frame.via_fill_value().__floordiv__()": "", "Frame.via_fill_value().__mod__()": "", "Frame.via_fill_value().__pow__()": "", "Frame.via_fill_value().__lshift__()": "", "Frame.via_fill_value().__rshift__()": "", "Frame.via_fill_value().__and__()": "", "Frame.via_fill_value().__xor__()": "", "Frame.via_fill_value().__or__()": "", "Frame.via_fill_value().__lt__()": "", "Frame.via_fill_value().__le__()": "", "Frame.via_fill_value().__eq__()": "", "Frame.via_fill_value().__ne__()": "", "Frame.via_fill_value().__gt__()": "", "Frame.via_fill_value().__ge__()": "", "Frame.via_fill_value().__radd__()": "", "Frame.via_fill_value().__rsub__()": "", "Frame.via_fill_value().__rmul__()": "", "Frame.via_fill_value().__rtruediv__()": "", "Frame.via_fill_value().__rfloordiv__()": "", "Frame.via_re().search()": "Scan through string looking for the first location where this regular expression...", "Frame.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "Frame.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "Frame.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "Frame.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "Frame.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "Frame.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "Frame.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "Frame.via_hashlib().md5()": "", "Frame.via_hashlib().sha256()": "", "Frame.via_hashlib().sha512()": "", "Frame.via_hashlib().sha3_256()": "", "Frame.via_hashlib().sha3_512()": "", "Frame.via_hashlib().shake_128()": "", "Frame.via_hashlib().shake_256()": "", "Frame.via_hashlib().blake2b()": "", "Frame.via_hashlib().blake2s()": "", "FrameGO.__init__()": "Initializer. Args: data: Default Frame initialization requires typed data such a...", "FrameGO.from_arrow()": "Realize a Frame from an Arrow Table. Args: value: A pyarrow.Table instance. inde...", "FrameGO.from_clipboard()": "Create a Frame from the contents of the clipboard (assuming a table is stored as...", "FrameGO.from_concat()": "Concatenate multiple Frame or Series into a new Frame. If index or columns are p...", "FrameGO.from_concat_items()": "Produce a Frame with a hierarchical index from an iterable of pairs of labels, F...", "FrameGO.from_csv()": "Specialized version of Frame.from_delimited for CSV files. Returns: Frame", "FrameGO.from_delimited()": "Create a Frame from a file path or a file-like object defining a delimited (CSV,...", "FrameGO.from_dict()": "Create a Frame from a dictionary (or any object that has an items() method) wher...", "FrameGO.from_dict_fields()": "Frame constructor from an iterable of dictionaries, where each dictionary repres...", "FrameGO.from_dict_records()": "Frame constructor from an iterable of dictionaries, where each dictionary repres...", "FrameGO.from_dict_records_items()": "Frame constructor from iterable of pairs of index label, row, where row is a dic...", "FrameGO.from_element()": "Create a Frame from an element, i.e., a single value stored in a single cell. Bo...", "FrameGO.from_element_items()": "Create a Frame from an iterable of key, value, where key is a pair of row, colum...", "FrameGO.from_elements()": "Create a Frame from an iterable of elements, to be formed into a Frame with a si...", "FrameGO.from_fields()": "Frame constructor from an iterator of columns, where columns are iterables. Seri...", "FrameGO.from_hdf5()": "Load Frame from the contents of a table in an HDF5 file.", "FrameGO.from_items()": "Frame constructor from an iterator of pairs, where the first value is the column...", "FrameGO.from_json()": "Frame constructor from an in-memory JSON document. Args: json_data: a string of...", "FrameGO.from_json_columns()": "Frame constructor from an in-memory JSON document in the following format: A JSO...", "FrameGO.from_json_index()": "Frame constructor from an in-memory JSON document in the following format: A JSO...", "FrameGO.from_json_records()": "Frame constructor from an in-memory JSON document in the following format: A JSO...", "FrameGO.from_json_split()": "Frame constructor from an in-memory JSON document in the following format: A JSO...", "FrameGO.from_json_url()": "Frame constructor from a JSON documenst provided via a URL. Args: url: URL to th...", "FrameGO.from_json_values()": "Frame constructor from an in-memory JSON document in the following format: A JSO...", "FrameGO.from_msgpack()": "Frame constructor from an in-memory binary object formatted as a msgpack. Args:...", "FrameGO.from_npy()": "Create a Frame from an directory of npy files. Args: fp: The path to the NPY dir...", "FrameGO.from_npy_mmap()": "Create a Frame from an directory of npy files using memory maps. Args: fp: The p...", "FrameGO.from_npz()": "Create a Frame from an npz file.", "FrameGO.from_overlay()": "Return a new Frame made by overlaying containers, filling in values with aligned...", "FrameGO.from_pandas()": "Given a Pandas DataFrame, return a Frame. Args: value: Pandas DataFrame. index_c...", "FrameGO.from_parquet()": "Realize a Frame from a Parquet file. Args: fp: A string file path or Path instan...", "FrameGO.from_pickle()": "Create a Frame from a pickle file. The pickle module is not secure. Only unpickl...", "FrameGO.from_records()": "Construct a Frame from an iterable of rows, where rows are defined as iterables,...", "FrameGO.from_records_items()": "Frame constructor from iterable of pairs of index value, row (where row is an it...", "FrameGO.from_series()": "Frame constructor from a Series: Args: series: A Series instance, to be realized...", "FrameGO.from_sql()": "Frame constructor from an SQL query and a database connection object. Args: quer...", "FrameGO.from_sqlite()": "Load Frame from the contents of a table in an SQLite database file.", "FrameGO.from_structured_array()": "Convert a NumPy structed array into a Frame. Args: array: Structured NumPy array...", "FrameGO.from_tsv()": "Specialized version of Frame.from_delimited for TSV files. Returns: Frame", "FrameGO.from_xlsx()": "Load Frame from the contents of a sheet in an XLSX workbook. Args: label: Option...", "FrameGO.to_arrow()": "Return a pyarrow.Table from this Frame.", "FrameGO.to_clipboard()": "Given a file path or file-like object, write the Frame as delimited text. The de...", "FrameGO.to_csv()": "Given a file path or file-like object, write the Frame as delimited text. The de...", "FrameGO.to_delimited()": "Given a file path or file-like object, write the Frame as delimited text. A deli...", "FrameGO.to_frame()": "Return Frame instance from this Frame. If this Frame is immutable the same insta...", "FrameGO.to_frame_go()": "Return a FrameGO instance from this Frame.", "FrameGO.to_frame_he()": "Return a FrameHE instance from this Frame. If this Frame is immutable the same i...", "FrameGO.to_hdf5()": "Write the Frame as single-table SQLite file.", "FrameGO.to_html()": "Return an HTML table representation of this Frame using standard TABLE, TR, and...", "FrameGO.to_html_datatables()": "Return a complete HTML representation of this Frame using the DataTables JS libr...", "FrameGO.to_json_columns()": "Export a Frame as a JSON string constructored as follows: A JSON object keyed by...", "FrameGO.to_json_index()": "Export a Frame as a JSON string constructored as follows: A JSON object keyed by...", "FrameGO.to_json_records()": "Export a Frame as a JSON string constructored as follows: A JSON array of row ob...", "FrameGO.to_json_split()": "Export a Frame as a JSON string constructored as follows: A JSON object with a k...", "FrameGO.to_json_values()": "Export a Frame as a JSON string constructored as follows: A JSON array of arrays...", "FrameGO.to_latex()": "Display the Frame as a LaTeX formatted table.", "FrameGO.to_markdown()": "Display the Frame as a Markdown formatted table.", "FrameGO.to_msgpack()": "Return msgpack bytes.", "FrameGO.to_npy()": "Write a Frame as a directory of npy file.", "FrameGO.to_npz()": "Write a Frame as an npz file.", "FrameGO.to_pairs()": "Return a tuple of major axis key, minor axis key vlaue pairs, where major axis i...", "FrameGO.to_pandas()": "Return a Pandas DataFrame.", "FrameGO.to_parquet()": "Write an Arrow Parquet binary file.", "FrameGO.to_pickle()": "Write a Frame as a Python pickle. The pickle module is not secure. Only unpickle...", "FrameGO.to_rst()": "Display the Frame as an RST formatted table.", "FrameGO.to_series()": "Return a Series representation of this Frame, where the index is extended with c...", "FrameGO.to_sqlite()": "Write the Frame as single-table SQLite file.", "FrameGO.to_tsv()": "Given a file path or file-like object, write the Frame as delimited text. The de...", "FrameGO.to_visidata()": "Open an interactive VisiData session.", "FrameGO.to_xarray()": "Return an xarray Dataset. In order to preserve columnar types, and following the...", "FrameGO.to_xlsx()": "Write the Frame as single-sheet XLSX file.", "FrameGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "FrameGO.T": "Transpose. Return a Frame with index as columns and vice versa.", "FrameGO.columns": "The IndexBase instance assigned for column labels.", "FrameGO.dtypes": "Return a Series of dytpes for each realizable column. Returns: Series", "FrameGO.index": "The IndexBase instance assigned for row labels.", "FrameGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "FrameGO.mloc": "The memory locations, represented as an array of integers, of the underlying Num...", "FrameGO.name": "A hashable label attached to this container. Returns: Hashable", "FrameGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "FrameGO.ndim": "Return the number of dimensions, which for a Frame is always 2. Returns: int", "FrameGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "FrameGO.size": "Return the size of the underlying NumPy array. Returns: int", "FrameGO.__array__()": "Support the __array__ interface, returning an array of values.", "FrameGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "FrameGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "FrameGO.__dataframe__()": "Return a data-frame interchange protocol compliant object. See https://data-apis...", "FrameGO.__deepcopy__()": "", "FrameGO.__len__()": "Length of rows in values.", "FrameGO.__round__()": "Return a Frame rounded to the given decimals. Negative decimals round to the lef...", "FrameGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "FrameGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "FrameGO.astype[]()": "Selector of columns by label. Args: key: A loc selector, either a label, a list...", "FrameGO.astype()": "Apply a single dtype to all columns.", "FrameGO.clip()": "Apply a clip operation to this Frame. Note that clip operations can be applied t...", "FrameGO.corr()": "Compute a correlation matrix. Args: axis: if 0, each row represents a variable,...", "FrameGO.count()": "Return the count of non-NA values along the provided axis, where 0 provides coun...", "FrameGO.cov()": "Compute a covariance matrix. Args: axis: if 0, each row represents a variable, w...", "FrameGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "FrameGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "FrameGO.drop_duplicated()": "Return a Frame with duplicated rows (axis 0) or columns (axis 1) removed. All va...", "FrameGO.dropfalsy()": "Return a new Frame after removing rows (axis 0) or columns (axis 1) where any or...", "FrameGO.dropna()": "Return a new Frame after removing rows (axis 0) or columns (axis 1) where any or...", "FrameGO.duplicated()": "Return an axis-sized Boolean Series that shows True for all rows (axis 0) or col...", "FrameGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "FrameGO.extend()": "Extend this FrameGO (in-place) with another Frame's blocks or Series array; as b...", "FrameGO.extend_items()": "Given an iterable of pairs of column name, column value, extend this FrameGO. Co...", "FrameGO.fillfalsy()": "Return a new Frame after replacing falsy values with the supplied value. Args: v...", "FrameGO.fillfalsy_backward()": "Return a new Frame after filling backward falsy values with the first observed v...", "FrameGO.fillfalsy_forward()": "Return a new Frame after filling forward falsy values with the last observed val...", "FrameGO.fillfalsy_leading()": "Return a new Frame after filling leading (and only leading) falsy values with th...", "FrameGO.fillfalsy_trailing()": "Return a new Frame after filling trailing (and only trailing) falsy values with...", "FrameGO.fillna()": "Return a new Frame after replacing null (NaN or None) values with the supplied v...", "FrameGO.fillna_backward()": "Return a new Frame after filling backward null (NaN or None) with the first obse...", "FrameGO.fillna_forward()": "Return a new Frame after filling forward null (NaN or None) with the last observ...", "FrameGO.fillna_leading()": "Return a new Frame after filling leading (and only leading) null (NaN or None) w...", "FrameGO.fillna_trailing()": "Return a new Frame after filling trailing (and only trailing) null (NaN or None)...", "FrameGO.head()": "Return a Frame consisting only of the top elements as specified by count. Args:...", "FrameGO.iloc_max()": "Return the integer indices corresponding to the maximum values found. Args: skip...", "FrameGO.iloc_min()": "Return the integer indices corresponding to the minimum values found. Args: skip...", "FrameGO.iloc_notfalsy_first()": "Return the position corresponding to the first non-falsy (including nan) values...", "FrameGO.iloc_notfalsy_last()": "Return the position corresponding to the last non-falsy (including nan) values a...", "FrameGO.iloc_notna_first()": "Return the position corresponding to the first non-missing values along the sele...", "FrameGO.iloc_notna_last()": "Return the position corresponding to the last non-missing values along the selec...", "FrameGO.insert_after()": "Create a new Frame by inserting a named Series or Frame at the position after th...", "FrameGO.insert_before()": "Create a new Frame by inserting a named Series or Frame at the position before t...", "FrameGO.isfalsy()": "Return a same-indexed, Boolean Frame indicating True which values are falsy.", "FrameGO.isin()": "Return a same-sized Boolean Frame that shows if the same-positioned element is i...", "FrameGO.isna()": "Return a same-indexed, Boolean Frame indicating True which values are NaN or Non...", "FrameGO.join_inner()": "Perform an inner join. Args: left_depth_level: Specify one or more left index de...", "FrameGO.join_left()": "Perform a left outer join. Args: left_depth_level: Specify one or more left inde...", "FrameGO.join_outer()": "Perform an outer join. Args: left_depth_level: Specify one or more left index de...", "FrameGO.join_right()": "Perform a right outer join. Args: left_depth_level: Specify one or more left ind...", "FrameGO.loc_max()": "Return the labels corresponding to the maximum values found. Args: skipna: if Tr...", "FrameGO.loc_min()": "Return the labels corresponding to the minimum value found. Args: skipna: if Tru...", "FrameGO.loc_notfalsy_first()": "Return the labels corresponding to the first non-falsy (including nan) values al...", "FrameGO.loc_notfalsy_last()": "Return the labels corresponding to the last non-falsy (including nan) values alo...", "FrameGO.loc_notna_first()": "Return the labels corresponding to the first non-missing values along the select...", "FrameGO.loc_notna_last()": "Return the labels corresponding to the last non-missing values along the selecte...", "FrameGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "FrameGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "FrameGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "FrameGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "FrameGO.notfalsy()": "Return a same-indexed, Boolean Frame indicating True which values are not falsy.", "FrameGO.notna()": "Return a same-indexed, Boolean Frame indicating True which values are not NaN or...", "FrameGO.pivot()": "Produce a pivot table, where one or more columns is selected for each of index_f...", "FrameGO.pivot_stack()": "Move labels from the columns to the index, creating or extending an IndexHierarc...", "FrameGO.pivot_unstack()": "Move labels from the index to the columns, creating or extending an IndexHierarc...", "FrameGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "FrameGO.rank_dense()": "Rank values as compactly as possible, where ties get the same value, and ranks a...", "FrameGO.rank_max()": "Rank values where tied values are assigned the maximum ordinal rank; ranks are p...", "FrameGO.rank_mean()": "Rank values where tied values are assigned the mean of the ordinal ranks; ranks...", "FrameGO.rank_min()": "Rank values where tied values are assigned the minimum ordinal rank; ranks are p...", "FrameGO.rank_ordinal()": "Rank values distinctly, where ties get distinct values that maintain their order...", "FrameGO.rehierarch()": "Produce a new Frame with index and/or columns constructed with a transformed hie...", "FrameGO.reindex()": "Return a new Frame with labels defined by the provided index. The size and order...", "FrameGO.relabel()": "Return a new Frame with transformed labels on the index. The size and ordering o...", "FrameGO.relabel_flat()": "Return a new Frame, where an IndexHierarchy (if defined) is replaced with a flat...", "FrameGO.relabel_level_add()": "Return a new Frame, adding a new root level to an existing IndexHierarchy, or cr...", "FrameGO.relabel_level_drop()": "Return a new Frame, dropping one or more levels from a either the root or the le...", "FrameGO.relabel_shift_in()": "Create, or augment, an IndexHierarchy by providing one or more selections from t...", "FrameGO.relabel_shift_out()": "Shift values from an index on an axis to the Frame by providing one or more dept...", "FrameGO.rename()": "Return a new Frame with an updated name attribute. Optionally update the name at...", "FrameGO.roll()": "Roll columns and/or rows by positive or negative integer counts, where columns a...", "FrameGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "FrameGO.set_columns()": "Return a new Frame produced by setting the given row as the columns, optionally...", "FrameGO.set_columns_hierarchy()": "Given an iterable of index labels, return a new Frame with those rows as an Inde...", "FrameGO.set_index()": "Return a new Frame produced by setting the given column as the index, optionally...", "FrameGO.set_index_hierarchy()": "Given an iterable of column labels, return a new Frame with those columns as an...", "FrameGO.shift()": "Shift columns and/or rows by positive or negative integer counts, where columns...", "FrameGO.sort_columns()": "Return a new Frame ordered by the sorted columns. Args: ascendings: Boolean, or...", "FrameGO.sort_index()": "Return a new Frame ordered by the sorted Index. Args: ascendings: Boolean, or it...", "FrameGO.sort_values()": "Return a new Frame ordered by the sorted values, where values are given by singl...", "FrameGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "FrameGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "FrameGO.tail()": "Return a Frame consisting only of the bottom elements as specified by count. Arg...", "FrameGO.transpose()": "Transpose. Return a Frame with index as columns and vice versa.", "FrameGO.unique()": "Return a NumPy array of unqiue values. If the axis argument is provied, uniquene...", "FrameGO.unset_columns()": "Return a new Frame where columns are added to the top of the data, and an IndexA...", "FrameGO.unset_index()": "Return a new Frame where the index is added to the front of the data, and an Ind...", "FrameGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "FrameGO.__contains__()": "Inclusion of value in column labels.", "FrameGO.__iter__()": "Iterator of column labels, same as Frame.keys.", "FrameGO.__reversed__()": "Returns a reverse iterator on the frame's columns.", "FrameGO.get()": "Return the value found at the columns key, else the default if the key is not fo...", "FrameGO.items()": "Iterator of pairs of column label and corresponding column Series.", "FrameGO.keys()": "Iterator of column labels.", "FrameGO.values": "A 2D NumPy array of all values in the Frame. As this is a single array, heteroge...", "FrameGO.interface": "A Frame documenting the interface of this class.", "FrameGO.__repr__()": "", "FrameGO.__str__()": "Return str(self).", "FrameGO.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "FrameGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "FrameGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "FrameGO.assign[]()": "Assign the value in the position specified by the selector. The name attribute i...", "FrameGO.assign[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "FrameGO.assign[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "FrameGO.assign[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "FrameGO.assign.iloc[]()": "Assign the value in the position specified by the selector. The name attribute i...", "FrameGO.assign.iloc[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "FrameGO.assign.iloc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "FrameGO.assign.iloc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "FrameGO.assign.loc[]()": "Assign the value in the position specified by the selector. The name attribute i...", "FrameGO.assign.loc[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "FrameGO.assign.loc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "FrameGO.assign.loc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "FrameGO.assign.bloc[]()": "Assign the value in the position specified by the selector. The name attribute i...", "FrameGO.assign.bloc[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "FrameGO.assign.bloc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "FrameGO.assign.bloc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "FrameGO.bloc[]": "", "FrameGO.drop[]": "Label-based selection.", "FrameGO.drop.iloc[]": "", "FrameGO.drop.loc[]": "", "FrameGO.mask[]": "Label-based selection.", "FrameGO.mask.iloc[]": "", "FrameGO.mask.loc[]": "", "FrameGO.masked_array[]": "Label-based selection.", "FrameGO.masked_array.iloc[]": "", "FrameGO.masked_array.loc[]": "", "FrameGO.[]": "Selector of columns by label. Args: key: A loc selector, either a label, a list...", "FrameGO.iloc[]": "", "FrameGO.loc[]": "", "FrameGO.iter_array()": "Iterator of np.array, where arrays are drawn from columns (axis=0) or rows (axis...", "FrameGO.iter_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_array_items()": "Iterator of pairs of label, np.array, where arrays are drawn from columns (axis=...", "FrameGO.iter_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_element()": "Iterator of elements, ordered by row then column.", "FrameGO.iter_element().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_element().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_element().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_element().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_element().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "FrameGO.iter_element().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "FrameGO.iter_element().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "FrameGO.iter_element().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "FrameGO.iter_element().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "FrameGO.iter_element().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "FrameGO.iter_element().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "FrameGO.iter_element().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "FrameGO.iter_element().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "FrameGO.iter_element_items()": "Iterator of pairs of label, element, where labels are pairs of index, columns la...", "FrameGO.iter_element_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_element_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_element_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_element_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_element_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "FrameGO.iter_element_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "FrameGO.iter_element_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "FrameGO.iter_element_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "FrameGO.iter_element_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "FrameGO.iter_element_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "FrameGO.iter_element_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "FrameGO.iter_element_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "FrameGO.iter_element_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "FrameGO.iter_group()": "Iterator of Frame grouped by unique values found in one or more columns (axis=0)...", "FrameGO.iter_group().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_group().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_group().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_group().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_group_array()": "Iterator of np.ndarray grouped by unique values found in one or more columns (ax...", "FrameGO.iter_group_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_group_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_group_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_group_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_group_array_items()": "Iterator of pairs of label, np.ndarray grouped by unique values found in one or...", "FrameGO.iter_group_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_group_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_group_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_group_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_group_items()": "Iterator of pairs of label, Frame grouped by unique values found in one or more...", "FrameGO.iter_group_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_group_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_group_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_group_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_group_labels()": "Iterator of Frame grouped by unique labels found in one or more index depths (ax...", "FrameGO.iter_group_labels().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_group_labels().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_group_labels().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_group_labels().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_group_labels_array()": "Iterator of np.ndarray grouped by unique labels found in one or more index depth...", "FrameGO.iter_group_labels_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_group_labels_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_group_labels_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_group_labels_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_group_labels_array_items()": "Iterator of pairs of label, np.ndarray grouped by unique labels found in one or...", "FrameGO.iter_group_labels_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_group_labels_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_group_labels_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_group_labels_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_group_labels_items()": "Iterator of pairs of label, Frame grouped by unique labels found in one or more...", "FrameGO.iter_group_labels_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_group_labels_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_group_labels_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_group_labels_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_group_other()": "Iterator of Frame grouped by unique values found in a supplied container.", "FrameGO.iter_group_other().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_group_other().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_group_other().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_group_other().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_group_other_array()": "Iterator of Frame grouped by unique values found in a supplied container.", "FrameGO.iter_group_other_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_group_other_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_group_other_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_group_other_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_group_other_array_items()": "Iterator of Frame grouped by unique values found in a supplied container.", "FrameGO.iter_group_other_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_group_other_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_group_other_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_group_other_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_group_other_items()": "Iterator of Frame grouped by unique values found in a supplied container.", "FrameGO.iter_group_other_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_group_other_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_group_other_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_group_other_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_series()": "Iterator of Series, where Series are drawn from columns (axis=0) or rows (axis=1...", "FrameGO.iter_series().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_series().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_series().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_series().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_series_items()": "Iterator of pairs of label, Series, where Series are drawn from columns (axis=0)...", "FrameGO.iter_series_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_series_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_series_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_series_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_tuple()": "Iterator of NamedTuple, where tuples are drawn from columns (axis=0) or rows (ax...", "FrameGO.iter_tuple().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_tuple().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_tuple().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_tuple().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_tuple().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "FrameGO.iter_tuple().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "FrameGO.iter_tuple().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "FrameGO.iter_tuple().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "FrameGO.iter_tuple().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "FrameGO.iter_tuple().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "FrameGO.iter_tuple().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "FrameGO.iter_tuple().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "FrameGO.iter_tuple().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "FrameGO.iter_tuple_items()": "Iterator of pairs of label, NamedTuple, where tuples are drawn from columns (axi...", "FrameGO.iter_tuple_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_tuple_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_tuple_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_tuple_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_tuple_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "FrameGO.iter_tuple_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "FrameGO.iter_tuple_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "FrameGO.iter_tuple_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "FrameGO.iter_tuple_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "FrameGO.iter_tuple_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "FrameGO.iter_tuple_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "FrameGO.iter_tuple_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "FrameGO.iter_tuple_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "FrameGO.iter_window()": "Iterator of windowed values, where values are given as a Frame. Args: size: Elem...", "FrameGO.iter_window().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_window().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_window().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_window().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_window_array()": "Iterator of windowed values, where values are given as a np.array. Args: size: E...", "FrameGO.iter_window_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_window_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_window_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_window_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_window_array_items()": "Iterator of pairs of label, windowed values, where values are given as a np.arra...", "FrameGO.iter_window_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_window_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_window_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_window_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.iter_window_items()": "Iterator of pairs of label, windowed values, where values are given as a Frame....", "FrameGO.iter_window_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameGO.iter_window_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameGO.iter_window_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameGO.iter_window_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameGO.__add__()": "", "FrameGO.__and__()": "", "FrameGO.__eq__()": "", "FrameGO.__floordiv__()": "", "FrameGO.__ge__()": "", "FrameGO.__gt__()": "", "FrameGO.__le__()": "", "FrameGO.__lt__()": "", "FrameGO.__matmul__()": "", "FrameGO.__mod__()": "", "FrameGO.__mul__()": "", "FrameGO.__ne__()": "", "FrameGO.__or__()": "", "FrameGO.__pow__()": "", "FrameGO.__radd__()": "", "FrameGO.__rfloordiv__()": "", "FrameGO.__rmatmul__()": "", "FrameGO.__rmul__()": "", "FrameGO.__rshift__()": "", "FrameGO.__rsub__()": "", "FrameGO.__rtruediv__()": "", "FrameGO.__sub__()": "", "FrameGO.__truediv__()": "", "FrameGO.__xor__()": "", "FrameGO.__abs__()": "", "FrameGO.__invert__()": "", "FrameGO.__neg__()": "", "FrameGO.__pos__()": "", "FrameGO.via_values.apply()": "", "FrameGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "FrameGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "FrameGO.via_dt.year": "Return the year of each element.", "FrameGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "FrameGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "FrameGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "FrameGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "FrameGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "FrameGO.via_dt.second": "Return the second of each element, between 0 and 60.", "FrameGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "FrameGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "FrameGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "FrameGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "FrameGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "FrameGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "FrameGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "FrameGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "FrameGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "FrameGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "FrameGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "FrameGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "FrameGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "FrameGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "FrameGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "FrameGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "FrameGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "FrameGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "FrameGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "FrameGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "FrameGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "FrameGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "FrameGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "FrameGO.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "FrameGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "FrameGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "FrameGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "FrameGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "FrameGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "FrameGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "FrameGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "FrameGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "FrameGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "FrameGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "FrameGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "FrameGO.via_str.len()": "Return the length of the string.", "FrameGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "FrameGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "FrameGO.via_str.partition()": "Partition each element around sep.", "FrameGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "FrameGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "FrameGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "FrameGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "FrameGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "FrameGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "FrameGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "FrameGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "FrameGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "FrameGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "FrameGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "FrameGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "FrameGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "FrameGO.via_str.zfill()": "Return the string left-filled with zeros.", "FrameGO.via_T.via_fill_value()": "Interface for using binary operators and methods with a pre-defined fill value.", "FrameGO.via_T.__add__()": "", "FrameGO.via_T.__sub__()": "", "FrameGO.via_T.__mul__()": "", "FrameGO.via_T.__truediv__()": "", "FrameGO.via_T.__floordiv__()": "", "FrameGO.via_T.__mod__()": "", "FrameGO.via_T.__pow__()": "", "FrameGO.via_T.__lshift__()": "", "FrameGO.via_T.__rshift__()": "", "FrameGO.via_T.__and__()": "", "FrameGO.via_T.__xor__()": "", "FrameGO.via_T.__or__()": "", "FrameGO.via_T.__lt__()": "", "FrameGO.via_T.__le__()": "", "FrameGO.via_T.__eq__()": "", "FrameGO.via_T.__ne__()": "", "FrameGO.via_T.__gt__()": "", "FrameGO.via_T.__ge__()": "", "FrameGO.via_T.__radd__()": "", "FrameGO.via_T.__rsub__()": "", "FrameGO.via_T.__rmul__()": "", "FrameGO.via_T.__rtruediv__()": "", "FrameGO.via_T.__rfloordiv__()": "", "FrameGO.via_fill_value().loc": "Label-based selection where labels not specified will define a new container con...", "FrameGO.via_fill_value().__getitem__()": "Label-based selection where labels not specified will define a new container con...", "FrameGO.via_fill_value().via_T": "Interface for using binary operators with one-dimensional sequences, where the o...", "FrameGO.via_fill_value().__add__()": "", "FrameGO.via_fill_value().__sub__()": "", "FrameGO.via_fill_value().__mul__()": "", "FrameGO.via_fill_value().__truediv__()": "", "FrameGO.via_fill_value().__floordiv__()": "", "FrameGO.via_fill_value().__mod__()": "", "FrameGO.via_fill_value().__pow__()": "", "FrameGO.via_fill_value().__lshift__()": "", "FrameGO.via_fill_value().__rshift__()": "", "FrameGO.via_fill_value().__and__()": "", "FrameGO.via_fill_value().__xor__()": "", "FrameGO.via_fill_value().__or__()": "", "FrameGO.via_fill_value().__lt__()": "", "FrameGO.via_fill_value().__le__()": "", "FrameGO.via_fill_value().__eq__()": "", "FrameGO.via_fill_value().__ne__()": "", "FrameGO.via_fill_value().__gt__()": "", "FrameGO.via_fill_value().__ge__()": "", "FrameGO.via_fill_value().__radd__()": "", "FrameGO.via_fill_value().__rsub__()": "", "FrameGO.via_fill_value().__rmul__()": "", "FrameGO.via_fill_value().__rtruediv__()": "", "FrameGO.via_fill_value().__rfloordiv__()": "", "FrameGO.via_re().search()": "Scan through string looking for the first location where this regular expression...", "FrameGO.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "FrameGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "FrameGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "FrameGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "FrameGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "FrameGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "FrameGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "FrameGO.via_hashlib().md5()": "", "FrameGO.via_hashlib().sha256()": "", "FrameGO.via_hashlib().sha512()": "", "FrameGO.via_hashlib().sha3_256()": "", "FrameGO.via_hashlib().sha3_512()": "", "FrameGO.via_hashlib().shake_128()": "", "FrameGO.via_hashlib().shake_256()": "", "FrameGO.via_hashlib().blake2b()": "", "FrameGO.via_hashlib().blake2s()": "", "FrameHE.__init__()": "Initializer. Args: data: Default Frame initialization requires typed data such a...", "FrameHE.from_arrow()": "Realize a Frame from an Arrow Table. Args: value: A pyarrow.Table instance. inde...", "FrameHE.from_clipboard()": "Create a Frame from the contents of the clipboard (assuming a table is stored as...", "FrameHE.from_concat()": "Concatenate multiple Frame or Series into a new Frame. If index or columns are p...", "FrameHE.from_concat_items()": "Produce a Frame with a hierarchical index from an iterable of pairs of labels, F...", "FrameHE.from_csv()": "Specialized version of Frame.from_delimited for CSV files. Returns: Frame", "FrameHE.from_delimited()": "Create a Frame from a file path or a file-like object defining a delimited (CSV,...", "FrameHE.from_dict()": "Create a Frame from a dictionary (or any object that has an items() method) wher...", "FrameHE.from_dict_fields()": "Frame constructor from an iterable of dictionaries, where each dictionary repres...", "FrameHE.from_dict_records()": "Frame constructor from an iterable of dictionaries, where each dictionary repres...", "FrameHE.from_dict_records_items()": "Frame constructor from iterable of pairs of index label, row, where row is a dic...", "FrameHE.from_element()": "Create a Frame from an element, i.e., a single value stored in a single cell. Bo...", "FrameHE.from_element_items()": "Create a Frame from an iterable of key, value, where key is a pair of row, colum...", "FrameHE.from_elements()": "Create a Frame from an iterable of elements, to be formed into a Frame with a si...", "FrameHE.from_fields()": "Frame constructor from an iterator of columns, where columns are iterables. Seri...", "FrameHE.from_hdf5()": "Load Frame from the contents of a table in an HDF5 file.", "FrameHE.from_items()": "Frame constructor from an iterator of pairs, where the first value is the column...", "FrameHE.from_json()": "Frame constructor from an in-memory JSON document. Args: json_data: a string of...", "FrameHE.from_json_columns()": "Frame constructor from an in-memory JSON document in the following format: A JSO...", "FrameHE.from_json_index()": "Frame constructor from an in-memory JSON document in the following format: A JSO...", "FrameHE.from_json_records()": "Frame constructor from an in-memory JSON document in the following format: A JSO...", "FrameHE.from_json_split()": "Frame constructor from an in-memory JSON document in the following format: A JSO...", "FrameHE.from_json_url()": "Frame constructor from a JSON documenst provided via a URL. Args: url: URL to th...", "FrameHE.from_json_values()": "Frame constructor from an in-memory JSON document in the following format: A JSO...", "FrameHE.from_msgpack()": "Frame constructor from an in-memory binary object formatted as a msgpack. Args:...", "FrameHE.from_npy()": "Create a Frame from an directory of npy files. Args: fp: The path to the NPY dir...", "FrameHE.from_npy_mmap()": "Create a Frame from an directory of npy files using memory maps. Args: fp: The p...", "FrameHE.from_npz()": "Create a Frame from an npz file.", "FrameHE.from_overlay()": "Return a new Frame made by overlaying containers, filling in values with aligned...", "FrameHE.from_pandas()": "Given a Pandas DataFrame, return a Frame. Args: value: Pandas DataFrame. index_c...", "FrameHE.from_parquet()": "Realize a Frame from a Parquet file. Args: fp: A string file path or Path instan...", "FrameHE.from_pickle()": "Create a Frame from a pickle file. The pickle module is not secure. Only unpickl...", "FrameHE.from_records()": "Construct a Frame from an iterable of rows, where rows are defined as iterables,...", "FrameHE.from_records_items()": "Frame constructor from iterable of pairs of index value, row (where row is an it...", "FrameHE.from_series()": "Frame constructor from a Series: Args: series: A Series instance, to be realized...", "FrameHE.from_sql()": "Frame constructor from an SQL query and a database connection object. Args: quer...", "FrameHE.from_sqlite()": "Load Frame from the contents of a table in an SQLite database file.", "FrameHE.from_structured_array()": "Convert a NumPy structed array into a Frame. Args: array: Structured NumPy array...", "FrameHE.from_tsv()": "Specialized version of Frame.from_delimited for TSV files. Returns: Frame", "FrameHE.from_xlsx()": "Load Frame from the contents of a sheet in an XLSX workbook. Args: label: Option...", "FrameHE.to_arrow()": "Return a pyarrow.Table from this Frame.", "FrameHE.to_clipboard()": "Given a file path or file-like object, write the Frame as delimited text. The de...", "FrameHE.to_csv()": "Given a file path or file-like object, write the Frame as delimited text. The de...", "FrameHE.to_delimited()": "Given a file path or file-like object, write the Frame as delimited text. A deli...", "FrameHE.to_frame()": "Return Frame instance from this Frame. If this Frame is immutable the same insta...", "FrameHE.to_frame_go()": "Return a FrameGO instance from this Frame.", "FrameHE.to_frame_he()": "Return a FrameHE instance from this Frame. If this Frame is immutable the same i...", "FrameHE.to_hdf5()": "Write the Frame as single-table SQLite file.", "FrameHE.to_html()": "Return an HTML table representation of this Frame using standard TABLE, TR, and...", "FrameHE.to_html_datatables()": "Return a complete HTML representation of this Frame using the DataTables JS libr...", "FrameHE.to_json_columns()": "Export a Frame as a JSON string constructored as follows: A JSON object keyed by...", "FrameHE.to_json_index()": "Export a Frame as a JSON string constructored as follows: A JSON object keyed by...", "FrameHE.to_json_records()": "Export a Frame as a JSON string constructored as follows: A JSON array of row ob...", "FrameHE.to_json_split()": "Export a Frame as a JSON string constructored as follows: A JSON object with a k...", "FrameHE.to_json_values()": "Export a Frame as a JSON string constructored as follows: A JSON array of arrays...", "FrameHE.to_latex()": "Display the Frame as a LaTeX formatted table.", "FrameHE.to_markdown()": "Display the Frame as a Markdown formatted table.", "FrameHE.to_msgpack()": "Return msgpack bytes.", "FrameHE.to_npy()": "Write a Frame as a directory of npy file.", "FrameHE.to_npz()": "Write a Frame as an npz file.", "FrameHE.to_pairs()": "Return a tuple of major axis key, minor axis key vlaue pairs, where major axis i...", "FrameHE.to_pandas()": "Return a Pandas DataFrame.", "FrameHE.to_parquet()": "Write an Arrow Parquet binary file.", "FrameHE.to_pickle()": "Write a Frame as a Python pickle. The pickle module is not secure. Only unpickle...", "FrameHE.to_rst()": "Display the Frame as an RST formatted table.", "FrameHE.to_series()": "Return a Series representation of this Frame, where the index is extended with c...", "FrameHE.to_sqlite()": "Write the Frame as single-table SQLite file.", "FrameHE.to_tsv()": "Given a file path or file-like object, write the Frame as delimited text. The de...", "FrameHE.to_visidata()": "Open an interactive VisiData session.", "FrameHE.to_xarray()": "Return an xarray Dataset. In order to preserve columnar types, and following the...", "FrameHE.to_xlsx()": "Write the Frame as single-sheet XLSX file.", "FrameHE.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "FrameHE.T": "Transpose. Return a Frame with index as columns and vice versa.", "FrameHE.columns": "The IndexBase instance assigned for column labels.", "FrameHE.dtypes": "Return a Series of dytpes for each realizable column. Returns: Series", "FrameHE.index": "The IndexBase instance assigned for row labels.", "FrameHE.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "FrameHE.mloc": "The memory locations, represented as an array of integers, of the underlying Num...", "FrameHE.name": "A hashable label attached to this container. Returns: Hashable", "FrameHE.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "FrameHE.ndim": "Return the number of dimensions, which for a Frame is always 2. Returns: int", "FrameHE.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "FrameHE.size": "Return the size of the underlying NumPy array. Returns: int", "FrameHE.__array__()": "Support the __array__ interface, returning an array of values.", "FrameHE.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "FrameHE.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "FrameHE.__dataframe__()": "Return a data-frame interchange protocol compliant object. See https://data-apis...", "FrameHE.__deepcopy__()": "", "FrameHE.__len__()": "Length of rows in values.", "FrameHE.__round__()": "Return a Frame rounded to the given decimals. Negative decimals round to the lef...", "FrameHE.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "FrameHE.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "FrameHE.astype[]()": "Selector of columns by label. Args: key: A loc selector, either a label, a list...", "FrameHE.astype()": "Apply a single dtype to all columns.", "FrameHE.clip()": "Apply a clip operation to this Frame. Note that clip operations can be applied t...", "FrameHE.corr()": "Compute a correlation matrix. Args: axis: if 0, each row represents a variable,...", "FrameHE.count()": "Return the count of non-NA values along the provided axis, where 0 provides coun...", "FrameHE.cov()": "Compute a covariance matrix. Args: axis: if 0, each row represents a variable, w...", "FrameHE.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "FrameHE.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "FrameHE.drop_duplicated()": "Return a Frame with duplicated rows (axis 0) or columns (axis 1) removed. All va...", "FrameHE.dropfalsy()": "Return a new Frame after removing rows (axis 0) or columns (axis 1) where any or...", "FrameHE.dropna()": "Return a new Frame after removing rows (axis 0) or columns (axis 1) where any or...", "FrameHE.duplicated()": "Return an axis-sized Boolean Series that shows True for all rows (axis 0) or col...", "FrameHE.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "FrameHE.fillfalsy()": "Return a new Frame after replacing falsy values with the supplied value. Args: v...", "FrameHE.fillfalsy_backward()": "Return a new Frame after filling backward falsy values with the first observed v...", "FrameHE.fillfalsy_forward()": "Return a new Frame after filling forward falsy values with the last observed val...", "FrameHE.fillfalsy_leading()": "Return a new Frame after filling leading (and only leading) falsy values with th...", "FrameHE.fillfalsy_trailing()": "Return a new Frame after filling trailing (and only trailing) falsy values with...", "FrameHE.fillna()": "Return a new Frame after replacing null (NaN or None) values with the supplied v...", "FrameHE.fillna_backward()": "Return a new Frame after filling backward null (NaN or None) with the first obse...", "FrameHE.fillna_forward()": "Return a new Frame after filling forward null (NaN or None) with the last observ...", "FrameHE.fillna_leading()": "Return a new Frame after filling leading (and only leading) null (NaN or None) w...", "FrameHE.fillna_trailing()": "Return a new Frame after filling trailing (and only trailing) null (NaN or None)...", "FrameHE.head()": "Return a Frame consisting only of the top elements as specified by count. Args:...", "FrameHE.iloc_max()": "Return the integer indices corresponding to the maximum values found. Args: skip...", "FrameHE.iloc_min()": "Return the integer indices corresponding to the minimum values found. Args: skip...", "FrameHE.iloc_notfalsy_first()": "Return the position corresponding to the first non-falsy (including nan) values...", "FrameHE.iloc_notfalsy_last()": "Return the position corresponding to the last non-falsy (including nan) values a...", "FrameHE.iloc_notna_first()": "Return the position corresponding to the first non-missing values along the sele...", "FrameHE.iloc_notna_last()": "Return the position corresponding to the last non-missing values along the selec...", "FrameHE.insert_after()": "Create a new Frame by inserting a named Series or Frame at the position after th...", "FrameHE.insert_before()": "Create a new Frame by inserting a named Series or Frame at the position before t...", "FrameHE.isfalsy()": "Return a same-indexed, Boolean Frame indicating True which values are falsy.", "FrameHE.isin()": "Return a same-sized Boolean Frame that shows if the same-positioned element is i...", "FrameHE.isna()": "Return a same-indexed, Boolean Frame indicating True which values are NaN or Non...", "FrameHE.join_inner()": "Perform an inner join. Args: left_depth_level: Specify one or more left index de...", "FrameHE.join_left()": "Perform a left outer join. Args: left_depth_level: Specify one or more left inde...", "FrameHE.join_outer()": "Perform an outer join. Args: left_depth_level: Specify one or more left index de...", "FrameHE.join_right()": "Perform a right outer join. Args: left_depth_level: Specify one or more left ind...", "FrameHE.loc_max()": "Return the labels corresponding to the maximum values found. Args: skipna: if Tr...", "FrameHE.loc_min()": "Return the labels corresponding to the minimum value found. Args: skipna: if Tru...", "FrameHE.loc_notfalsy_first()": "Return the labels corresponding to the first non-falsy (including nan) values al...", "FrameHE.loc_notfalsy_last()": "Return the labels corresponding to the last non-falsy (including nan) values alo...", "FrameHE.loc_notna_first()": "Return the labels corresponding to the first non-missing values along the select...", "FrameHE.loc_notna_last()": "Return the labels corresponding to the last non-missing values along the selecte...", "FrameHE.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "FrameHE.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "FrameHE.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "FrameHE.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "FrameHE.notfalsy()": "Return a same-indexed, Boolean Frame indicating True which values are not falsy.", "FrameHE.notna()": "Return a same-indexed, Boolean Frame indicating True which values are not NaN or...", "FrameHE.pivot()": "Produce a pivot table, where one or more columns is selected for each of index_f...", "FrameHE.pivot_stack()": "Move labels from the columns to the index, creating or extending an IndexHierarc...", "FrameHE.pivot_unstack()": "Move labels from the index to the columns, creating or extending an IndexHierarc...", "FrameHE.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "FrameHE.rank_dense()": "Rank values as compactly as possible, where ties get the same value, and ranks a...", "FrameHE.rank_max()": "Rank values where tied values are assigned the maximum ordinal rank; ranks are p...", "FrameHE.rank_mean()": "Rank values where tied values are assigned the mean of the ordinal ranks; ranks...", "FrameHE.rank_min()": "Rank values where tied values are assigned the minimum ordinal rank; ranks are p...", "FrameHE.rank_ordinal()": "Rank values distinctly, where ties get distinct values that maintain their order...", "FrameHE.rehierarch()": "Produce a new Frame with index and/or columns constructed with a transformed hie...", "FrameHE.reindex()": "Return a new Frame with labels defined by the provided index. The size and order...", "FrameHE.relabel()": "Return a new Frame with transformed labels on the index. The size and ordering o...", "FrameHE.relabel_flat()": "Return a new Frame, where an IndexHierarchy (if defined) is replaced with a flat...", "FrameHE.relabel_level_add()": "Return a new Frame, adding a new root level to an existing IndexHierarchy, or cr...", "FrameHE.relabel_level_drop()": "Return a new Frame, dropping one or more levels from a either the root or the le...", "FrameHE.relabel_shift_in()": "Create, or augment, an IndexHierarchy by providing one or more selections from t...", "FrameHE.relabel_shift_out()": "Shift values from an index on an axis to the Frame by providing one or more dept...", "FrameHE.rename()": "Return a new Frame with an updated name attribute. Optionally update the name at...", "FrameHE.roll()": "Roll columns and/or rows by positive or negative integer counts, where columns a...", "FrameHE.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "FrameHE.set_columns()": "Return a new Frame produced by setting the given row as the columns, optionally...", "FrameHE.set_columns_hierarchy()": "Given an iterable of index labels, return a new Frame with those rows as an Inde...", "FrameHE.set_index()": "Return a new Frame produced by setting the given column as the index, optionally...", "FrameHE.set_index_hierarchy()": "Given an iterable of column labels, return a new Frame with those columns as an...", "FrameHE.shift()": "Shift columns and/or rows by positive or negative integer counts, where columns...", "FrameHE.sort_columns()": "Return a new Frame ordered by the sorted columns. Args: ascendings: Boolean, or...", "FrameHE.sort_index()": "Return a new Frame ordered by the sorted Index. Args: ascendings: Boolean, or it...", "FrameHE.sort_values()": "Return a new Frame ordered by the sorted values, where values are given by singl...", "FrameHE.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "FrameHE.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "FrameHE.tail()": "Return a Frame consisting only of the bottom elements as specified by count. Arg...", "FrameHE.transpose()": "Transpose. Return a Frame with index as columns and vice versa.", "FrameHE.unique()": "Return a NumPy array of unqiue values. If the axis argument is provied, uniquene...", "FrameHE.unset_columns()": "Return a new Frame where columns are added to the top of the data, and an IndexA...", "FrameHE.unset_index()": "Return a new Frame where the index is added to the front of the data, and an Ind...", "FrameHE.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "FrameHE.__contains__()": "Inclusion of value in column labels.", "FrameHE.__iter__()": "Iterator of column labels, same as Frame.keys.", "FrameHE.__reversed__()": "Returns a reverse iterator on the frame's columns.", "FrameHE.get()": "Return the value found at the columns key, else the default if the key is not fo...", "FrameHE.items()": "Iterator of pairs of column label and corresponding column Series.", "FrameHE.keys()": "Iterator of column labels.", "FrameHE.values": "A 2D NumPy array of all values in the Frame. As this is a single array, heteroge...", "FrameHE.interface": "A Frame documenting the interface of this class.", "FrameHE.__repr__()": "", "FrameHE.__str__()": "Return str(self).", "FrameHE.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "FrameHE.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "FrameHE.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "FrameHE.assign[]()": "Assign the value in the position specified by the selector. The name attribute i...", "FrameHE.assign[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "FrameHE.assign[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "FrameHE.assign[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "FrameHE.assign.iloc[]()": "Assign the value in the position specified by the selector. The name attribute i...", "FrameHE.assign.iloc[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "FrameHE.assign.iloc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "FrameHE.assign.iloc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "FrameHE.assign.loc[]()": "Assign the value in the position specified by the selector. The name attribute i...", "FrameHE.assign.loc[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "FrameHE.assign.loc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "FrameHE.assign.loc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "FrameHE.assign.bloc[]()": "Assign the value in the position specified by the selector. The name attribute i...", "FrameHE.assign.bloc[].apply()": "Provide a function to apply to the assignment target, and use that as the assign...", "FrameHE.assign.bloc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use th...", "FrameHE.assign.bloc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in...", "FrameHE.bloc[]": "", "FrameHE.drop[]": "Label-based selection.", "FrameHE.drop.iloc[]": "", "FrameHE.drop.loc[]": "", "FrameHE.mask[]": "Label-based selection.", "FrameHE.mask.iloc[]": "", "FrameHE.mask.loc[]": "", "FrameHE.masked_array[]": "Label-based selection.", "FrameHE.masked_array.iloc[]": "", "FrameHE.masked_array.loc[]": "", "FrameHE.[]": "Selector of columns by label. Args: key: A loc selector, either a label, a list...", "FrameHE.iloc[]": "", "FrameHE.loc[]": "", "FrameHE.iter_array()": "Iterator of np.array, where arrays are drawn from columns (axis=0) or rows (axis...", "FrameHE.iter_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_array_items()": "Iterator of pairs of label, np.array, where arrays are drawn from columns (axis=...", "FrameHE.iter_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_element()": "Iterator of elements, ordered by row then column.", "FrameHE.iter_element().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_element().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_element().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_element().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_element().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "FrameHE.iter_element().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "FrameHE.iter_element().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "FrameHE.iter_element().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "FrameHE.iter_element().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "FrameHE.iter_element().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "FrameHE.iter_element().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "FrameHE.iter_element().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "FrameHE.iter_element().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "FrameHE.iter_element_items()": "Iterator of pairs of label, element, where labels are pairs of index, columns la...", "FrameHE.iter_element_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_element_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_element_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_element_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_element_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "FrameHE.iter_element_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "FrameHE.iter_element_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "FrameHE.iter_element_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "FrameHE.iter_element_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "FrameHE.iter_element_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "FrameHE.iter_element_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "FrameHE.iter_element_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "FrameHE.iter_element_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "FrameHE.iter_group()": "Iterator of Frame grouped by unique values found in one or more columns (axis=0)...", "FrameHE.iter_group().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_group().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_group().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_group().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_group_array()": "Iterator of np.ndarray grouped by unique values found in one or more columns (ax...", "FrameHE.iter_group_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_group_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_group_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_group_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_group_array_items()": "Iterator of pairs of label, np.ndarray grouped by unique values found in one or...", "FrameHE.iter_group_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_group_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_group_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_group_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_group_items()": "Iterator of pairs of label, Frame grouped by unique values found in one or more...", "FrameHE.iter_group_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_group_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_group_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_group_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_group_labels()": "Iterator of Frame grouped by unique labels found in one or more index depths (ax...", "FrameHE.iter_group_labels().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_group_labels().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_group_labels().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_group_labels().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_group_labels_array()": "Iterator of np.ndarray grouped by unique labels found in one or more index depth...", "FrameHE.iter_group_labels_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_group_labels_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_group_labels_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_group_labels_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_group_labels_array_items()": "Iterator of pairs of label, np.ndarray grouped by unique labels found in one or...", "FrameHE.iter_group_labels_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_group_labels_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_group_labels_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_group_labels_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_group_labels_items()": "Iterator of pairs of label, Frame grouped by unique labels found in one or more...", "FrameHE.iter_group_labels_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_group_labels_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_group_labels_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_group_labels_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_group_other()": "Iterator of Frame grouped by unique values found in a supplied container.", "FrameHE.iter_group_other().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_group_other().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_group_other().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_group_other().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_group_other_array()": "Iterator of Frame grouped by unique values found in a supplied container.", "FrameHE.iter_group_other_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_group_other_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_group_other_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_group_other_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_group_other_array_items()": "Iterator of Frame grouped by unique values found in a supplied container.", "FrameHE.iter_group_other_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_group_other_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_group_other_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_group_other_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_group_other_items()": "Iterator of Frame grouped by unique values found in a supplied container.", "FrameHE.iter_group_other_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_group_other_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_group_other_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_group_other_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_series()": "Iterator of Series, where Series are drawn from columns (axis=0) or rows (axis=1...", "FrameHE.iter_series().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_series().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_series().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_series().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_series_items()": "Iterator of pairs of label, Series, where Series are drawn from columns (axis=0)...", "FrameHE.iter_series_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_series_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_series_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_series_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_tuple()": "Iterator of NamedTuple, where tuples are drawn from columns (axis=0) or rows (ax...", "FrameHE.iter_tuple().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_tuple().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_tuple().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_tuple().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_tuple().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "FrameHE.iter_tuple().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "FrameHE.iter_tuple().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "FrameHE.iter_tuple().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "FrameHE.iter_tuple().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "FrameHE.iter_tuple().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "FrameHE.iter_tuple().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "FrameHE.iter_tuple().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "FrameHE.iter_tuple().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "FrameHE.iter_tuple_items()": "Iterator of pairs of label, NamedTuple, where tuples are drawn from columns (axi...", "FrameHE.iter_tuple_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_tuple_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_tuple_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_tuple_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_tuple_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "FrameHE.iter_tuple_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "FrameHE.iter_tuple_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "FrameHE.iter_tuple_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "FrameHE.iter_tuple_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "FrameHE.iter_tuple_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "FrameHE.iter_tuple_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "FrameHE.iter_tuple_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "FrameHE.iter_tuple_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "FrameHE.iter_window()": "Iterator of windowed values, where values are given as a Frame. Args: size: Elem...", "FrameHE.iter_window().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_window().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_window().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_window().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_window_array()": "Iterator of windowed values, where values are given as a np.array. Args: size: E...", "FrameHE.iter_window_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_window_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_window_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_window_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_window_array_items()": "Iterator of pairs of label, windowed values, where values are given as a np.arra...", "FrameHE.iter_window_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_window_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_window_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_window_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.iter_window_items()": "Iterator of pairs of label, windowed values, where values are given as a Frame....", "FrameHE.iter_window_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "FrameHE.iter_window_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "FrameHE.iter_window_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "FrameHE.iter_window_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "FrameHE.__add__()": "", "FrameHE.__and__()": "", "FrameHE.__eq__()": "Return True if other is a Frame with the same labels, values, and name. Containe...", "FrameHE.__floordiv__()": "", "FrameHE.__ge__()": "", "FrameHE.__gt__()": "", "FrameHE.__le__()": "", "FrameHE.__lt__()": "", "FrameHE.__matmul__()": "", "FrameHE.__mod__()": "", "FrameHE.__mul__()": "", "FrameHE.__ne__()": "Return False if other is a Frame with the different labels, values, or name. Con...", "FrameHE.__or__()": "", "FrameHE.__pow__()": "", "FrameHE.__radd__()": "", "FrameHE.__rfloordiv__()": "", "FrameHE.__rmatmul__()": "", "FrameHE.__rmul__()": "", "FrameHE.__rshift__()": "", "FrameHE.__rsub__()": "", "FrameHE.__rtruediv__()": "", "FrameHE.__sub__()": "", "FrameHE.__truediv__()": "", "FrameHE.__xor__()": "", "FrameHE.__abs__()": "", "FrameHE.__invert__()": "", "FrameHE.__neg__()": "", "FrameHE.__pos__()": "", "FrameHE.via_values.apply()": "", "FrameHE.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "FrameHE.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "FrameHE.via_dt.year": "Return the year of each element.", "FrameHE.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "FrameHE.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "FrameHE.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "FrameHE.via_dt.hour": "Return the hour of each element, between 0 and 24.", "FrameHE.via_dt.minute": "Return the minute of each element, between 0 and 60.", "FrameHE.via_dt.second": "Return the second of each element, between 0 and 60.", "FrameHE.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "FrameHE.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "FrameHE.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "FrameHE.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "FrameHE.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "FrameHE.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "FrameHE.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "FrameHE.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "FrameHE.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "FrameHE.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "FrameHE.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "FrameHE.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "FrameHE.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "FrameHE.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "FrameHE.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "FrameHE.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "FrameHE.via_str.center()": "Return a container with its elements centered in a string of length width.", "FrameHE.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "FrameHE.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "FrameHE.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "FrameHE.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "FrameHE.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "FrameHE.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "FrameHE.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "FrameHE.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "FrameHE.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "FrameHE.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "FrameHE.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "FrameHE.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "FrameHE.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "FrameHE.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "FrameHE.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "FrameHE.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "FrameHE.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "FrameHE.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "FrameHE.via_str.len()": "Return the length of the string.", "FrameHE.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "FrameHE.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "FrameHE.via_str.partition()": "Partition each element around sep.", "FrameHE.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "FrameHE.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "FrameHE.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "FrameHE.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "FrameHE.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "FrameHE.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "FrameHE.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "FrameHE.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "FrameHE.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "FrameHE.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "FrameHE.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "FrameHE.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "FrameHE.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "FrameHE.via_str.zfill()": "Return the string left-filled with zeros.", "FrameHE.via_T.via_fill_value()": "Interface for using binary operators and methods with a pre-defined fill value.", "FrameHE.via_T.__add__()": "", "FrameHE.via_T.__sub__()": "", "FrameHE.via_T.__mul__()": "", "FrameHE.via_T.__truediv__()": "", "FrameHE.via_T.__floordiv__()": "", "FrameHE.via_T.__mod__()": "", "FrameHE.via_T.__pow__()": "", "FrameHE.via_T.__lshift__()": "", "FrameHE.via_T.__rshift__()": "", "FrameHE.via_T.__and__()": "", "FrameHE.via_T.__xor__()": "", "FrameHE.via_T.__or__()": "", "FrameHE.via_T.__lt__()": "", "FrameHE.via_T.__le__()": "", "FrameHE.via_T.__eq__()": "", "FrameHE.via_T.__ne__()": "", "FrameHE.via_T.__gt__()": "", "FrameHE.via_T.__ge__()": "", "FrameHE.via_T.__radd__()": "", "FrameHE.via_T.__rsub__()": "", "FrameHE.via_T.__rmul__()": "", "FrameHE.via_T.__rtruediv__()": "", "FrameHE.via_T.__rfloordiv__()": "", "FrameHE.via_fill_value().loc": "Label-based selection where labels not specified will define a new container con...", "FrameHE.via_fill_value().__getitem__()": "Label-based selection where labels not specified will define a new container con...", "FrameHE.via_fill_value().via_T": "Interface for using binary operators with one-dimensional sequences, where the o...", "FrameHE.via_fill_value().__add__()": "", "FrameHE.via_fill_value().__sub__()": "", "FrameHE.via_fill_value().__mul__()": "", "FrameHE.via_fill_value().__truediv__()": "", "FrameHE.via_fill_value().__floordiv__()": "", "FrameHE.via_fill_value().__mod__()": "", "FrameHE.via_fill_value().__pow__()": "", "FrameHE.via_fill_value().__lshift__()": "", "FrameHE.via_fill_value().__rshift__()": "", "FrameHE.via_fill_value().__and__()": "", "FrameHE.via_fill_value().__xor__()": "", "FrameHE.via_fill_value().__or__()": "", "FrameHE.via_fill_value().__lt__()": "", "FrameHE.via_fill_value().__le__()": "", "FrameHE.via_fill_value().__eq__()": "", "FrameHE.via_fill_value().__ne__()": "", "FrameHE.via_fill_value().__gt__()": "", "FrameHE.via_fill_value().__ge__()": "", "FrameHE.via_fill_value().__radd__()": "", "FrameHE.via_fill_value().__rsub__()": "", "FrameHE.via_fill_value().__rmul__()": "", "FrameHE.via_fill_value().__rtruediv__()": "", "FrameHE.via_fill_value().__rfloordiv__()": "", "FrameHE.via_re().search()": "Scan through string looking for the first location where this regular expression...", "FrameHE.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "FrameHE.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "FrameHE.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "FrameHE.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "FrameHE.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "FrameHE.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "FrameHE.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "FrameHE.via_hashlib().md5()": "", "FrameHE.via_hashlib().sha256()": "", "FrameHE.via_hashlib().sha512()": "", "FrameHE.via_hashlib().sha3_256()": "", "FrameHE.via_hashlib().sha3_512()": "", "FrameHE.via_hashlib().shake_128()": "", "FrameHE.via_hashlib().shake_256()": "", "FrameHE.via_hashlib().blake2b()": "", "FrameHE.via_hashlib().blake2s()": "", "Bus.__init__()": "Default Bus constructor. {args}", "Bus.from_concat()": "Concatenate multiple Bus into a new Bus. All Bus will load all Frame into memory...", "Bus.from_dict()": "Bus construction from a mapping of labels and Frame. Args: mapping: a dictionary...", "Bus.from_frames()": "Return a Bus from an iterable of Frame; labels will be drawn from Frame.name.", "Bus.from_hdf5()": "Given a file path to a HDF5 Bus store, return a Bus instance. Args: fp: A string...", "Bus.from_items()": "Return a Bus from an iterable of pairs of label, Frame. Returns: Bus", "Bus.from_series()": "Create a Bus from a Series of Frame.", "Bus.from_sqlite()": "Given a file path to an SQLite Bus store, return a Bus instance. Args: fp: A str...", "Bus.from_xlsx()": "Given a file path to an XLSX Bus store, return a Bus instance. Args: fp: A strin...", "Bus.from_zip_csv()": "Given a file path to zipped CSV Bus store, return a Bus instance. Args: fp: A st...", "Bus.from_zip_npy()": "Given a file path to zipped NPY Bus store, return a Bus instance. Args: fp: A st...", "Bus.from_zip_npz()": "Given a file path to zipped NPZ Bus store, return a Bus instance. Args: fp: A st...", "Bus.from_zip_parquet()": "Given a file path to zipped parquet Bus store, return a Bus instance. Args: fp:...", "Bus.from_zip_pickle()": "Given a file path to zipped pickle Bus store, return a Bus instance. Args: fp: A...", "Bus.from_zip_tsv()": "Given a file path to zipped TSV Bus store, return a Bus instance. Args: fp: A st...", "Bus.to_hdf5()": "Write the complete Bus as an HDF5 table. Args: fp: A string file path or Path in...", "Bus.to_series()": "Return a Series with the Frame contained in this Bus. If the Bus is associated w...", "Bus.to_sqlite()": "Write the complete Bus as an SQLite database file. Args: fp: A string file path...", "Bus.to_visidata()": "Open an interactive VisiData session.", "Bus.to_xlsx()": "Write the complete Bus as a XLSX workbook. Args: fp: A string file path or Path...", "Bus.to_zip_csv()": "Write the complete Bus as a zipped archive of CSV files. Args: fp: A string file...", "Bus.to_zip_npy()": "Write the complete Bus as a zipped archive of NPY files. Args: fp: A string file...", "Bus.to_zip_npz()": "Write the complete Bus as a zipped archive of NPZ files. Args: fp: A string file...", "Bus.to_zip_parquet()": "Write the complete Bus as a zipped archive of parquet files. Args: fp: A string...", "Bus.to_zip_pickle()": "Write the complete Bus as a zipped archive of pickles. Args: fp: A string file p...", "Bus.to_zip_tsv()": "Write the complete Bus as a zipped archive of TSV files. Args: fp: A string file...", "Bus.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "Bus.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "Bus.dtypes": "Returns a Frame of dtype per column for all loaded Frames.", "Bus.index": "The index instance assigned to this container. Returns: Index", "Bus.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "Bus.mloc": "Returns a Series showing a tuple of memory locations within each loaded Frame.", "Bus.name": "A hashable label attached to this container. Returns: Hashable", "Bus.nbytes": "Total bytes of data currently loaded in the Bus.", "Bus.ndim": "Return the number of dimensions, which for a Bus is always 1. Returns: int", "Bus.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: Tupl...", "Bus.shapes": "A Series describing the shape of each loaded Frame. Unloaded Frame will have a s...", "Bus.size": "Return the size of the underlying NumPy array. Returns: int", "Bus.status": "Return a Frame indicating loaded status, size, bytes, and shape of all loaded Fr...", "Bus.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "Bus.__len__()": "Length of values.", "Bus.equals()": "Return a bool from comparison to any other object. Note: this will attempt to lo...", "Bus.head()": "Return a Bus consisting only of the top elements as specified by count. Args: co...", "Bus.rehierarch()": "Return a new Bus with new a hierarchy based on the supplied depth_map.", "Bus.reindex()": "Return a new Bus with labels defined by the provided index. The size and orderin...", "Bus.relabel()": "Return a new Bus with transformed labels on the index. The size and ordering of...", "Bus.relabel_flat()": "Return a new Bus, where an IndexHierarchy (if defined) is replaced with a flat,...", "Bus.relabel_level_add()": "Return a new Bus, adding a new root level to an existing IndexHierarchy, or crea...", "Bus.relabel_level_drop()": "Return a new Bus, dropping one or more levels from a either the root or the leav...", "Bus.rename()": "Return a new Bus with an updated name attribute.", "Bus.roll()": "Return a Bus with values rotated forward and wrapped around the index (with a po...", "Bus.shift()": "Return a Bus with values shifted forward on the index (with a positive shift) or...", "Bus.sort_index()": "Return a new Bus ordered by the sorted Index. Args: * ascendings: Boolean, or it...", "Bus.sort_values()": "Return a new Bus ordered by the sorted values. Note that as a Bus contains Frame...", "Bus.tail()": "Return a Bus consisting only of the bottom elements as specified by count. s Arg...", "Bus.unpersist()": "Replace loaded Frame with FrameDeferred.", "Bus.__contains__()": "Inclusion of value in index labels. Returns: bool", "Bus.__iter__()": "Iterator of index labels, same as Series.keys. Returns: Iterator[Hashasble]", "Bus.__reversed__()": "Returns a reverse iterator on the Bus index. Returns: Index", "Bus.get()": "Return the value found at the index key, else the default if the key is not foun...", "Bus.items()": "Iterator of pairs of Bus label and contained Frame.", "Bus.keys()": "Iterator of index labels. Returns: Iterator[Hashable]", "Bus.values": "A 1D object array of all Frame contained in the Bus. The returned np.ndarray wil...", "Bus.interface": "A Frame documenting the interface of this class.", "Bus.__repr__()": "", "Bus.__str__()": "Return str(self).", "Bus.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "Bus.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "Bus.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "Bus.drop[]": "Label-based selection.", "Bus.drop.iloc[]": "", "Bus.drop.loc[]": "", "Bus.[]": "Selector of values by label. Args: key: A loc selector, either a label, a list o...", "Bus.iloc[]": "", "Bus.loc[]": "", "Bus.iter_element()": "Iterator of elements.", "Bus.iter_element().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Bus.iter_element().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Bus.iter_element().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Bus.iter_element().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Bus.iter_element_items()": "Iterator of label, element pairs.", "Bus.iter_element_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Bus.iter_element_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Bus.iter_element_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Bus.iter_element_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Bus.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "Bus.via_hashlib().md5()": "", "Bus.via_hashlib().sha256()": "", "Bus.via_hashlib().sha512()": "", "Bus.via_hashlib().sha3_256()": "", "Bus.via_hashlib().sha3_512()": "", "Bus.via_hashlib().shake_128()": "", "Bus.via_hashlib().shake_256()": "", "Bus.via_hashlib().blake2b()": "", "Bus.via_hashlib().blake2s()": "", "Batch.__init__()": "Default constructor of a Batch. Args: name: A hashable object to label the conta...", "Batch.from_frames()": "Return a Batch from an iterable of Frame; labels will be drawn from Frame.name.", "Batch.from_hdf5()": "Given a file path to a HDF5 Batch store, return a Batch instance. Args: fp: A st...", "Batch.from_sqlite()": "Given a file path to an SQLite Batch store, return a Batch instance. Args: fp: A...", "Batch.from_xlsx()": "Given a file path to an XLSX Batch store, return a Batch instance. Args: fp: A s...", "Batch.from_zip_csv()": "Given a file path to zipped CSV Batch store, return a Batch instance. Args: fp:...", "Batch.from_zip_npy()": "Given a file path to zipped NPY Batch store, return a Batch instance. Args: fp:...", "Batch.from_zip_npz()": "Given a file path to zipped NPZ Batch store, return a Batch instance. Args: fp:...", "Batch.from_zip_parquet()": "Given a file path to zipped parquet Batch store, return a Batch instance. Args:...", "Batch.from_zip_pickle()": "Given a file path to zipped pickle Batch store, return a Batch instance. Args: f...", "Batch.from_zip_tsv()": "Given a file path to zipped TSV Batch store, return a Batch instance. Args: fp:...", "Batch.to_bus()": "Realize the Batch as an Bus. Note that, as a Bus must have all labels (even if F...", "Batch.to_frame()": "Consolidate stored Frame into a new Frame using the stored labels as the index o...", "Batch.to_hdf5()": "Write the complete Bus as an HDF5 table. Args: fp: A string file path or Path in...", "Batch.to_series()": "Consolidate stored values into a new Series using the stored labels as the index...", "Batch.to_sqlite()": "Write the complete Bus as an SQLite database file. Args: fp: A string file path...", "Batch.to_visidata()": "Open an interactive VisiData session.", "Batch.to_xlsx()": "Write the complete Bus as a XLSX workbook. Args: fp: A string file path or Path...", "Batch.to_zip_csv()": "Write the complete Bus as a zipped archive of CSV files. Args: fp: A string file...", "Batch.to_zip_npy()": "Write the complete Bus as a zipped archive of NPY files. Args: fp: A string file...", "Batch.to_zip_npz()": "Write the complete Bus as a zipped archive of NPZ files. Args: fp: A string file...", "Batch.to_zip_parquet()": "Write the complete Bus as a zipped archive of parquet files. Args: fp: A string...", "Batch.to_zip_pickle()": "Write the complete Bus as a zipped archive of pickles. Args: fp: A string file p...", "Batch.to_zip_tsv()": "Write the complete Bus as a zipped archive of TSV files. Args: fp: A string file...", "Batch.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "Batch.T": "Transpose. Return a Frame with index as columns and vice versa.", "Batch.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "Batch.name": "A hashable label attached to this container. Returns: Hashable", "Batch.shapes": "A Series describing the shape of each iterated Frame. Returns: tp.Tuple[int]", "Batch.via_container": "Return a new Batch with all values wrapped in either a Frame or Series.", "Batch.__array__()": "Support the __array__ interface, returning an array of values.", "Batch.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "Batch.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "Batch.__round__()": "Return a Batch with contained Frame rounded to the given decimals. Negative deci...", "Batch.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "Batch.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "Batch.apply()": "Apply a function to each Frame contained in this Frame, where a function is give...", "Batch.apply_except()": "Apply a function to each Frame contained in this Frame, where a function is give...", "Batch.apply_items()": "Apply a function to each Frame contained in this Frame, where a function is give...", "Batch.apply_items_except()": "Apply a function to each Frame contained in this Frame, where a function is give...", "Batch.astype[]()": "Selector of columns by label. Args: key: A loc selector, either a label, a list...", "Batch.astype()": "Apply a single dtype to all columns.", "Batch.clip()": "Apply a clip operation to this Batch. Note that clip operations can be applied t...", "Batch.corr()": "Compute a correlation matrix. Args: axis: if 0, each row represents a variable,...", "Batch.count()": "Apply count on contained Frames.", "Batch.cov()": "Compute a covariance matrix. Args: axis: if 0, each row represents a variable, w...", "Batch.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "Batch.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "Batch.drop_duplicated()": "Return a Batch with contained Frame with duplicated rows (axis 0) or columns (ax...", "Batch.dropfalsy()": "Return a Batch with contained Frame after removing rows (axis 0) or columns (axi...", "Batch.dropna()": "Return a Batch with contained Frame after removing rows (axis 0) or columns (axi...", "Batch.duplicated()": "Return an axis-sized Boolean Series that shows True for all rows (axis 0) or col...", "Batch.equals()": "", "Batch.fillfalsy()": "Return a new Batch with contained Frame after filling falsy values with the prov...", "Batch.fillfalsy_backward()": "Return a new Batch with contained Frame after filling backward falsy values with...", "Batch.fillfalsy_forward()": "Return a new Batch with contained Frame after filling forward falsy values with...", "Batch.fillfalsy_leading()": "Return a new Batch with contained Frame after filling leading (and only leading)...", "Batch.fillfalsy_trailing()": "Return a new Batch with contained Frame after filling trailing (and only trailin...", "Batch.fillna()": "Return a new Batch with contained Frame after filling null (NaN or None) with th...", "Batch.fillna_backward()": "Return a new Batch with contained Frame after filling backward null (NaN or None...", "Batch.fillna_forward()": "Return a new Batch with contained Frame after filling forward null (NaN or None)...", "Batch.fillna_leading()": "Return a new Batch with contained Frame after filling leading (and only leading)...", "Batch.fillna_trailing()": "Return a new Batch with contained Frame after filling trailing (and only trailin...", "Batch.head()": "Return a Batch consisting only of the top elements as specified by count. Args:...", "Batch.iloc_max()": "Return the integer indices corresponding to the maximum values found. Args: skip...", "Batch.iloc_min()": "Return the integer indices corresponding to the minimum values found. Args: skip...", "Batch.isfalsy()": "Return a Batch with contained, same-indexed Frame indicating True which values a...", "Batch.isin()": "Return a new Batch with contained Frame as a same-sized Boolean Frame that shows...", "Batch.isna()": "Return a Batch with contained, same-indexed Frame indicating True which values a...", "Batch.loc_max()": "Return the labels corresponding to the maximum values found. Args: skipna: if Tr...", "Batch.loc_min()": "Return the labels corresponding to the minimum value found. Args: skipna: if Tru...", "Batch.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "Batch.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "Batch.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "Batch.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "Batch.notfalsy()": "Return a Batch with contained, same-indexed Frame indicating True which values a...", "Batch.notna()": "Return a Batch with contained, same-indexed Frame indicating True which values a...", "Batch.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "Batch.rank_dense()": "", "Batch.rank_max()": "", "Batch.rank_mean()": "", "Batch.rank_min()": "", "Batch.rank_ordinal()": "", "Batch.reindex()": "", "Batch.relabel()": "", "Batch.relabel_flat()": "", "Batch.relabel_level_add()": "", "Batch.relabel_level_drop()": "", "Batch.relabel_shift_in()": "", "Batch.rename()": "Return a new Batch with an updated name attribute.", "Batch.roll()": "Roll columns and/or rows by positive or negative integer counts, where columns a...", "Batch.sample()": "Apply sample on contained Frames. Args: Number of labels to select from the inde...", "Batch.shift()": "Shift columns and/or rows by positive or negative integer counts, where columns...", "Batch.sort_columns()": "Return a new Batch with contained Frame ordered by the sorted columns.", "Batch.sort_index()": "Return a new Batch with contained :obj;Frame ordered by the sorted index.", "Batch.sort_values()": "Return a new Batch with contained Frame ordered by the sorted values, where valu...", "Batch.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "Batch.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "Batch.tail()": "Return a Batch consisting only of the bottom elements as specified by count. Arg...", "Batch.transpose()": "Transpose. Return a Frame with index as columns and vice versa.", "Batch.unique()": "Return a NumPy array of unqiue values. If the axis argument is provied, uniquene...", "Batch.unset_index()": "", "Batch.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "Batch.__iter__()": "Iterator of Frame labels, same as Batch.keys.", "Batch.items()": "Iterator of labels, Frame.", "Batch.keys()": "Iterator of Frame labels.", "Batch.values": "Return an iterator of values (Frame or Series) stored in this Batch.", "Batch.interface": "A Frame documenting the interface of this class.", "Batch.__repr__()": "Provide a display of the Batch that does not exhaust the generator.", "Batch.__str__()": "Return str(self).", "Batch.display()": "Provide a Series-style display of the Batch. Note that if the held iterator is a...", "Batch.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "Batch.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "Batch.bloc[]": "", "Batch.drop[]": "Label-based selection.", "Batch.drop.iloc[]": "", "Batch.drop.loc[]": "", "Batch.[]": "", "Batch.iloc[]": "", "Batch.loc[]": "", "Batch.__add__()": "", "Batch.__and__()": "", "Batch.__eq__()": "", "Batch.__floordiv__()": "", "Batch.__ge__()": "", "Batch.__gt__()": "", "Batch.__le__()": "", "Batch.__lt__()": "", "Batch.__matmul__()": "", "Batch.__mod__()": "", "Batch.__mul__()": "", "Batch.__ne__()": "", "Batch.__or__()": "", "Batch.__pow__()": "", "Batch.__radd__()": "", "Batch.__rfloordiv__()": "", "Batch.__rmatmul__()": "", "Batch.__rmul__()": "", "Batch.__rshift__()": "", "Batch.__rsub__()": "", "Batch.__rtruediv__()": "", "Batch.__sub__()": "", "Batch.__truediv__()": "", "Batch.__xor__()": "", "Batch.__abs__()": "", "Batch.__invert__()": "", "Batch.__neg__()": "", "Batch.__pos__()": "", "Batch.via_values.apply()": "Interface for using binary operators and methods with a pre-defined fill value.", "Batch.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "Batch.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "Batch.via_dt.year": "Return the year of each element.", "Batch.via_dt.year_month": "Return the month of each element, between 1 and 12 inclusive.", "Batch.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "Batch.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "Batch.via_dt.hour": "Return the hour of each element, between 0 and 24.", "Batch.via_dt.minute": "Return the minute of each element, between 0 and 60.", "Batch.via_dt.second": "Return the second of each element, between 0 and 60.", "Batch.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "Batch.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "Batch.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "Batch.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "Batch.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "Batch.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "Batch.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "Batch.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "Batch.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "Batch.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "Batch.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "Batch.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "Batch.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "Batch.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "Batch.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "Batch.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "Batch.via_str.center()": "Return a container with its elements centered in a string of length width.", "Batch.via_str.contains()": "Returns a container with the number of non-overlapping occurrences of substring...", "Batch.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "Batch.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "Batch.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "Batch.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "Batch.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "Batch.via_str.format()": "For each element, return a string resulting from calling the format argument's f...", "Batch.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "Batch.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "Batch.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "Batch.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "Batch.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "Batch.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "Batch.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "Batch.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "Batch.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "Batch.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "Batch.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "Batch.via_str.len()": "Return the length of the string.", "Batch.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "Batch.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "Batch.via_str.partition()": "Partition each element around sep.", "Batch.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "Batch.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "Batch.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "Batch.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "Batch.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "Batch.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "Batch.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "Batch.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "Batch.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "Batch.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "Batch.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "Batch.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "Batch.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "Batch.via_str.zfill()": "Return the string left-filled with zeros.", "Batch.via_T.via_fill_value()": "Interface for using binary operators and methods with a pre-defined fill value.", "Batch.via_T.__add__()": "", "Batch.via_T.__sub__()": "", "Batch.via_T.__mul__()": "", "Batch.via_T.__truediv__()": "", "Batch.via_T.__floordiv__()": "", "Batch.via_T.__mod__()": "", "Batch.via_T.__pow__()": "", "Batch.via_T.__lshift__()": "", "Batch.via_T.__rshift__()": "", "Batch.via_T.__and__()": "", "Batch.via_T.__xor__()": "", "Batch.via_T.__or__()": "", "Batch.via_T.__lt__()": "", "Batch.via_T.__le__()": "", "Batch.via_T.__eq__()": "", "Batch.via_T.__ne__()": "", "Batch.via_T.__gt__()": "", "Batch.via_T.__ge__()": "", "Batch.via_T.__radd__()": "", "Batch.via_T.__rsub__()": "", "Batch.via_T.__rmul__()": "", "Batch.via_T.__rtruediv__()": "", "Batch.via_T.__rfloordiv__()": "", "Batch.via_fill_value().loc": "Label-based selection where labels not specified will define a new container con...", "Batch.via_fill_value().__getitem__()": "Label-based selection where labels not specified will define a new container con...", "Batch.via_fill_value().via_T": "Interface for using binary operators with one-dimensional sequences, where the o...", "Batch.via_fill_value().__add__()": "", "Batch.via_fill_value().__sub__()": "", "Batch.via_fill_value().__mul__()": "", "Batch.via_fill_value().__truediv__()": "", "Batch.via_fill_value().__floordiv__()": "", "Batch.via_fill_value().__mod__()": "", "Batch.via_fill_value().__pow__()": "", "Batch.via_fill_value().__lshift__()": "", "Batch.via_fill_value().__rshift__()": "", "Batch.via_fill_value().__and__()": "", "Batch.via_fill_value().__xor__()": "", "Batch.via_fill_value().__or__()": "", "Batch.via_fill_value().__lt__()": "", "Batch.via_fill_value().__le__()": "", "Batch.via_fill_value().__eq__()": "", "Batch.via_fill_value().__ne__()": "", "Batch.via_fill_value().__gt__()": "", "Batch.via_fill_value().__ge__()": "", "Batch.via_fill_value().__radd__()": "", "Batch.via_fill_value().__rsub__()": "", "Batch.via_fill_value().__rmul__()": "", "Batch.via_fill_value().__rtruediv__()": "", "Batch.via_fill_value().__rfloordiv__()": "", "Batch.via_re().search()": "Scan through string looking for the first location where this regular expression...", "Batch.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "Batch.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "Batch.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "Batch.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "Batch.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "Batch.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "Batch.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "Batch.via_hashlib().md5()": "", "Batch.via_hashlib().sha256()": "", "Batch.via_hashlib().sha512()": "", "Batch.via_hashlib().sha3_256()": "", "Batch.via_hashlib().sha3_512()": "", "Batch.via_hashlib().shake_128()": "", "Batch.via_hashlib().shake_256()": "", "Batch.via_hashlib().blake2b()": "", "Batch.via_hashlib().blake2s()": "", "Yarn.__init__()": "Args: series: An iterable (or Series) of Bus. The length of this container is no...", "Yarn.from_buses()": "Return a Yarn from an iterable of Bus; labels will be drawn from Bus.name.", "Yarn.from_concat()": "Concatenate multiple Yarn into a new Yarn. Loaded status of Frame within each Bu...", "Yarn.to_hdf5()": "Write the complete Bus as an HDF5 table. Args: fp: A string file path or Path in...", "Yarn.to_series()": "Return a Series with the Frame contained in all contained Bus.", "Yarn.to_sqlite()": "Write the complete Bus as an SQLite database file. Args: fp: A string file path...", "Yarn.to_visidata()": "Open an interactive VisiData session.", "Yarn.to_xlsx()": "Write the complete Bus as a XLSX workbook. Args: fp: A string file path or Path...", "Yarn.to_zip_csv()": "Write the complete Bus as a zipped archive of CSV files. Args: fp: A string file...", "Yarn.to_zip_npy()": "Write the complete Bus as a zipped archive of NPY files. Args: fp: A string file...", "Yarn.to_zip_npz()": "Write the complete Bus as a zipped archive of NPZ files. Args: fp: A string file...", "Yarn.to_zip_parquet()": "Write the complete Bus as a zipped archive of parquet files. Args: fp: A string...", "Yarn.to_zip_pickle()": "Write the complete Bus as a zipped archive of pickles. Args: fp: A string file p...", "Yarn.to_zip_tsv()": "Write the complete Bus as a zipped archive of TSV files. Args: fp: A string file...", "Yarn.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "Yarn.dtype": "Return the dtype of the realized NumPy array. Returns: numpy.dtype", "Yarn.dtypes": "Returns a Frame of dtypes for all loaded Frames.", "Yarn.index": "The index instance assigned to this container. Returns: Index", "Yarn.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "Yarn.mloc": "Returns a Series showing a tuple of memory locations within each loaded Frame.", "Yarn.name": "A hashable label attached to this container. Returns: Hashable", "Yarn.nbytes": "Total bytes of data currently loaded in Bus contained in this Yarn.", "Yarn.ndim": "Return the number of dimensions, which for a Yarn is always 1. Returns: int", "Yarn.shape": "Return a tuple describing the shape of the realized NumPy array. Returns: Tuple[...", "Yarn.shapes": "A Series describing the shape of each loaded Frame. Unloaded Frame will have a s...", "Yarn.size": "Return the size of the underlying NumPy array. Returns: int", "Yarn.status": "Return a Frame indicating loaded status, size, bytes, and shape of all loaded Fr...", "Yarn.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "Yarn.__len__()": "Length of values.", "Yarn.equals()": "Return a bool from comparison to any other object. Note: this will attempt to lo...", "Yarn.head()": "Return a Yarn consisting only of the top elements as specified by count. Args: c...", "Yarn.rehierarch()": "Return a new Series with new a hierarchy based on the supplied depth_map.", "Yarn.relabel()": "Return a new Yarn with transformed labels on the index. The size and ordering of...", "Yarn.relabel_flat()": "Return a new Yarn, where an IndexHierarchy (if defined) is replaced with a flat,...", "Yarn.relabel_level_add()": "Return a new Yarn, adding a new root level to an existing IndexHierarchy, or cre...", "Yarn.relabel_level_drop()": "Return a new Yarn, dropping one or more levels from a either the root or the lea...", "Yarn.rename()": "Return a new Yarn with an updated name attribute. Args: name", "Yarn.tail()": "Return a Yarn consisting only of the bottom elements as specified by count. s Ar...", "Yarn.unpersist()": "For the Bus contained in this object, replace all loaded Frame with FrameDeferre...", "Yarn.__contains__()": "Inclusion of value in index labels. Returns: bool", "Yarn.__iter__()": "Iterator of index labels, same as Series.keys. Returns: Iterator[Hashasble]", "Yarn.__reversed__()": "Returns a reverse iterator on the Yarn index. Returns: Index", "Yarn.get()": "Return the value found at the index key, else the default if the key is not foun...", "Yarn.items()": "Iterator of pairs of Yarn label and contained Frame.", "Yarn.keys()": "Iterator of index labels. Returns: Iterator[Hashable]", "Yarn.values": "A 1D object array of all Frame contained in all contained Bus.", "Yarn.interface": "A Frame documenting the interface of this class.", "Yarn.__repr__()": "", "Yarn.__str__()": "Return str(self).", "Yarn.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "Yarn.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "Yarn.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "Yarn.drop[]": "Label-based selection.", "Yarn.drop.iloc[]": "", "Yarn.drop.loc[]": "", "Yarn.[]": "Selector of values by label. Args: key: A loc selector, either a label, a list o...", "Yarn.iloc[]": "", "Yarn.loc[]": "", "Yarn.iter_element()": "Iterator of elements.", "Yarn.iter_element().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Yarn.iter_element().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Yarn.iter_element().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Yarn.iter_element().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Yarn.iter_element_items()": "Iterator of label, element pairs.", "Yarn.iter_element_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Yarn.iter_element_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Yarn.iter_element_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Yarn.iter_element_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Yarn.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "Yarn.via_hashlib().md5()": "", "Yarn.via_hashlib().sha256()": "", "Yarn.via_hashlib().sha512()": "", "Yarn.via_hashlib().sha3_256()": "", "Yarn.via_hashlib().sha3_512()": "", "Yarn.via_hashlib().shake_128()": "", "Yarn.via_hashlib().shake_256()": "", "Yarn.via_hashlib().blake2b()": "", "Yarn.via_hashlib().blake2s()": "", "Quilt.__init__()": "Args: bus: Bus of Frame to be used for virtual concatenation. axis: Integer spec...", "Quilt.from_frame()": "Given a Frame, create a Quilt by partitioning it along the specified axis in uni...", "Quilt.from_frames()": "Return a Quilt from an iterable of Frame; labels will be drawn from Frame.name.", "Quilt.from_hdf5()": "Given a file path to a HDF5 Quilt store, return a Quilt instance. Args: fp: A st...", "Quilt.from_items()": "Given an iterable of pairs of label, Frame, create a Quilt.", "Quilt.from_sqlite()": "Given a file path to an SQLite Quilt store, return a Quilt instance. Args: fp: A...", "Quilt.from_xlsx()": "Given a file path to an XLSX Quilt store, return a Quilt instance. Args: fp: A s...", "Quilt.from_zip_csv()": "Given a file path to zipped CSV Quilt store, return a Quilt instance. Args: fp:...", "Quilt.from_zip_npy()": "Given a file path to zipped NPY Quilt store, return a Quilt instance. Args: fp:...", "Quilt.from_zip_npz()": "Given a file path to zipped NPZ Quilt store, return a Quilt instance. Args: fp:...", "Quilt.from_zip_parquet()": "Given a file path to zipped parquet Quilt store, return a Quilt instance. Args:...", "Quilt.from_zip_pickle()": "Given a file path to zipped pickle Quilt store, return a Quilt instance. Args: f...", "Quilt.from_zip_tsv()": "Given a file path to zipped TSV Quilt store, return a Quilt instance. Args: fp:...", "Quilt.to_frame()": "Return a consolidated Frame.", "Quilt.to_hdf5()": "Write the complete Bus as an HDF5 table. Args: fp: A string file path or Path in...", "Quilt.to_sqlite()": "Write the complete Bus as an SQLite database file. Args: fp: A string file path...", "Quilt.to_visidata()": "Open an interactive VisiData session.", "Quilt.to_xlsx()": "Write the complete Bus as a XLSX workbook. Args: fp: A string file path or Path...", "Quilt.to_zip_csv()": "Write the complete Bus as a zipped archive of CSV files. Args: fp: A string file...", "Quilt.to_zip_npy()": "Write the complete Bus as a zipped archive of NPY files. Args: fp: A string file...", "Quilt.to_zip_npz()": "Write the complete Bus as a zipped archive of NPZ files. Args: fp: A string file...", "Quilt.to_zip_parquet()": "Write the complete Bus as a zipped archive of parquet files. Args: fp: A string...", "Quilt.to_zip_pickle()": "Write the complete Bus as a zipped archive of pickles. Args: fp: A string file p...", "Quilt.to_zip_tsv()": "Write the complete Bus as a zipped archive of TSV files. Args: fp: A string file...", "Quilt.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "Quilt.columns": "The IndexBase instance assigned for column labels.", "Quilt.index": "The IndexBase instance assigned for row labels.", "Quilt.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "Quilt.name": "A hashable label attached to this container. Returns: Hashable", "Quilt.nbytes": "Return the total bytes of the underlying NumPy arrays. Returns: int", "Quilt.ndim": "Return the number of dimensions, which for a Frame is always 2. Returns: int", "Quilt.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "Quilt.size": "Return the size of the underlying NumPy array. Returns: int", "Quilt.status": "Return a Frame indicating loaded status, size, bytes, and shape of all loaded Fr...", "Quilt.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "Quilt.equals()": "Return a bool from comparison to any other object. Note: this will attempt to lo...", "Quilt.head()": "Return a Quilt consisting only of the top elements as specified by count. Args:...", "Quilt.rename()": "Return a new Quilt with an updated name attribute. Args: name", "Quilt.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "Quilt.tail()": "Return a Quilt consisting only of the bottom elements as specified by count. Arg...", "Quilt.unpersist()": "For the Bus or Yarn contained in this object, replace all loaded Frame with Fram...", "Quilt.__contains__()": "Inclusion of value in column labels.", "Quilt.__iter__()": "Iterator of column labels, same as Frame.keys.", "Quilt.get()": "Return the value found at the columns key, else the default if the key is not fo...", "Quilt.items()": "Iterator of pairs of column label and corresponding column Series.", "Quilt.keys()": "Iterator of column labels.", "Quilt.values": "A 2D NumPy array of all values in the Quilt. As this is a single array, heteroge...", "Quilt.interface": "A Frame documenting the interface of this class.", "Quilt.__repr__()": "", "Quilt.__str__()": "Return str(self).", "Quilt.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "Quilt.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "Quilt.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "Quilt.[]": "Selector of columns by label. Args: key: A loc selector, either a label, a list...", "Quilt.iloc[]": "", "Quilt.loc[]": "", "Quilt.iter_array()": "Iterator of np.array, where arrays are drawn from columns (axis=0) or rows (axis...", "Quilt.iter_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Quilt.iter_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Quilt.iter_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Quilt.iter_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Quilt.iter_array_items()": "Iterator of pairs of label, np.array, where arrays are drawn from columns (axis=...", "Quilt.iter_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Quilt.iter_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Quilt.iter_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Quilt.iter_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Quilt.iter_series()": "Iterator of Series, where Series are drawn from columns (axis=0) or rows (axis=1...", "Quilt.iter_series().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Quilt.iter_series().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Quilt.iter_series().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Quilt.iter_series().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Quilt.iter_series_items()": "Iterator of pairs of label, Series, where Series are drawn from columns (axis=0)...", "Quilt.iter_series_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Quilt.iter_series_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Quilt.iter_series_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Quilt.iter_series_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Quilt.iter_tuple()": "Iterator of NamedTuple, where tuples are drawn from columns (axis=0) or rows (ax...", "Quilt.iter_tuple().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Quilt.iter_tuple().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Quilt.iter_tuple().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Quilt.iter_tuple().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Quilt.iter_tuple().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "Quilt.iter_tuple().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "Quilt.iter_tuple().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "Quilt.iter_tuple().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "Quilt.iter_tuple().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "Quilt.iter_tuple().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "Quilt.iter_tuple().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "Quilt.iter_tuple().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "Quilt.iter_tuple().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "Quilt.iter_tuple_items()": "Iterator of pairs of label, NamedTuple, where tuples are drawn from columns (axi...", "Quilt.iter_tuple_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Quilt.iter_tuple_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Quilt.iter_tuple_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Quilt.iter_tuple_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Quilt.iter_tuple_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns...", "Quilt.iter_tuple_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "Quilt.iter_tuple_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A genera...", "Quilt.iter_tuple_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a...", "Quilt.iter_tuple_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "Quilt.iter_tuple_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generat...", "Quilt.iter_tuple_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Retu...", "Quilt.iter_tuple_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "Quilt.iter_tuple_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A ge...", "Quilt.iter_window()": "Iterator of windowed values, where values are given as a Frame. Args: size: Elem...", "Quilt.iter_window().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Quilt.iter_window().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Quilt.iter_window().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Quilt.iter_window().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Quilt.iter_window_array()": "Iterator of windowed values, where values are given as a np.array. Args: size: E...", "Quilt.iter_window_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Quilt.iter_window_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Quilt.iter_window_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Quilt.iter_window_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Quilt.iter_window_array_items()": "Iterator of pairs of label, windowed values, where values are given as a np.arra...", "Quilt.iter_window_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Quilt.iter_window_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Quilt.iter_window_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Quilt.iter_window_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Quilt.iter_window_items()": "Iterator of pairs of label, windowed values, where values are given as a Frame....", "Quilt.iter_window_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Quilt.iter_window_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Quilt.iter_window_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Quilt.iter_window_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Quilt.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "Quilt.via_hashlib().md5()": "", "Quilt.via_hashlib().sha256()": "", "Quilt.via_hashlib().sha512()": "", "Quilt.via_hashlib().sha3_256()": "", "Quilt.via_hashlib().sha3_512()": "", "Quilt.via_hashlib().shake_128()": "", "Quilt.via_hashlib().shake_256()": "", "Quilt.via_hashlib().blake2b()": "", "Quilt.via_hashlib().blake2s()": "", "Index.__init__()": "Initializer. Args: labels: An iterable of unique, hashable values, or another In...", "Index.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "Index.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "Index.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "Index.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "Index.to_pandas()": "Return a Pandas Index.", "Index.to_series()": "Return a Series with values from this Index's labels.", "Index.to_visidata()": "Open an interactive VisiData session.", "Index.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "Index.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "Index.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "Index.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "Index.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "Index.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "Index.name": "A hashable label attached to this container. Returns: Hashable", "Index.names": "Provide a suitable iterable of names for usage in output formats that require a...", "Index.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "Index.ndim": "Return the number of dimensions. Returns: int", "Index.positions": "Return the immutable positions array.", "Index.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "Index.size": "Return the size of the underlying NumPy array. Returns: int", "Index.__array__()": "Support the __array__ interface, returning an array of values.", "Index.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "Index.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "Index.__copy__()": "Return shallow copy of this Index.", "Index.__deepcopy__()": "", "Index.__len__()": "", "Index.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "Index.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "Index.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "Index.copy()": "Return shallow copy of this Index.", "Index.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "Index.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "Index.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "Index.dropfalsy()": "Return a new Index after removing values of NaN or None.", "Index.dropna()": "Return a new Index after removing values of NaN or None.", "Index.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "Index.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "Index.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "Index.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "Index.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "Index.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "Index.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "Index.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "Index.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "Index.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "Index.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "Index.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "Index.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "Index.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "Index.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "Index.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "Index.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "Index.rename()": "Return a new Frame with an updated name attribute.", "Index.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "Index.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "Index.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "Index.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "Index.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "Index.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "Index.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "Index.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "Index.values_at_depth()": "Return an NP array for the depth_level specified.", "Index.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "Index.__contains__()": "Return True if value in the labels.", "Index.__iter__()": "Iterate over labels.", "Index.__reversed__()": "Returns a reverse iterator on the index labels.", "Index.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "Index.interface": "A Frame documenting the interface of this class.", "Index.__repr__()": "", "Index.__str__()": "Return str(self).", "Index.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "Index.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "Index.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "Index.drop.iloc[]": "", "Index.drop.loc[]": "", "Index.[]": "Extract a new index given an iloc key.", "Index.iloc[]": "", "Index.loc[]": "", "Index.iter_label()": "", "Index.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "Index.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "Index.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "Index.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "Index.__add__()": "", "Index.__and__()": "", "Index.__eq__()": "", "Index.__floordiv__()": "", "Index.__ge__()": "", "Index.__gt__()": "", "Index.__le__()": "", "Index.__lt__()": "", "Index.__matmul__()": "", "Index.__mod__()": "", "Index.__mul__()": "", "Index.__ne__()": "", "Index.__or__()": "", "Index.__pow__()": "", "Index.__radd__()": "", "Index.__rfloordiv__()": "", "Index.__rmatmul__()": "", "Index.__rmul__()": "", "Index.__rshift__()": "", "Index.__rsub__()": "", "Index.__rtruediv__()": "", "Index.__sub__()": "", "Index.__truediv__()": "", "Index.__xor__()": "", "Index.__abs__()": "", "Index.__invert__()": "", "Index.__neg__()": "", "Index.__pos__()": "", "Index.via_values.apply()": "", "Index.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "Index.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "Index.via_dt.year": "Return the year of each element.", "Index.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "Index.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "Index.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "Index.via_dt.hour": "Return the hour of each element, between 0 and 24.", "Index.via_dt.minute": "Return the minute of each element, between 0 and 60.", "Index.via_dt.second": "Return the second of each element, between 0 and 60.", "Index.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "Index.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "Index.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "Index.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "Index.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "Index.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "Index.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "Index.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "Index.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "Index.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "Index.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "Index.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "Index.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "Index.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "Index.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "Index.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "Index.via_str.center()": "Return a container with its elements centered in a string of length width.", "Index.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "Index.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "Index.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "Index.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "Index.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "Index.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "Index.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "Index.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "Index.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "Index.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "Index.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "Index.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "Index.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "Index.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "Index.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "Index.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "Index.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "Index.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "Index.via_str.len()": "Return the length of the string.", "Index.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "Index.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "Index.via_str.partition()": "Partition each element around sep.", "Index.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "Index.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "Index.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "Index.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "Index.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "Index.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "Index.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "Index.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "Index.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "Index.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "Index.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "Index.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "Index.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "Index.via_str.zfill()": "Return the string left-filled with zeros.", "Index.via_re().search()": "Scan through string looking for the first location where this regular expression...", "Index.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "Index.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "Index.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "Index.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "Index.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "Index.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "Index.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "Index.via_hashlib().md5()": "", "Index.via_hashlib().sha256()": "", "Index.via_hashlib().sha512()": "", "Index.via_hashlib().sha3_256()": "", "Index.via_hashlib().sha3_512()": "", "Index.via_hashlib().shake_128()": "", "Index.via_hashlib().shake_256()": "", "Index.via_hashlib().blake2b()": "", "Index.via_hashlib().blake2s()": "", "IndexGO.__init__()": "Initializer. Args: labels: An iterable of unique, hashable values, or another In...", "IndexGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexGO.to_pandas()": "Return a Pandas Index.", "IndexGO.to_series()": "Return a Series with values from this Index's labels.", "IndexGO.to_visidata()": "Open an interactive VisiData session.", "IndexGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexGO.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexGO.ndim": "Return the number of dimensions. Returns: int", "IndexGO.positions": "Return the immutable positions array.", "IndexGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexGO.__copy__()": "Return shallow copy of this Index.", "IndexGO.__deepcopy__()": "", "IndexGO.__len__()": "", "IndexGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexGO.append()": "append a value", "IndexGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexGO.copy()": "Return shallow copy of this Index.", "IndexGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexGO.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexGO.rename()": "Return a new Frame with an updated name attribute.", "IndexGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexGO.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexGO.__contains__()": "Return True if value in the labels.", "IndexGO.__iter__()": "Iterate over labels.", "IndexGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexGO.interface": "A Frame documenting the interface of this class.", "IndexGO.__repr__()": "", "IndexGO.__str__()": "Return str(self).", "IndexGO.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexGO.drop.iloc[]": "", "IndexGO.drop.loc[]": "", "IndexGO.[]": "Extract a new index given an iloc key.", "IndexGO.iloc[]": "", "IndexGO.loc[]": "", "IndexGO.iter_label()": "", "IndexGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexGO.__add__()": "", "IndexGO.__and__()": "", "IndexGO.__eq__()": "", "IndexGO.__floordiv__()": "", "IndexGO.__ge__()": "", "IndexGO.__gt__()": "", "IndexGO.__le__()": "", "IndexGO.__lt__()": "", "IndexGO.__matmul__()": "", "IndexGO.__mod__()": "", "IndexGO.__mul__()": "", "IndexGO.__ne__()": "", "IndexGO.__or__()": "", "IndexGO.__pow__()": "", "IndexGO.__radd__()": "", "IndexGO.__rfloordiv__()": "", "IndexGO.__rmatmul__()": "", "IndexGO.__rmul__()": "", "IndexGO.__rshift__()": "", "IndexGO.__rsub__()": "", "IndexGO.__rtruediv__()": "", "IndexGO.__sub__()": "", "IndexGO.__truediv__()": "", "IndexGO.__xor__()": "", "IndexGO.__abs__()": "", "IndexGO.__invert__()": "", "IndexGO.__neg__()": "", "IndexGO.__pos__()": "", "IndexGO.via_values.apply()": "", "IndexGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexGO.via_dt.year": "Return the year of each element.", "IndexGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexGO.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexGO.via_str.len()": "Return the length of the string.", "IndexGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexGO.via_str.partition()": "Partition each element around sep.", "IndexGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexGO.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexGO.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexGO.via_hashlib().md5()": "", "IndexGO.via_hashlib().sha256()": "", "IndexGO.via_hashlib().sha512()": "", "IndexGO.via_hashlib().sha3_256()": "", "IndexGO.via_hashlib().sha3_512()": "", "IndexGO.via_hashlib().shake_128()": "", "IndexGO.via_hashlib().shake_256()": "", "IndexGO.via_hashlib().blake2b()": "", "IndexGO.via_hashlib().blake2s()": "", "IndexHierarchy.__init__()": "Initializer. Args: indices: list of Index objects indexers: a 2D indexer array n...", "IndexHierarchy.from_index_items()": "Given an iterable of pairs of label, IndexBase, produce an IndexHierarchy where...", "IndexHierarchy.from_labels()": "Construct an IndexHierarchy from an iterable of labels, where each label is tupl...", "IndexHierarchy.from_labels_delimited()": "Construct an IndexHierarchy from an iterable of labels, where each label is stri...", "IndexHierarchy.from_names()": "Construct a zero-length IndexHierarchy from an iterable of names, where the leng...", "IndexHierarchy.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexHierarchy.from_product()": "Given groups of iterables, return an IndexHierarchy made of the product of a val...", "IndexHierarchy.from_tree()": "Convert into a IndexHierarchy a dictionary defining keys to either iterables or...", "IndexHierarchy.from_values_per_depth()": "Construct an IndexHierarchy from a 2D NumPy array, or a collection of 1D arrays...", "IndexHierarchy.to_frame()": "Return Frame version of this IndexHierarchy.", "IndexHierarchy.to_frame_go()": "Return a FrameGO version of this IndexHierarchy.", "IndexHierarchy.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexHierarchy.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexHierarchy.to_pandas()": "Return a Pandas MultiIndex.", "IndexHierarchy.to_tree()": "Returns the tree representation of an IndexHierarchy", "IndexHierarchy.to_visidata()": "Open an interactive VisiData session.", "IndexHierarchy.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexHierarchy.depth": "Return the depth of the index hierarchy.", "IndexHierarchy.dtypes": "Return a Series of dytpes for each index depth. Returns: Series", "IndexHierarchy.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexHierarchy.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexHierarchy.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexHierarchy.name": "A hashable label attached to this container. Returns: Hashable", "IndexHierarchy.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexHierarchy.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexHierarchy.ndim": "Return the number of dimensions. Returns: int", "IndexHierarchy.positions": "Return the immutable positions array.", "IndexHierarchy.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexHierarchy.size": "Return the size of the underlying NumPy array. Returns: int", "IndexHierarchy.__array__()": "Support the __array__ interface, returning an array of values.", "IndexHierarchy.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexHierarchy.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexHierarchy.__copy__()": "Return a shallow copy of this IndexHierarchy.", "IndexHierarchy.__deepcopy__()": "Return a deep copy of this IndexHierarchy.", "IndexHierarchy.__len__()": "", "IndexHierarchy.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexHierarchy.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexHierarchy.astype[]()": "Selector of columns by label. Args: key: A loc selector, either a label, a list...", "IndexHierarchy.astype()": "Apply a single dtype to all columns.", "IndexHierarchy.copy()": "Return a shallow copy of this IndexHierarchy.", "IndexHierarchy.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexHierarchy.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexHierarchy.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexHierarchy.dropfalsy()": "Return a new obj:IndexHierarchy after removing labels where any or all values ar...", "IndexHierarchy.dropna()": "Return a new obj:IndexHierarchy after removing labels where any or all values ar...", "IndexHierarchy.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexHierarchy.fillfalsy()": "Return an IndexHierarchy after replacing falsy values with the supplied value. A...", "IndexHierarchy.fillna()": "Return an IndexHierarchy after replacing NA (NaN or None) with the supplied valu...", "IndexHierarchy.flat()": "Return a flat, one-dimensional index of tuples for each level.", "IndexHierarchy.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexHierarchy.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexHierarchy.index_at_depth()": "Return an index, or a tuple of indices for the depth_level specified. Args: dept...", "IndexHierarchy.indexer_at_depth()": "Return the indexers for the depth_level specified. Array will 2D if multiple dep...", "IndexHierarchy.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexHierarchy.isin()": "Return a Boolean array showing True where one or more of the passed in iterable...", "IndexHierarchy.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexHierarchy.level_add()": "Return an IndexHierarchy with a new root (outer) level added.", "IndexHierarchy.level_drop()": "Return an IndexHierarchy with one or more leaf levels removed. Args: count: A po...", "IndexHierarchy.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexHierarchy.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, an HLo...", "IndexHierarchy.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexHierarchy.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexHierarchy.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexHierarchy.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexHierarchy.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexHierarchy.rehierarch()": "Return a new IndexHierarchy that conforms to the new depth assignments given be...", "IndexHierarchy.relabel()": "Return a new IndexHierarchy with labels replaced by the callable or mapping; ord...", "IndexHierarchy.relabel_at_depth()": "Return a new IndexHierarchy after applying mapper to a level or each individual...", "IndexHierarchy.rename()": "Return a new IndexHierarchy with an updated name attribute.", "IndexHierarchy.roll()": "Return an IndexHierarchy with values rotated forward and wrapped around (with a...", "IndexHierarchy.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexHierarchy.sort()": "Return a new Index with the labels sorted. Args: ascendings: Boolean, or iterabl...", "IndexHierarchy.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexHierarchy.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexHierarchy.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexHierarchy.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexHierarchy.unique()": "Return a NumPy array of unique values. Args: depth_level: Specify a single depth...", "IndexHierarchy.values_at_depth()": "Return an NP array for the depth_level specified. Args: depth_level: a single de...", "IndexHierarchy.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexHierarchy.__contains__()": "Determine if a label value is contained in this Index.", "IndexHierarchy.__iter__()": "Iterate over labels.", "IndexHierarchy.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexHierarchy.values": "A 2D NumPy array of all values in the IndexHierarchy. As this is a single array,...", "IndexHierarchy.interface": "A Frame documenting the interface of this class.", "IndexHierarchy.__repr__()": "", "IndexHierarchy.__str__()": "Return str(self).", "IndexHierarchy.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexHierarchy.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexHierarchy.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexHierarchy.[]": "Extract a new index given a key.", "IndexHierarchy.iloc[]": "", "IndexHierarchy.loc[]": "", "IndexHierarchy.iter_label()": "", "IndexHierarchy.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexHierarchy.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexHierarchy.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexHierarchy.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexHierarchy.__add__()": "", "IndexHierarchy.__and__()": "", "IndexHierarchy.__eq__()": "", "IndexHierarchy.__floordiv__()": "", "IndexHierarchy.__ge__()": "", "IndexHierarchy.__gt__()": "", "IndexHierarchy.__le__()": "", "IndexHierarchy.__lt__()": "", "IndexHierarchy.__matmul__()": "", "IndexHierarchy.__mod__()": "", "IndexHierarchy.__mul__()": "", "IndexHierarchy.__ne__()": "", "IndexHierarchy.__or__()": "", "IndexHierarchy.__pow__()": "", "IndexHierarchy.__radd__()": "", "IndexHierarchy.__rfloordiv__()": "", "IndexHierarchy.__rmatmul__()": "", "IndexHierarchy.__rmul__()": "", "IndexHierarchy.__rshift__()": "", "IndexHierarchy.__rsub__()": "", "IndexHierarchy.__rtruediv__()": "", "IndexHierarchy.__sub__()": "", "IndexHierarchy.__truediv__()": "", "IndexHierarchy.__xor__()": "", "IndexHierarchy.__abs__()": "", "IndexHierarchy.__invert__()": "", "IndexHierarchy.__neg__()": "", "IndexHierarchy.__pos__()": "", "IndexHierarchy.via_values.apply()": "", "IndexHierarchy.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexHierarchy.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexHierarchy.via_dt.year": "Return the year of each element.", "IndexHierarchy.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexHierarchy.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexHierarchy.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexHierarchy.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexHierarchy.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexHierarchy.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexHierarchy.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexHierarchy.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexHierarchy.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexHierarchy.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexHierarchy.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexHierarchy.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexHierarchy.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexHierarchy.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexHierarchy.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexHierarchy.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexHierarchy.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexHierarchy.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexHierarchy.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexHierarchy.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexHierarchy.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexHierarchy.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexHierarchy.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexHierarchy.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexHierarchy.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexHierarchy.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexHierarchy.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexHierarchy.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexHierarchy.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexHierarchy.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexHierarchy.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexHierarchy.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexHierarchy.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexHierarchy.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexHierarchy.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexHierarchy.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexHierarchy.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexHierarchy.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexHierarchy.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexHierarchy.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexHierarchy.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexHierarchy.via_str.len()": "Return the length of the string.", "IndexHierarchy.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexHierarchy.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexHierarchy.via_str.partition()": "Partition each element around sep.", "IndexHierarchy.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexHierarchy.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexHierarchy.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexHierarchy.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexHierarchy.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexHierarchy.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexHierarchy.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexHierarchy.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexHierarchy.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexHierarchy.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexHierarchy.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexHierarchy.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexHierarchy.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexHierarchy.via_str.zfill()": "Return the string left-filled with zeros.", "IndexHierarchy.via_T.via_fill_value()": "Interface for using binary operators and methods with a pre-defined fill value.", "IndexHierarchy.via_T.__add__()": "", "IndexHierarchy.via_T.__sub__()": "", "IndexHierarchy.via_T.__mul__()": "", "IndexHierarchy.via_T.__truediv__()": "", "IndexHierarchy.via_T.__floordiv__()": "", "IndexHierarchy.via_T.__mod__()": "", "IndexHierarchy.via_T.__pow__()": "", "IndexHierarchy.via_T.__lshift__()": "", "IndexHierarchy.via_T.__rshift__()": "", "IndexHierarchy.via_T.__and__()": "", "IndexHierarchy.via_T.__xor__()": "", "IndexHierarchy.via_T.__or__()": "", "IndexHierarchy.via_T.__lt__()": "", "IndexHierarchy.via_T.__le__()": "", "IndexHierarchy.via_T.__eq__()": "", "IndexHierarchy.via_T.__ne__()": "", "IndexHierarchy.via_T.__gt__()": "", "IndexHierarchy.via_T.__ge__()": "", "IndexHierarchy.via_T.__radd__()": "", "IndexHierarchy.via_T.__rsub__()": "", "IndexHierarchy.via_T.__rmul__()": "", "IndexHierarchy.via_T.__rtruediv__()": "", "IndexHierarchy.via_T.__rfloordiv__()": "", "IndexHierarchy.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexHierarchy.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexHierarchy.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexHierarchy.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexHierarchy.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexHierarchy.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexHierarchy.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexHierarchy.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexHierarchy.via_hashlib().md5()": "", "IndexHierarchy.via_hashlib().sha256()": "", "IndexHierarchy.via_hashlib().sha512()": "", "IndexHierarchy.via_hashlib().sha3_256()": "", "IndexHierarchy.via_hashlib().sha3_512()": "", "IndexHierarchy.via_hashlib().shake_128()": "", "IndexHierarchy.via_hashlib().shake_256()": "", "IndexHierarchy.via_hashlib().blake2b()": "", "IndexHierarchy.via_hashlib().blake2s()": "", "IndexHierarchyGO.__init__()": "Initializer. Args: indices: list of Index objects indexers: a 2D indexer array n...", "IndexHierarchyGO.from_index_items()": "Given an iterable of pairs of label, IndexBase, produce an IndexHierarchy where...", "IndexHierarchyGO.from_labels()": "Construct an IndexHierarchy from an iterable of labels, where each label is tupl...", "IndexHierarchyGO.from_labels_delimited()": "Construct an IndexHierarchy from an iterable of labels, where each label is stri...", "IndexHierarchyGO.from_names()": "Construct a zero-length IndexHierarchy from an iterable of names, where the leng...", "IndexHierarchyGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexHierarchyGO.from_product()": "Given groups of iterables, return an IndexHierarchy made of the product of a val...", "IndexHierarchyGO.from_tree()": "Convert into a IndexHierarchy a dictionary defining keys to either iterables or...", "IndexHierarchyGO.from_values_per_depth()": "Construct an IndexHierarchy from a 2D NumPy array, or a collection of 1D arrays...", "IndexHierarchyGO.to_frame()": "Return Frame version of this IndexHierarchy.", "IndexHierarchyGO.to_frame_go()": "Return a FrameGO version of this IndexHierarchy.", "IndexHierarchyGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexHierarchyGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexHierarchyGO.to_pandas()": "Return a Pandas MultiIndex.", "IndexHierarchyGO.to_tree()": "Returns the tree representation of an IndexHierarchy", "IndexHierarchyGO.to_visidata()": "Open an interactive VisiData session.", "IndexHierarchyGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexHierarchyGO.depth": "Return the depth of the index hierarchy.", "IndexHierarchyGO.dtypes": "Return a Series of dytpes for each index depth. Returns: Series", "IndexHierarchyGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexHierarchyGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexHierarchyGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexHierarchyGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexHierarchyGO.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexHierarchyGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexHierarchyGO.ndim": "Return the number of dimensions. Returns: int", "IndexHierarchyGO.positions": "Return the immutable positions array.", "IndexHierarchyGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexHierarchyGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexHierarchyGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexHierarchyGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexHierarchyGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexHierarchyGO.__copy__()": "Return a shallow copy of this IndexHierarchy.", "IndexHierarchyGO.__deepcopy__()": "Return a deep copy of this IndexHierarchy.", "IndexHierarchyGO.__len__()": "", "IndexHierarchyGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexHierarchyGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexHierarchyGO.append()": "Append a single label to this IndexHierarchyGO in-place", "IndexHierarchyGO.astype[]()": "Selector of columns by label. Args: key: A loc selector, either a label, a list...", "IndexHierarchyGO.astype()": "Apply a single dtype to all columns.", "IndexHierarchyGO.copy()": "Return a shallow copy of this IndexHierarchy.", "IndexHierarchyGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexHierarchyGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexHierarchyGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexHierarchyGO.dropfalsy()": "Return a new obj:IndexHierarchy after removing labels where any or all values ar...", "IndexHierarchyGO.dropna()": "Return a new obj:IndexHierarchy after removing labels where any or all values ar...", "IndexHierarchyGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexHierarchyGO.extend()": "Extend this IndexHierarchyGO in-place", "IndexHierarchyGO.fillfalsy()": "Return an IndexHierarchy after replacing falsy values with the supplied value. A...", "IndexHierarchyGO.fillna()": "Return an IndexHierarchy after replacing NA (NaN or None) with the supplied valu...", "IndexHierarchyGO.flat()": "Return a flat, one-dimensional index of tuples for each level.", "IndexHierarchyGO.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexHierarchyGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexHierarchyGO.index_at_depth()": "Return an index, or a tuple of indices for the depth_level specified. Args: dept...", "IndexHierarchyGO.indexer_at_depth()": "Return the indexers for the depth_level specified. Array will 2D if multiple dep...", "IndexHierarchyGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexHierarchyGO.isin()": "Return a Boolean array showing True where one or more of the passed in iterable...", "IndexHierarchyGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexHierarchyGO.level_add()": "Return an IndexHierarchy with a new root (outer) level added.", "IndexHierarchyGO.level_drop()": "Return an IndexHierarchy with one or more leaf levels removed. Args: count: A po...", "IndexHierarchyGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexHierarchyGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, an HLo...", "IndexHierarchyGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexHierarchyGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexHierarchyGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexHierarchyGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexHierarchyGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexHierarchyGO.rehierarch()": "Return a new IndexHierarchy that conforms to the new depth assignments given be...", "IndexHierarchyGO.relabel()": "Return a new IndexHierarchy with labels replaced by the callable or mapping; ord...", "IndexHierarchyGO.relabel_at_depth()": "Return a new IndexHierarchy after applying mapper to a level or each individual...", "IndexHierarchyGO.rename()": "Return a new IndexHierarchy with an updated name attribute.", "IndexHierarchyGO.roll()": "Return an IndexHierarchy with values rotated forward and wrapped around (with a...", "IndexHierarchyGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexHierarchyGO.sort()": "Return a new Index with the labels sorted. Args: ascendings: Boolean, or iterabl...", "IndexHierarchyGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexHierarchyGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexHierarchyGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexHierarchyGO.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexHierarchyGO.unique()": "Return a NumPy array of unique values. Args: depth_level: Specify a single depth...", "IndexHierarchyGO.values_at_depth()": "Return an NP array for the depth_level specified. Args: depth_level: a single de...", "IndexHierarchyGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexHierarchyGO.__contains__()": "Determine if a label value is contained in this Index.", "IndexHierarchyGO.__iter__()": "Iterate over labels.", "IndexHierarchyGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexHierarchyGO.values": "A 2D NumPy array of all values in the IndexHierarchy. As this is a single array,...", "IndexHierarchyGO.interface": "A Frame documenting the interface of this class.", "IndexHierarchyGO.__repr__()": "", "IndexHierarchyGO.__str__()": "Return str(self).", "IndexHierarchyGO.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexHierarchyGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexHierarchyGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexHierarchyGO.[]": "Extract a new index given a key.", "IndexHierarchyGO.iloc[]": "", "IndexHierarchyGO.loc[]": "", "IndexHierarchyGO.iter_label()": "", "IndexHierarchyGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexHierarchyGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexHierarchyGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexHierarchyGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexHierarchyGO.__add__()": "", "IndexHierarchyGO.__and__()": "", "IndexHierarchyGO.__eq__()": "", "IndexHierarchyGO.__floordiv__()": "", "IndexHierarchyGO.__ge__()": "", "IndexHierarchyGO.__gt__()": "", "IndexHierarchyGO.__le__()": "", "IndexHierarchyGO.__lt__()": "", "IndexHierarchyGO.__matmul__()": "", "IndexHierarchyGO.__mod__()": "", "IndexHierarchyGO.__mul__()": "", "IndexHierarchyGO.__ne__()": "", "IndexHierarchyGO.__or__()": "", "IndexHierarchyGO.__pow__()": "", "IndexHierarchyGO.__radd__()": "", "IndexHierarchyGO.__rfloordiv__()": "", "IndexHierarchyGO.__rmatmul__()": "", "IndexHierarchyGO.__rmul__()": "", "IndexHierarchyGO.__rshift__()": "", "IndexHierarchyGO.__rsub__()": "", "IndexHierarchyGO.__rtruediv__()": "", "IndexHierarchyGO.__sub__()": "", "IndexHierarchyGO.__truediv__()": "", "IndexHierarchyGO.__xor__()": "", "IndexHierarchyGO.__abs__()": "", "IndexHierarchyGO.__invert__()": "", "IndexHierarchyGO.__neg__()": "", "IndexHierarchyGO.__pos__()": "", "IndexHierarchyGO.via_values.apply()": "", "IndexHierarchyGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexHierarchyGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexHierarchyGO.via_dt.year": "Return the year of each element.", "IndexHierarchyGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexHierarchyGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexHierarchyGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexHierarchyGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexHierarchyGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexHierarchyGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexHierarchyGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexHierarchyGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexHierarchyGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexHierarchyGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexHierarchyGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexHierarchyGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexHierarchyGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexHierarchyGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexHierarchyGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexHierarchyGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexHierarchyGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexHierarchyGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexHierarchyGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexHierarchyGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexHierarchyGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexHierarchyGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexHierarchyGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexHierarchyGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexHierarchyGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexHierarchyGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexHierarchyGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexHierarchyGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexHierarchyGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexHierarchyGO.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexHierarchyGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexHierarchyGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexHierarchyGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexHierarchyGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexHierarchyGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexHierarchyGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexHierarchyGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexHierarchyGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexHierarchyGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexHierarchyGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexHierarchyGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexHierarchyGO.via_str.len()": "Return the length of the string.", "IndexHierarchyGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexHierarchyGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexHierarchyGO.via_str.partition()": "Partition each element around sep.", "IndexHierarchyGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexHierarchyGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexHierarchyGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexHierarchyGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexHierarchyGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexHierarchyGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexHierarchyGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexHierarchyGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexHierarchyGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexHierarchyGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexHierarchyGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexHierarchyGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexHierarchyGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexHierarchyGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexHierarchyGO.via_T.via_fill_value()": "Interface for using binary operators and methods with a pre-defined fill value.", "IndexHierarchyGO.via_T.__add__()": "", "IndexHierarchyGO.via_T.__sub__()": "", "IndexHierarchyGO.via_T.__mul__()": "", "IndexHierarchyGO.via_T.__truediv__()": "", "IndexHierarchyGO.via_T.__floordiv__()": "", "IndexHierarchyGO.via_T.__mod__()": "", "IndexHierarchyGO.via_T.__pow__()": "", "IndexHierarchyGO.via_T.__lshift__()": "", "IndexHierarchyGO.via_T.__rshift__()": "", "IndexHierarchyGO.via_T.__and__()": "", "IndexHierarchyGO.via_T.__xor__()": "", "IndexHierarchyGO.via_T.__or__()": "", "IndexHierarchyGO.via_T.__lt__()": "", "IndexHierarchyGO.via_T.__le__()": "", "IndexHierarchyGO.via_T.__eq__()": "", "IndexHierarchyGO.via_T.__ne__()": "", "IndexHierarchyGO.via_T.__gt__()": "", "IndexHierarchyGO.via_T.__ge__()": "", "IndexHierarchyGO.via_T.__radd__()": "", "IndexHierarchyGO.via_T.__rsub__()": "", "IndexHierarchyGO.via_T.__rmul__()": "", "IndexHierarchyGO.via_T.__rtruediv__()": "", "IndexHierarchyGO.via_T.__rfloordiv__()": "", "IndexHierarchyGO.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexHierarchyGO.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexHierarchyGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexHierarchyGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexHierarchyGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexHierarchyGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexHierarchyGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexHierarchyGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexHierarchyGO.via_hashlib().md5()": "", "IndexHierarchyGO.via_hashlib().sha256()": "", "IndexHierarchyGO.via_hashlib().sha512()": "", "IndexHierarchyGO.via_hashlib().sha3_256()": "", "IndexHierarchyGO.via_hashlib().sha3_512()": "", "IndexHierarchyGO.via_hashlib().shake_128()": "", "IndexHierarchyGO.via_hashlib().shake_256()": "", "IndexHierarchyGO.via_hashlib().blake2b()": "", "IndexHierarchyGO.via_hashlib().blake2s()": "", "IndexYear.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexYear.from_date_range()": "Get an IndexYearMonth instance over a range of dates, where start and stop are i...", "IndexYear.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexYear.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexYear.from_year_month_range()": "Get an IndexYearMonth instance over a range of months, where start and end are i...", "IndexYear.from_year_range()": "Get an IndexDate instance over a range of years, where start and end are inclusi...", "IndexYear.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexYear.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexYear.to_pandas()": "Return a Pandas Index.", "IndexYear.to_series()": "Return a Series with values from this Index's labels.", "IndexYear.to_visidata()": "Open an interactive VisiData session.", "IndexYear.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexYear.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexYear.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexYear.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexYear.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexYear.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexYear.name": "A hashable label attached to this container. Returns: Hashable", "IndexYear.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexYear.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexYear.ndim": "Return the number of dimensions. Returns: int", "IndexYear.positions": "Return the immutable positions array.", "IndexYear.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexYear.size": "Return the size of the underlying NumPy array. Returns: int", "IndexYear.__array__()": "Support the __array__ interface, returning an array of values.", "IndexYear.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexYear.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexYear.__copy__()": "Return shallow copy of this Index.", "IndexYear.__deepcopy__()": "", "IndexYear.__len__()": "", "IndexYear.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexYear.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexYear.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexYear.copy()": "Return shallow copy of this Index.", "IndexYear.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexYear.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexYear.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexYear.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexYear.dropna()": "Return a new Index after removing values of NaN or None.", "IndexYear.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexYear.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexYear.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexYear.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexYear.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexYear.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexYear.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexYear.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexYear.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexYear.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexYear.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexYear.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexYear.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexYear.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexYear.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexYear.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexYear.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexYear.rename()": "Return a new Frame with an updated name attribute.", "IndexYear.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexYear.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexYear.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexYear.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexYear.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexYear.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexYear.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexYear.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexYear.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexYear.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexYear.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexYear.__iter__()": "Iterate over labels.", "IndexYear.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexYear.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexYear.interface": "A Frame documenting the interface of this class.", "IndexYear.__repr__()": "", "IndexYear.__str__()": "Return str(self).", "IndexYear.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexYear.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexYear.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexYear.drop.iloc[]": "", "IndexYear.drop.loc[]": "", "IndexYear.[]": "Extract a new index given an iloc key.", "IndexYear.iloc[]": "", "IndexYear.loc[]": "", "IndexYear.iter_label()": "", "IndexYear.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexYear.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexYear.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexYear.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexYear.__add__()": "", "IndexYear.__and__()": "", "IndexYear.__eq__()": "", "IndexYear.__floordiv__()": "", "IndexYear.__ge__()": "", "IndexYear.__gt__()": "", "IndexYear.__le__()": "", "IndexYear.__lt__()": "", "IndexYear.__matmul__()": "", "IndexYear.__mod__()": "", "IndexYear.__mul__()": "", "IndexYear.__ne__()": "", "IndexYear.__or__()": "", "IndexYear.__pow__()": "", "IndexYear.__radd__()": "", "IndexYear.__rfloordiv__()": "", "IndexYear.__rmatmul__()": "", "IndexYear.__rmul__()": "", "IndexYear.__rshift__()": "", "IndexYear.__rsub__()": "", "IndexYear.__rtruediv__()": "", "IndexYear.__sub__()": "", "IndexYear.__truediv__()": "", "IndexYear.__xor__()": "", "IndexYear.__abs__()": "", "IndexYear.__invert__()": "", "IndexYear.__neg__()": "", "IndexYear.__pos__()": "", "IndexYear.via_values.apply()": "", "IndexYear.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexYear.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexYear.via_dt.year": "Return the year of each element.", "IndexYear.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexYear.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexYear.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexYear.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexYear.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexYear.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexYear.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexYear.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexYear.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexYear.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexYear.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexYear.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexYear.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexYear.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexYear.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexYear.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexYear.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexYear.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexYear.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexYear.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexYear.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexYear.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexYear.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexYear.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexYear.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexYear.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexYear.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexYear.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexYear.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexYear.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexYear.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexYear.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexYear.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexYear.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexYear.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexYear.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexYear.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexYear.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexYear.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexYear.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexYear.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexYear.via_str.len()": "Return the length of the string.", "IndexYear.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexYear.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexYear.via_str.partition()": "Partition each element around sep.", "IndexYear.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexYear.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexYear.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexYear.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexYear.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexYear.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexYear.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexYear.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexYear.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexYear.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexYear.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexYear.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexYear.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexYear.via_str.zfill()": "Return the string left-filled with zeros.", "IndexYear.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexYear.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexYear.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexYear.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexYear.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexYear.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexYear.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexYear.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexYear.via_hashlib().md5()": "", "IndexYear.via_hashlib().sha256()": "", "IndexYear.via_hashlib().sha512()": "", "IndexYear.via_hashlib().sha3_256()": "", "IndexYear.via_hashlib().sha3_512()": "", "IndexYear.via_hashlib().shake_128()": "", "IndexYear.via_hashlib().shake_256()": "", "IndexYear.via_hashlib().blake2b()": "", "IndexYear.via_hashlib().blake2s()": "", "IndexYearGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexYearGO.from_date_range()": "Get an IndexYearMonth instance over a range of dates, where start and stop are i...", "IndexYearGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexYearGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexYearGO.from_year_month_range()": "Get an IndexYearMonth instance over a range of months, where start and end are i...", "IndexYearGO.from_year_range()": "Get an IndexDate instance over a range of years, where start and end are inclusi...", "IndexYearGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexYearGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexYearGO.to_pandas()": "Return a Pandas Index.", "IndexYearGO.to_series()": "Return a Series with values from this Index's labels.", "IndexYearGO.to_visidata()": "Open an interactive VisiData session.", "IndexYearGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexYearGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexYearGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexYearGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexYearGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexYearGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexYearGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexYearGO.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexYearGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexYearGO.ndim": "Return the number of dimensions. Returns: int", "IndexYearGO.positions": "Return the immutable positions array.", "IndexYearGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexYearGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexYearGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexYearGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexYearGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexYearGO.__copy__()": "Return shallow copy of this Index.", "IndexYearGO.__deepcopy__()": "", "IndexYearGO.__len__()": "", "IndexYearGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexYearGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexYearGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resol...", "IndexYearGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexYearGO.copy()": "Return shallow copy of this Index.", "IndexYearGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexYearGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexYearGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexYearGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexYearGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexYearGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexYearGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexYearGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexYearGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexYearGO.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexYearGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexYearGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexYearGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexYearGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexYearGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexYearGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexYearGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexYearGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexYearGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexYearGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexYearGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexYearGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexYearGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexYearGO.rename()": "Return a new Frame with an updated name attribute.", "IndexYearGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexYearGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexYearGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexYearGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexYearGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexYearGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexYearGO.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexYearGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexYearGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexYearGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexYearGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexYearGO.__iter__()": "Iterate over labels.", "IndexYearGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexYearGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexYearGO.interface": "A Frame documenting the interface of this class.", "IndexYearGO.__repr__()": "", "IndexYearGO.__str__()": "Return str(self).", "IndexYearGO.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexYearGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexYearGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexYearGO.drop.iloc[]": "", "IndexYearGO.drop.loc[]": "", "IndexYearGO.[]": "Extract a new index given an iloc key.", "IndexYearGO.iloc[]": "", "IndexYearGO.loc[]": "", "IndexYearGO.iter_label()": "", "IndexYearGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexYearGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexYearGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexYearGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexYearGO.__add__()": "", "IndexYearGO.__and__()": "", "IndexYearGO.__eq__()": "", "IndexYearGO.__floordiv__()": "", "IndexYearGO.__ge__()": "", "IndexYearGO.__gt__()": "", "IndexYearGO.__le__()": "", "IndexYearGO.__lt__()": "", "IndexYearGO.__matmul__()": "", "IndexYearGO.__mod__()": "", "IndexYearGO.__mul__()": "", "IndexYearGO.__ne__()": "", "IndexYearGO.__or__()": "", "IndexYearGO.__pow__()": "", "IndexYearGO.__radd__()": "", "IndexYearGO.__rfloordiv__()": "", "IndexYearGO.__rmatmul__()": "", "IndexYearGO.__rmul__()": "", "IndexYearGO.__rshift__()": "", "IndexYearGO.__rsub__()": "", "IndexYearGO.__rtruediv__()": "", "IndexYearGO.__sub__()": "", "IndexYearGO.__truediv__()": "", "IndexYearGO.__xor__()": "", "IndexYearGO.__abs__()": "", "IndexYearGO.__invert__()": "", "IndexYearGO.__neg__()": "", "IndexYearGO.__pos__()": "", "IndexYearGO.via_values.apply()": "", "IndexYearGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexYearGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexYearGO.via_dt.year": "Return the year of each element.", "IndexYearGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexYearGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexYearGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexYearGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexYearGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexYearGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexYearGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexYearGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexYearGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexYearGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexYearGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexYearGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexYearGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexYearGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexYearGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexYearGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexYearGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexYearGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexYearGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexYearGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexYearGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexYearGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexYearGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexYearGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexYearGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexYearGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexYearGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexYearGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexYearGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexYearGO.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexYearGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexYearGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexYearGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexYearGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexYearGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexYearGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexYearGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexYearGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexYearGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexYearGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexYearGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexYearGO.via_str.len()": "Return the length of the string.", "IndexYearGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexYearGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexYearGO.via_str.partition()": "Partition each element around sep.", "IndexYearGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexYearGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexYearGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexYearGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexYearGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexYearGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexYearGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexYearGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexYearGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexYearGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexYearGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexYearGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexYearGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexYearGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexYearGO.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexYearGO.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexYearGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexYearGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexYearGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexYearGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexYearGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexYearGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexYearGO.via_hashlib().md5()": "", "IndexYearGO.via_hashlib().sha256()": "", "IndexYearGO.via_hashlib().sha512()": "", "IndexYearGO.via_hashlib().sha3_256()": "", "IndexYearGO.via_hashlib().sha3_512()": "", "IndexYearGO.via_hashlib().shake_128()": "", "IndexYearGO.via_hashlib().shake_256()": "", "IndexYearGO.via_hashlib().blake2b()": "", "IndexYearGO.via_hashlib().blake2s()": "", "IndexYearMonth.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexYearMonth.from_date_range()": "Get an IndexYearMonth instance over a range of dates, where start and stop is in...", "IndexYearMonth.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexYearMonth.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexYearMonth.from_year_month_range()": "Get an IndexYearMonth instance over a range of months, where start and end are i...", "IndexYearMonth.from_year_range()": "Get an IndexYearMonth instance over a range of years, where start and end are in...", "IndexYearMonth.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexYearMonth.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexYearMonth.to_pandas()": "Return a Pandas Index.", "IndexYearMonth.to_series()": "Return a Series with values from this Index's labels.", "IndexYearMonth.to_visidata()": "Open an interactive VisiData session.", "IndexYearMonth.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexYearMonth.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexYearMonth.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexYearMonth.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexYearMonth.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexYearMonth.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexYearMonth.name": "A hashable label attached to this container. Returns: Hashable", "IndexYearMonth.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexYearMonth.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexYearMonth.ndim": "Return the number of dimensions. Returns: int", "IndexYearMonth.positions": "Return the immutable positions array.", "IndexYearMonth.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexYearMonth.size": "Return the size of the underlying NumPy array. Returns: int", "IndexYearMonth.__array__()": "Support the __array__ interface, returning an array of values.", "IndexYearMonth.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexYearMonth.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexYearMonth.__copy__()": "Return shallow copy of this Index.", "IndexYearMonth.__deepcopy__()": "", "IndexYearMonth.__len__()": "", "IndexYearMonth.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexYearMonth.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexYearMonth.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexYearMonth.copy()": "Return shallow copy of this Index.", "IndexYearMonth.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexYearMonth.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexYearMonth.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexYearMonth.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexYearMonth.dropna()": "Return a new Index after removing values of NaN or None.", "IndexYearMonth.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexYearMonth.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexYearMonth.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexYearMonth.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexYearMonth.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexYearMonth.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexYearMonth.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexYearMonth.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexYearMonth.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexYearMonth.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexYearMonth.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexYearMonth.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexYearMonth.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexYearMonth.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexYearMonth.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexYearMonth.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexYearMonth.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexYearMonth.rename()": "Return a new Frame with an updated name attribute.", "IndexYearMonth.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexYearMonth.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexYearMonth.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexYearMonth.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexYearMonth.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexYearMonth.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexYearMonth.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexYearMonth.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexYearMonth.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexYearMonth.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexYearMonth.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexYearMonth.__iter__()": "Iterate over labels.", "IndexYearMonth.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexYearMonth.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexYearMonth.interface": "A Frame documenting the interface of this class.", "IndexYearMonth.__repr__()": "", "IndexYearMonth.__str__()": "Return str(self).", "IndexYearMonth.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexYearMonth.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexYearMonth.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexYearMonth.drop.iloc[]": "", "IndexYearMonth.drop.loc[]": "", "IndexYearMonth.[]": "Extract a new index given an iloc key.", "IndexYearMonth.iloc[]": "", "IndexYearMonth.loc[]": "", "IndexYearMonth.iter_label()": "", "IndexYearMonth.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexYearMonth.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexYearMonth.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexYearMonth.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexYearMonth.__add__()": "", "IndexYearMonth.__and__()": "", "IndexYearMonth.__eq__()": "", "IndexYearMonth.__floordiv__()": "", "IndexYearMonth.__ge__()": "", "IndexYearMonth.__gt__()": "", "IndexYearMonth.__le__()": "", "IndexYearMonth.__lt__()": "", "IndexYearMonth.__matmul__()": "", "IndexYearMonth.__mod__()": "", "IndexYearMonth.__mul__()": "", "IndexYearMonth.__ne__()": "", "IndexYearMonth.__or__()": "", "IndexYearMonth.__pow__()": "", "IndexYearMonth.__radd__()": "", "IndexYearMonth.__rfloordiv__()": "", "IndexYearMonth.__rmatmul__()": "", "IndexYearMonth.__rmul__()": "", "IndexYearMonth.__rshift__()": "", "IndexYearMonth.__rsub__()": "", "IndexYearMonth.__rtruediv__()": "", "IndexYearMonth.__sub__()": "", "IndexYearMonth.__truediv__()": "", "IndexYearMonth.__xor__()": "", "IndexYearMonth.__abs__()": "", "IndexYearMonth.__invert__()": "", "IndexYearMonth.__neg__()": "", "IndexYearMonth.__pos__()": "", "IndexYearMonth.via_values.apply()": "", "IndexYearMonth.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexYearMonth.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexYearMonth.via_dt.year": "Return the year of each element.", "IndexYearMonth.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexYearMonth.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexYearMonth.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexYearMonth.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexYearMonth.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexYearMonth.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexYearMonth.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexYearMonth.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexYearMonth.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexYearMonth.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexYearMonth.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexYearMonth.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexYearMonth.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexYearMonth.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexYearMonth.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexYearMonth.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexYearMonth.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexYearMonth.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexYearMonth.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexYearMonth.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexYearMonth.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexYearMonth.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexYearMonth.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexYearMonth.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexYearMonth.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexYearMonth.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexYearMonth.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexYearMonth.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexYearMonth.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexYearMonth.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexYearMonth.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexYearMonth.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexYearMonth.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexYearMonth.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexYearMonth.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexYearMonth.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexYearMonth.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexYearMonth.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexYearMonth.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexYearMonth.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexYearMonth.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexYearMonth.via_str.len()": "Return the length of the string.", "IndexYearMonth.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexYearMonth.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexYearMonth.via_str.partition()": "Partition each element around sep.", "IndexYearMonth.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexYearMonth.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexYearMonth.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexYearMonth.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexYearMonth.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexYearMonth.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexYearMonth.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexYearMonth.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexYearMonth.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexYearMonth.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexYearMonth.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexYearMonth.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexYearMonth.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexYearMonth.via_str.zfill()": "Return the string left-filled with zeros.", "IndexYearMonth.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexYearMonth.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexYearMonth.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexYearMonth.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexYearMonth.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexYearMonth.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexYearMonth.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexYearMonth.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexYearMonth.via_hashlib().md5()": "", "IndexYearMonth.via_hashlib().sha256()": "", "IndexYearMonth.via_hashlib().sha512()": "", "IndexYearMonth.via_hashlib().sha3_256()": "", "IndexYearMonth.via_hashlib().sha3_512()": "", "IndexYearMonth.via_hashlib().shake_128()": "", "IndexYearMonth.via_hashlib().shake_256()": "", "IndexYearMonth.via_hashlib().blake2b()": "", "IndexYearMonth.via_hashlib().blake2s()": "", "IndexYearMonthGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexYearMonthGO.from_date_range()": "Get an IndexYearMonth instance over a range of dates, where start and stop is in...", "IndexYearMonthGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexYearMonthGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexYearMonthGO.from_year_month_range()": "Get an IndexYearMonth instance over a range of months, where start and end are i...", "IndexYearMonthGO.from_year_range()": "Get an IndexYearMonth instance over a range of years, where start and end are in...", "IndexYearMonthGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexYearMonthGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexYearMonthGO.to_pandas()": "Return a Pandas Index.", "IndexYearMonthGO.to_series()": "Return a Series with values from this Index's labels.", "IndexYearMonthGO.to_visidata()": "Open an interactive VisiData session.", "IndexYearMonthGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexYearMonthGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexYearMonthGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexYearMonthGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexYearMonthGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexYearMonthGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexYearMonthGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexYearMonthGO.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexYearMonthGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexYearMonthGO.ndim": "Return the number of dimensions. Returns: int", "IndexYearMonthGO.positions": "Return the immutable positions array.", "IndexYearMonthGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexYearMonthGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexYearMonthGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexYearMonthGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexYearMonthGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexYearMonthGO.__copy__()": "Return shallow copy of this Index.", "IndexYearMonthGO.__deepcopy__()": "", "IndexYearMonthGO.__len__()": "", "IndexYearMonthGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexYearMonthGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexYearMonthGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resol...", "IndexYearMonthGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexYearMonthGO.copy()": "Return shallow copy of this Index.", "IndexYearMonthGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexYearMonthGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexYearMonthGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexYearMonthGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexYearMonthGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexYearMonthGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexYearMonthGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexYearMonthGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexYearMonthGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexYearMonthGO.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexYearMonthGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexYearMonthGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexYearMonthGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexYearMonthGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexYearMonthGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexYearMonthGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexYearMonthGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexYearMonthGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexYearMonthGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexYearMonthGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexYearMonthGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexYearMonthGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexYearMonthGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexYearMonthGO.rename()": "Return a new Frame with an updated name attribute.", "IndexYearMonthGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexYearMonthGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexYearMonthGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexYearMonthGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexYearMonthGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexYearMonthGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexYearMonthGO.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexYearMonthGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexYearMonthGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexYearMonthGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexYearMonthGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexYearMonthGO.__iter__()": "Iterate over labels.", "IndexYearMonthGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexYearMonthGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexYearMonthGO.interface": "A Frame documenting the interface of this class.", "IndexYearMonthGO.__repr__()": "", "IndexYearMonthGO.__str__()": "Return str(self).", "IndexYearMonthGO.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexYearMonthGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexYearMonthGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexYearMonthGO.drop.iloc[]": "", "IndexYearMonthGO.drop.loc[]": "", "IndexYearMonthGO.[]": "Extract a new index given an iloc key.", "IndexYearMonthGO.iloc[]": "", "IndexYearMonthGO.loc[]": "", "IndexYearMonthGO.iter_label()": "", "IndexYearMonthGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexYearMonthGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexYearMonthGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexYearMonthGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexYearMonthGO.__add__()": "", "IndexYearMonthGO.__and__()": "", "IndexYearMonthGO.__eq__()": "", "IndexYearMonthGO.__floordiv__()": "", "IndexYearMonthGO.__ge__()": "", "IndexYearMonthGO.__gt__()": "", "IndexYearMonthGO.__le__()": "", "IndexYearMonthGO.__lt__()": "", "IndexYearMonthGO.__matmul__()": "", "IndexYearMonthGO.__mod__()": "", "IndexYearMonthGO.__mul__()": "", "IndexYearMonthGO.__ne__()": "", "IndexYearMonthGO.__or__()": "", "IndexYearMonthGO.__pow__()": "", "IndexYearMonthGO.__radd__()": "", "IndexYearMonthGO.__rfloordiv__()": "", "IndexYearMonthGO.__rmatmul__()": "", "IndexYearMonthGO.__rmul__()": "", "IndexYearMonthGO.__rshift__()": "", "IndexYearMonthGO.__rsub__()": "", "IndexYearMonthGO.__rtruediv__()": "", "IndexYearMonthGO.__sub__()": "", "IndexYearMonthGO.__truediv__()": "", "IndexYearMonthGO.__xor__()": "", "IndexYearMonthGO.__abs__()": "", "IndexYearMonthGO.__invert__()": "", "IndexYearMonthGO.__neg__()": "", "IndexYearMonthGO.__pos__()": "", "IndexYearMonthGO.via_values.apply()": "", "IndexYearMonthGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexYearMonthGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexYearMonthGO.via_dt.year": "Return the year of each element.", "IndexYearMonthGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexYearMonthGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexYearMonthGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexYearMonthGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexYearMonthGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexYearMonthGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexYearMonthGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexYearMonthGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexYearMonthGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexYearMonthGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexYearMonthGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexYearMonthGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexYearMonthGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexYearMonthGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexYearMonthGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexYearMonthGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexYearMonthGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexYearMonthGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexYearMonthGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexYearMonthGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexYearMonthGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexYearMonthGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexYearMonthGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexYearMonthGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexYearMonthGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexYearMonthGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexYearMonthGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexYearMonthGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexYearMonthGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexYearMonthGO.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexYearMonthGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexYearMonthGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexYearMonthGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexYearMonthGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexYearMonthGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexYearMonthGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexYearMonthGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexYearMonthGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexYearMonthGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexYearMonthGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexYearMonthGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexYearMonthGO.via_str.len()": "Return the length of the string.", "IndexYearMonthGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexYearMonthGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexYearMonthGO.via_str.partition()": "Partition each element around sep.", "IndexYearMonthGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexYearMonthGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexYearMonthGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexYearMonthGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexYearMonthGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexYearMonthGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexYearMonthGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexYearMonthGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexYearMonthGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexYearMonthGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexYearMonthGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexYearMonthGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexYearMonthGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexYearMonthGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexYearMonthGO.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexYearMonthGO.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexYearMonthGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexYearMonthGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexYearMonthGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexYearMonthGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexYearMonthGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexYearMonthGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexYearMonthGO.via_hashlib().md5()": "", "IndexYearMonthGO.via_hashlib().sha256()": "", "IndexYearMonthGO.via_hashlib().sha512()": "", "IndexYearMonthGO.via_hashlib().sha3_256()": "", "IndexYearMonthGO.via_hashlib().sha3_512()": "", "IndexYearMonthGO.via_hashlib().shake_128()": "", "IndexYearMonthGO.via_hashlib().shake_256()": "", "IndexYearMonthGO.via_hashlib().blake2b()": "", "IndexYearMonthGO.via_hashlib().blake2s()": "", "IndexDate.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexDate.from_date_range()": "Get an IndexDate instance over a range of dates, where start and stop is inclusi...", "IndexDate.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexDate.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexDate.from_year_month_range()": "Get an IndexDate instance over a range of months, where start and end are inclus...", "IndexDate.from_year_range()": "Get an IndexDate instance over a range of years, where start and end are inclusi...", "IndexDate.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexDate.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexDate.to_pandas()": "Return a Pandas Index.", "IndexDate.to_series()": "Return a Series with values from this Index's labels.", "IndexDate.to_visidata()": "Open an interactive VisiData session.", "IndexDate.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexDate.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexDate.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexDate.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexDate.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexDate.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexDate.name": "A hashable label attached to this container. Returns: Hashable", "IndexDate.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexDate.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexDate.ndim": "Return the number of dimensions. Returns: int", "IndexDate.positions": "Return the immutable positions array.", "IndexDate.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexDate.size": "Return the size of the underlying NumPy array. Returns: int", "IndexDate.__array__()": "Support the __array__ interface, returning an array of values.", "IndexDate.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexDate.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexDate.__copy__()": "Return shallow copy of this Index.", "IndexDate.__deepcopy__()": "", "IndexDate.__len__()": "", "IndexDate.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexDate.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexDate.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexDate.copy()": "Return shallow copy of this Index.", "IndexDate.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexDate.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexDate.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexDate.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexDate.dropna()": "Return a new Index after removing values of NaN or None.", "IndexDate.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexDate.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexDate.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexDate.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexDate.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexDate.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexDate.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexDate.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexDate.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexDate.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexDate.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexDate.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexDate.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexDate.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexDate.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexDate.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexDate.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexDate.rename()": "Return a new Frame with an updated name attribute.", "IndexDate.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexDate.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexDate.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexDate.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexDate.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexDate.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexDate.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexDate.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexDate.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexDate.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexDate.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexDate.__iter__()": "Iterate over labels.", "IndexDate.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexDate.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexDate.interface": "A Frame documenting the interface of this class.", "IndexDate.__repr__()": "", "IndexDate.__str__()": "Return str(self).", "IndexDate.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexDate.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexDate.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexDate.drop.iloc[]": "", "IndexDate.drop.loc[]": "", "IndexDate.[]": "Extract a new index given an iloc key.", "IndexDate.iloc[]": "", "IndexDate.loc[]": "", "IndexDate.iter_label()": "", "IndexDate.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexDate.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexDate.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexDate.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexDate.__add__()": "", "IndexDate.__and__()": "", "IndexDate.__eq__()": "", "IndexDate.__floordiv__()": "", "IndexDate.__ge__()": "", "IndexDate.__gt__()": "", "IndexDate.__le__()": "", "IndexDate.__lt__()": "", "IndexDate.__matmul__()": "", "IndexDate.__mod__()": "", "IndexDate.__mul__()": "", "IndexDate.__ne__()": "", "IndexDate.__or__()": "", "IndexDate.__pow__()": "", "IndexDate.__radd__()": "", "IndexDate.__rfloordiv__()": "", "IndexDate.__rmatmul__()": "", "IndexDate.__rmul__()": "", "IndexDate.__rshift__()": "", "IndexDate.__rsub__()": "", "IndexDate.__rtruediv__()": "", "IndexDate.__sub__()": "", "IndexDate.__truediv__()": "", "IndexDate.__xor__()": "", "IndexDate.__abs__()": "", "IndexDate.__invert__()": "", "IndexDate.__neg__()": "", "IndexDate.__pos__()": "", "IndexDate.via_values.apply()": "", "IndexDate.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexDate.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexDate.via_dt.year": "Return the year of each element.", "IndexDate.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexDate.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexDate.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexDate.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexDate.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexDate.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexDate.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexDate.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexDate.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexDate.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexDate.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexDate.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexDate.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexDate.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexDate.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexDate.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexDate.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexDate.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexDate.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexDate.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexDate.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexDate.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexDate.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexDate.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexDate.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexDate.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexDate.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexDate.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexDate.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexDate.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexDate.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexDate.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexDate.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexDate.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexDate.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexDate.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexDate.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexDate.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexDate.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexDate.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexDate.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexDate.via_str.len()": "Return the length of the string.", "IndexDate.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexDate.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexDate.via_str.partition()": "Partition each element around sep.", "IndexDate.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexDate.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexDate.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexDate.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexDate.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexDate.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexDate.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexDate.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexDate.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexDate.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexDate.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexDate.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexDate.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexDate.via_str.zfill()": "Return the string left-filled with zeros.", "IndexDate.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexDate.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexDate.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexDate.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexDate.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexDate.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexDate.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexDate.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexDate.via_hashlib().md5()": "", "IndexDate.via_hashlib().sha256()": "", "IndexDate.via_hashlib().sha512()": "", "IndexDate.via_hashlib().sha3_256()": "", "IndexDate.via_hashlib().sha3_512()": "", "IndexDate.via_hashlib().shake_128()": "", "IndexDate.via_hashlib().shake_256()": "", "IndexDate.via_hashlib().blake2b()": "", "IndexDate.via_hashlib().blake2s()": "", "IndexDateGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexDateGO.from_date_range()": "Get an IndexDate instance over a range of dates, where start and stop is inclusi...", "IndexDateGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexDateGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexDateGO.from_year_month_range()": "Get an IndexDate instance over a range of months, where start and end are inclus...", "IndexDateGO.from_year_range()": "Get an IndexDate instance over a range of years, where start and end are inclusi...", "IndexDateGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexDateGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexDateGO.to_pandas()": "Return a Pandas Index.", "IndexDateGO.to_series()": "Return a Series with values from this Index's labels.", "IndexDateGO.to_visidata()": "Open an interactive VisiData session.", "IndexDateGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexDateGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexDateGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexDateGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexDateGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexDateGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexDateGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexDateGO.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexDateGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexDateGO.ndim": "Return the number of dimensions. Returns: int", "IndexDateGO.positions": "Return the immutable positions array.", "IndexDateGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexDateGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexDateGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexDateGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexDateGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexDateGO.__copy__()": "Return shallow copy of this Index.", "IndexDateGO.__deepcopy__()": "", "IndexDateGO.__len__()": "", "IndexDateGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexDateGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexDateGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resol...", "IndexDateGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexDateGO.copy()": "Return shallow copy of this Index.", "IndexDateGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexDateGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexDateGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexDateGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexDateGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexDateGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexDateGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexDateGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexDateGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexDateGO.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexDateGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexDateGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexDateGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexDateGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexDateGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexDateGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexDateGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexDateGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexDateGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexDateGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexDateGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexDateGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexDateGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexDateGO.rename()": "Return a new Frame with an updated name attribute.", "IndexDateGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexDateGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexDateGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexDateGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexDateGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexDateGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexDateGO.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexDateGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexDateGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexDateGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexDateGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexDateGO.__iter__()": "Iterate over labels.", "IndexDateGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexDateGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexDateGO.interface": "A Frame documenting the interface of this class.", "IndexDateGO.__repr__()": "", "IndexDateGO.__str__()": "Return str(self).", "IndexDateGO.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexDateGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexDateGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexDateGO.drop.iloc[]": "", "IndexDateGO.drop.loc[]": "", "IndexDateGO.[]": "Extract a new index given an iloc key.", "IndexDateGO.iloc[]": "", "IndexDateGO.loc[]": "", "IndexDateGO.iter_label()": "", "IndexDateGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexDateGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexDateGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexDateGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexDateGO.__add__()": "", "IndexDateGO.__and__()": "", "IndexDateGO.__eq__()": "", "IndexDateGO.__floordiv__()": "", "IndexDateGO.__ge__()": "", "IndexDateGO.__gt__()": "", "IndexDateGO.__le__()": "", "IndexDateGO.__lt__()": "", "IndexDateGO.__matmul__()": "", "IndexDateGO.__mod__()": "", "IndexDateGO.__mul__()": "", "IndexDateGO.__ne__()": "", "IndexDateGO.__or__()": "", "IndexDateGO.__pow__()": "", "IndexDateGO.__radd__()": "", "IndexDateGO.__rfloordiv__()": "", "IndexDateGO.__rmatmul__()": "", "IndexDateGO.__rmul__()": "", "IndexDateGO.__rshift__()": "", "IndexDateGO.__rsub__()": "", "IndexDateGO.__rtruediv__()": "", "IndexDateGO.__sub__()": "", "IndexDateGO.__truediv__()": "", "IndexDateGO.__xor__()": "", "IndexDateGO.__abs__()": "", "IndexDateGO.__invert__()": "", "IndexDateGO.__neg__()": "", "IndexDateGO.__pos__()": "", "IndexDateGO.via_values.apply()": "", "IndexDateGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexDateGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexDateGO.via_dt.year": "Return the year of each element.", "IndexDateGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexDateGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexDateGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexDateGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexDateGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexDateGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexDateGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexDateGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexDateGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexDateGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexDateGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexDateGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexDateGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexDateGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexDateGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexDateGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexDateGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexDateGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexDateGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexDateGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexDateGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexDateGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexDateGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexDateGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexDateGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexDateGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexDateGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexDateGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexDateGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexDateGO.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexDateGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexDateGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexDateGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexDateGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexDateGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexDateGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexDateGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexDateGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexDateGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexDateGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexDateGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexDateGO.via_str.len()": "Return the length of the string.", "IndexDateGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexDateGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexDateGO.via_str.partition()": "Partition each element around sep.", "IndexDateGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexDateGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexDateGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexDateGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexDateGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexDateGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexDateGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexDateGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexDateGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexDateGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexDateGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexDateGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexDateGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexDateGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexDateGO.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexDateGO.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexDateGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexDateGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexDateGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexDateGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexDateGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexDateGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexDateGO.via_hashlib().md5()": "", "IndexDateGO.via_hashlib().sha256()": "", "IndexDateGO.via_hashlib().sha512()": "", "IndexDateGO.via_hashlib().sha3_256()": "", "IndexDateGO.via_hashlib().sha3_512()": "", "IndexDateGO.via_hashlib().shake_128()": "", "IndexDateGO.via_hashlib().shake_256()": "", "IndexDateGO.via_hashlib().blake2b()": "", "IndexDateGO.via_hashlib().blake2s()": "", "IndexMinute.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexMinute.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexMinute.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexMinute.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexMinute.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexMinute.to_pandas()": "Return a Pandas Index.", "IndexMinute.to_series()": "Return a Series with values from this Index's labels.", "IndexMinute.to_visidata()": "Open an interactive VisiData session.", "IndexMinute.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexMinute.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexMinute.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexMinute.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexMinute.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexMinute.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexMinute.name": "A hashable label attached to this container. Returns: Hashable", "IndexMinute.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexMinute.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexMinute.ndim": "Return the number of dimensions. Returns: int", "IndexMinute.positions": "Return the immutable positions array.", "IndexMinute.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexMinute.size": "Return the size of the underlying NumPy array. Returns: int", "IndexMinute.__array__()": "Support the __array__ interface, returning an array of values.", "IndexMinute.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexMinute.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexMinute.__copy__()": "Return shallow copy of this Index.", "IndexMinute.__deepcopy__()": "", "IndexMinute.__len__()": "", "IndexMinute.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexMinute.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexMinute.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexMinute.copy()": "Return shallow copy of this Index.", "IndexMinute.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexMinute.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexMinute.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexMinute.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexMinute.dropna()": "Return a new Index after removing values of NaN or None.", "IndexMinute.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexMinute.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexMinute.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexMinute.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexMinute.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexMinute.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexMinute.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexMinute.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexMinute.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexMinute.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexMinute.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexMinute.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMinute.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexMinute.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexMinute.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMinute.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMinute.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexMinute.rename()": "Return a new Frame with an updated name attribute.", "IndexMinute.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexMinute.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexMinute.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexMinute.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexMinute.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexMinute.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexMinute.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexMinute.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexMinute.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexMinute.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexMinute.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexMinute.__iter__()": "Iterate over labels.", "IndexMinute.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexMinute.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexMinute.interface": "A Frame documenting the interface of this class.", "IndexMinute.__repr__()": "", "IndexMinute.__str__()": "Return str(self).", "IndexMinute.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexMinute.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexMinute.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexMinute.drop.iloc[]": "", "IndexMinute.drop.loc[]": "", "IndexMinute.[]": "Extract a new index given an iloc key.", "IndexMinute.iloc[]": "", "IndexMinute.loc[]": "", "IndexMinute.iter_label()": "", "IndexMinute.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexMinute.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexMinute.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexMinute.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexMinute.__add__()": "", "IndexMinute.__and__()": "", "IndexMinute.__eq__()": "", "IndexMinute.__floordiv__()": "", "IndexMinute.__ge__()": "", "IndexMinute.__gt__()": "", "IndexMinute.__le__()": "", "IndexMinute.__lt__()": "", "IndexMinute.__matmul__()": "", "IndexMinute.__mod__()": "", "IndexMinute.__mul__()": "", "IndexMinute.__ne__()": "", "IndexMinute.__or__()": "", "IndexMinute.__pow__()": "", "IndexMinute.__radd__()": "", "IndexMinute.__rfloordiv__()": "", "IndexMinute.__rmatmul__()": "", "IndexMinute.__rmul__()": "", "IndexMinute.__rshift__()": "", "IndexMinute.__rsub__()": "", "IndexMinute.__rtruediv__()": "", "IndexMinute.__sub__()": "", "IndexMinute.__truediv__()": "", "IndexMinute.__xor__()": "", "IndexMinute.__abs__()": "", "IndexMinute.__invert__()": "", "IndexMinute.__neg__()": "", "IndexMinute.__pos__()": "", "IndexMinute.via_values.apply()": "", "IndexMinute.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexMinute.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexMinute.via_dt.year": "Return the year of each element.", "IndexMinute.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexMinute.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexMinute.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexMinute.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexMinute.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexMinute.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexMinute.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexMinute.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexMinute.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexMinute.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexMinute.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexMinute.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexMinute.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexMinute.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexMinute.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexMinute.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexMinute.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexMinute.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexMinute.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexMinute.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexMinute.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexMinute.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexMinute.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexMinute.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexMinute.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMinute.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexMinute.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexMinute.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMinute.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexMinute.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexMinute.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexMinute.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexMinute.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexMinute.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexMinute.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexMinute.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexMinute.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexMinute.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexMinute.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexMinute.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexMinute.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexMinute.via_str.len()": "Return the length of the string.", "IndexMinute.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexMinute.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexMinute.via_str.partition()": "Partition each element around sep.", "IndexMinute.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexMinute.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexMinute.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexMinute.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexMinute.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexMinute.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexMinute.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexMinute.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexMinute.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMinute.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexMinute.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMinute.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMinute.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMinute.via_str.zfill()": "Return the string left-filled with zeros.", "IndexMinute.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexMinute.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexMinute.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexMinute.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexMinute.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexMinute.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexMinute.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexMinute.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexMinute.via_hashlib().md5()": "", "IndexMinute.via_hashlib().sha256()": "", "IndexMinute.via_hashlib().sha512()": "", "IndexMinute.via_hashlib().sha3_256()": "", "IndexMinute.via_hashlib().sha3_512()": "", "IndexMinute.via_hashlib().shake_128()": "", "IndexMinute.via_hashlib().shake_256()": "", "IndexMinute.via_hashlib().blake2b()": "", "IndexMinute.via_hashlib().blake2s()": "", "IndexMinuteGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexMinuteGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexMinuteGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexMinuteGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexMinuteGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexMinuteGO.to_pandas()": "Return a Pandas Index.", "IndexMinuteGO.to_series()": "Return a Series with values from this Index's labels.", "IndexMinuteGO.to_visidata()": "Open an interactive VisiData session.", "IndexMinuteGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexMinuteGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexMinuteGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexMinuteGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexMinuteGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexMinuteGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexMinuteGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexMinuteGO.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexMinuteGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexMinuteGO.ndim": "Return the number of dimensions. Returns: int", "IndexMinuteGO.positions": "Return the immutable positions array.", "IndexMinuteGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexMinuteGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexMinuteGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexMinuteGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexMinuteGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexMinuteGO.__copy__()": "Return shallow copy of this Index.", "IndexMinuteGO.__deepcopy__()": "", "IndexMinuteGO.__len__()": "", "IndexMinuteGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexMinuteGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexMinuteGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resol...", "IndexMinuteGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexMinuteGO.copy()": "Return shallow copy of this Index.", "IndexMinuteGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexMinuteGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexMinuteGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexMinuteGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexMinuteGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexMinuteGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexMinuteGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexMinuteGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexMinuteGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexMinuteGO.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexMinuteGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexMinuteGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexMinuteGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexMinuteGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexMinuteGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexMinuteGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexMinuteGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexMinuteGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMinuteGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexMinuteGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexMinuteGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMinuteGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMinuteGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexMinuteGO.rename()": "Return a new Frame with an updated name attribute.", "IndexMinuteGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexMinuteGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexMinuteGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexMinuteGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexMinuteGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexMinuteGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexMinuteGO.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexMinuteGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexMinuteGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexMinuteGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexMinuteGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexMinuteGO.__iter__()": "Iterate over labels.", "IndexMinuteGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexMinuteGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexMinuteGO.interface": "A Frame documenting the interface of this class.", "IndexMinuteGO.__repr__()": "", "IndexMinuteGO.__str__()": "Return str(self).", "IndexMinuteGO.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexMinuteGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexMinuteGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexMinuteGO.drop.iloc[]": "", "IndexMinuteGO.drop.loc[]": "", "IndexMinuteGO.[]": "Extract a new index given an iloc key.", "IndexMinuteGO.iloc[]": "", "IndexMinuteGO.loc[]": "", "IndexMinuteGO.iter_label()": "", "IndexMinuteGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexMinuteGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexMinuteGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexMinuteGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexMinuteGO.__add__()": "", "IndexMinuteGO.__and__()": "", "IndexMinuteGO.__eq__()": "", "IndexMinuteGO.__floordiv__()": "", "IndexMinuteGO.__ge__()": "", "IndexMinuteGO.__gt__()": "", "IndexMinuteGO.__le__()": "", "IndexMinuteGO.__lt__()": "", "IndexMinuteGO.__matmul__()": "", "IndexMinuteGO.__mod__()": "", "IndexMinuteGO.__mul__()": "", "IndexMinuteGO.__ne__()": "", "IndexMinuteGO.__or__()": "", "IndexMinuteGO.__pow__()": "", "IndexMinuteGO.__radd__()": "", "IndexMinuteGO.__rfloordiv__()": "", "IndexMinuteGO.__rmatmul__()": "", "IndexMinuteGO.__rmul__()": "", "IndexMinuteGO.__rshift__()": "", "IndexMinuteGO.__rsub__()": "", "IndexMinuteGO.__rtruediv__()": "", "IndexMinuteGO.__sub__()": "", "IndexMinuteGO.__truediv__()": "", "IndexMinuteGO.__xor__()": "", "IndexMinuteGO.__abs__()": "", "IndexMinuteGO.__invert__()": "", "IndexMinuteGO.__neg__()": "", "IndexMinuteGO.__pos__()": "", "IndexMinuteGO.via_values.apply()": "", "IndexMinuteGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexMinuteGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexMinuteGO.via_dt.year": "Return the year of each element.", "IndexMinuteGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexMinuteGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexMinuteGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexMinuteGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexMinuteGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexMinuteGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexMinuteGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexMinuteGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexMinuteGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexMinuteGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexMinuteGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexMinuteGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexMinuteGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexMinuteGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexMinuteGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexMinuteGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexMinuteGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexMinuteGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexMinuteGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexMinuteGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexMinuteGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexMinuteGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexMinuteGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexMinuteGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexMinuteGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMinuteGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexMinuteGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexMinuteGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMinuteGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexMinuteGO.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexMinuteGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexMinuteGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexMinuteGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexMinuteGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexMinuteGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexMinuteGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexMinuteGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexMinuteGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexMinuteGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexMinuteGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexMinuteGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexMinuteGO.via_str.len()": "Return the length of the string.", "IndexMinuteGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexMinuteGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexMinuteGO.via_str.partition()": "Partition each element around sep.", "IndexMinuteGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexMinuteGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexMinuteGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexMinuteGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexMinuteGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexMinuteGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexMinuteGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexMinuteGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexMinuteGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMinuteGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexMinuteGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMinuteGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMinuteGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMinuteGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexMinuteGO.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexMinuteGO.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexMinuteGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexMinuteGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexMinuteGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexMinuteGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexMinuteGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexMinuteGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexMinuteGO.via_hashlib().md5()": "", "IndexMinuteGO.via_hashlib().sha256()": "", "IndexMinuteGO.via_hashlib().sha512()": "", "IndexMinuteGO.via_hashlib().sha3_256()": "", "IndexMinuteGO.via_hashlib().sha3_512()": "", "IndexMinuteGO.via_hashlib().shake_128()": "", "IndexMinuteGO.via_hashlib().shake_256()": "", "IndexMinuteGO.via_hashlib().blake2b()": "", "IndexMinuteGO.via_hashlib().blake2s()": "", "IndexHour.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexHour.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexHour.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexHour.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexHour.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexHour.to_pandas()": "Return a Pandas Index.", "IndexHour.to_series()": "Return a Series with values from this Index's labels.", "IndexHour.to_visidata()": "Open an interactive VisiData session.", "IndexHour.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexHour.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexHour.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexHour.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexHour.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexHour.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexHour.name": "A hashable label attached to this container. Returns: Hashable", "IndexHour.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexHour.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexHour.ndim": "Return the number of dimensions. Returns: int", "IndexHour.positions": "Return the immutable positions array.", "IndexHour.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexHour.size": "Return the size of the underlying NumPy array. Returns: int", "IndexHour.__array__()": "Support the __array__ interface, returning an array of values.", "IndexHour.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexHour.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexHour.__copy__()": "Return shallow copy of this Index.", "IndexHour.__deepcopy__()": "", "IndexHour.__len__()": "", "IndexHour.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexHour.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexHour.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexHour.copy()": "Return shallow copy of this Index.", "IndexHour.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexHour.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexHour.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexHour.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexHour.dropna()": "Return a new Index after removing values of NaN or None.", "IndexHour.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexHour.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexHour.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexHour.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexHour.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexHour.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexHour.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexHour.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexHour.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexHour.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexHour.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexHour.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexHour.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexHour.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexHour.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexHour.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexHour.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexHour.rename()": "Return a new Frame with an updated name attribute.", "IndexHour.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexHour.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexHour.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexHour.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexHour.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexHour.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexHour.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexHour.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexHour.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexHour.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexHour.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexHour.__iter__()": "Iterate over labels.", "IndexHour.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexHour.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexHour.interface": "A Frame documenting the interface of this class.", "IndexHour.__repr__()": "", "IndexHour.__str__()": "Return str(self).", "IndexHour.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexHour.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexHour.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexHour.drop.iloc[]": "", "IndexHour.drop.loc[]": "", "IndexHour.[]": "Extract a new index given an iloc key.", "IndexHour.iloc[]": "", "IndexHour.loc[]": "", "IndexHour.iter_label()": "", "IndexHour.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexHour.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexHour.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexHour.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexHour.__add__()": "", "IndexHour.__and__()": "", "IndexHour.__eq__()": "", "IndexHour.__floordiv__()": "", "IndexHour.__ge__()": "", "IndexHour.__gt__()": "", "IndexHour.__le__()": "", "IndexHour.__lt__()": "", "IndexHour.__matmul__()": "", "IndexHour.__mod__()": "", "IndexHour.__mul__()": "", "IndexHour.__ne__()": "", "IndexHour.__or__()": "", "IndexHour.__pow__()": "", "IndexHour.__radd__()": "", "IndexHour.__rfloordiv__()": "", "IndexHour.__rmatmul__()": "", "IndexHour.__rmul__()": "", "IndexHour.__rshift__()": "", "IndexHour.__rsub__()": "", "IndexHour.__rtruediv__()": "", "IndexHour.__sub__()": "", "IndexHour.__truediv__()": "", "IndexHour.__xor__()": "", "IndexHour.__abs__()": "", "IndexHour.__invert__()": "", "IndexHour.__neg__()": "", "IndexHour.__pos__()": "", "IndexHour.via_values.apply()": "", "IndexHour.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexHour.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexHour.via_dt.year": "Return the year of each element.", "IndexHour.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexHour.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexHour.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexHour.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexHour.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexHour.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexHour.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexHour.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexHour.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexHour.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexHour.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexHour.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexHour.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexHour.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexHour.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexHour.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexHour.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexHour.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexHour.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexHour.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexHour.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexHour.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexHour.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexHour.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexHour.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexHour.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexHour.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexHour.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexHour.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexHour.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexHour.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexHour.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexHour.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexHour.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexHour.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexHour.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexHour.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexHour.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexHour.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexHour.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexHour.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexHour.via_str.len()": "Return the length of the string.", "IndexHour.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexHour.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexHour.via_str.partition()": "Partition each element around sep.", "IndexHour.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexHour.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexHour.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexHour.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexHour.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexHour.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexHour.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexHour.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexHour.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexHour.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexHour.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexHour.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexHour.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexHour.via_str.zfill()": "Return the string left-filled with zeros.", "IndexHour.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexHour.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexHour.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexHour.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexHour.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexHour.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexHour.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexHour.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexHour.via_hashlib().md5()": "", "IndexHour.via_hashlib().sha256()": "", "IndexHour.via_hashlib().sha512()": "", "IndexHour.via_hashlib().sha3_256()": "", "IndexHour.via_hashlib().sha3_512()": "", "IndexHour.via_hashlib().shake_128()": "", "IndexHour.via_hashlib().shake_256()": "", "IndexHour.via_hashlib().blake2b()": "", "IndexHour.via_hashlib().blake2s()": "", "IndexHourGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexHourGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexHourGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexHourGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexHourGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexHourGO.to_pandas()": "Return a Pandas Index.", "IndexHourGO.to_series()": "Return a Series with values from this Index's labels.", "IndexHourGO.to_visidata()": "Open an interactive VisiData session.", "IndexHourGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexHourGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexHourGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexHourGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexHourGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexHourGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexHourGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexHourGO.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexHourGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexHourGO.ndim": "Return the number of dimensions. Returns: int", "IndexHourGO.positions": "Return the immutable positions array.", "IndexHourGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexHourGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexHourGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexHourGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexHourGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexHourGO.__copy__()": "Return shallow copy of this Index.", "IndexHourGO.__deepcopy__()": "", "IndexHourGO.__len__()": "", "IndexHourGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexHourGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexHourGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resol...", "IndexHourGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexHourGO.copy()": "Return shallow copy of this Index.", "IndexHourGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexHourGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexHourGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexHourGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexHourGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexHourGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexHourGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexHourGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexHourGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexHourGO.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexHourGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexHourGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexHourGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexHourGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexHourGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexHourGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexHourGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexHourGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexHourGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexHourGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexHourGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexHourGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexHourGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexHourGO.rename()": "Return a new Frame with an updated name attribute.", "IndexHourGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexHourGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexHourGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexHourGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexHourGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexHourGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexHourGO.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexHourGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexHourGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexHourGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexHourGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexHourGO.__iter__()": "Iterate over labels.", "IndexHourGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexHourGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexHourGO.interface": "A Frame documenting the interface of this class.", "IndexHourGO.__repr__()": "", "IndexHourGO.__str__()": "Return str(self).", "IndexHourGO.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexHourGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexHourGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexHourGO.drop.iloc[]": "", "IndexHourGO.drop.loc[]": "", "IndexHourGO.[]": "Extract a new index given an iloc key.", "IndexHourGO.iloc[]": "", "IndexHourGO.loc[]": "", "IndexHourGO.iter_label()": "", "IndexHourGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexHourGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexHourGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexHourGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexHourGO.__add__()": "", "IndexHourGO.__and__()": "", "IndexHourGO.__eq__()": "", "IndexHourGO.__floordiv__()": "", "IndexHourGO.__ge__()": "", "IndexHourGO.__gt__()": "", "IndexHourGO.__le__()": "", "IndexHourGO.__lt__()": "", "IndexHourGO.__matmul__()": "", "IndexHourGO.__mod__()": "", "IndexHourGO.__mul__()": "", "IndexHourGO.__ne__()": "", "IndexHourGO.__or__()": "", "IndexHourGO.__pow__()": "", "IndexHourGO.__radd__()": "", "IndexHourGO.__rfloordiv__()": "", "IndexHourGO.__rmatmul__()": "", "IndexHourGO.__rmul__()": "", "IndexHourGO.__rshift__()": "", "IndexHourGO.__rsub__()": "", "IndexHourGO.__rtruediv__()": "", "IndexHourGO.__sub__()": "", "IndexHourGO.__truediv__()": "", "IndexHourGO.__xor__()": "", "IndexHourGO.__abs__()": "", "IndexHourGO.__invert__()": "", "IndexHourGO.__neg__()": "", "IndexHourGO.__pos__()": "", "IndexHourGO.via_values.apply()": "", "IndexHourGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexHourGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexHourGO.via_dt.year": "Return the year of each element.", "IndexHourGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexHourGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexHourGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexHourGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexHourGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexHourGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexHourGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexHourGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexHourGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexHourGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexHourGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexHourGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexHourGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexHourGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexHourGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexHourGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexHourGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexHourGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexHourGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexHourGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexHourGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexHourGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexHourGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexHourGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexHourGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexHourGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexHourGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexHourGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexHourGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexHourGO.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexHourGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexHourGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexHourGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexHourGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexHourGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexHourGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexHourGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexHourGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexHourGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexHourGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexHourGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexHourGO.via_str.len()": "Return the length of the string.", "IndexHourGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexHourGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexHourGO.via_str.partition()": "Partition each element around sep.", "IndexHourGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexHourGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexHourGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexHourGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexHourGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexHourGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexHourGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexHourGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexHourGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexHourGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexHourGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexHourGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexHourGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexHourGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexHourGO.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexHourGO.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexHourGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexHourGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexHourGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexHourGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexHourGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexHourGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexHourGO.via_hashlib().md5()": "", "IndexHourGO.via_hashlib().sha256()": "", "IndexHourGO.via_hashlib().sha512()": "", "IndexHourGO.via_hashlib().sha3_256()": "", "IndexHourGO.via_hashlib().sha3_512()": "", "IndexHourGO.via_hashlib().shake_128()": "", "IndexHourGO.via_hashlib().shake_256()": "", "IndexHourGO.via_hashlib().blake2b()": "", "IndexHourGO.via_hashlib().blake2s()": "", "IndexSecond.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexSecond.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexSecond.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexSecond.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexSecond.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexSecond.to_pandas()": "Return a Pandas Index.", "IndexSecond.to_series()": "Return a Series with values from this Index's labels.", "IndexSecond.to_visidata()": "Open an interactive VisiData session.", "IndexSecond.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexSecond.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexSecond.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexSecond.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexSecond.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexSecond.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexSecond.name": "A hashable label attached to this container. Returns: Hashable", "IndexSecond.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexSecond.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexSecond.ndim": "Return the number of dimensions. Returns: int", "IndexSecond.positions": "Return the immutable positions array.", "IndexSecond.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexSecond.size": "Return the size of the underlying NumPy array. Returns: int", "IndexSecond.__array__()": "Support the __array__ interface, returning an array of values.", "IndexSecond.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexSecond.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexSecond.__copy__()": "Return shallow copy of this Index.", "IndexSecond.__deepcopy__()": "", "IndexSecond.__len__()": "", "IndexSecond.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexSecond.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexSecond.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexSecond.copy()": "Return shallow copy of this Index.", "IndexSecond.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexSecond.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexSecond.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexSecond.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexSecond.dropna()": "Return a new Index after removing values of NaN or None.", "IndexSecond.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexSecond.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexSecond.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexSecond.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexSecond.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexSecond.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexSecond.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexSecond.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexSecond.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexSecond.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexSecond.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexSecond.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexSecond.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexSecond.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexSecond.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexSecond.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexSecond.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexSecond.rename()": "Return a new Frame with an updated name attribute.", "IndexSecond.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexSecond.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexSecond.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexSecond.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexSecond.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexSecond.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexSecond.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexSecond.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexSecond.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexSecond.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexSecond.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexSecond.__iter__()": "Iterate over labels.", "IndexSecond.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexSecond.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexSecond.interface": "A Frame documenting the interface of this class.", "IndexSecond.__repr__()": "", "IndexSecond.__str__()": "Return str(self).", "IndexSecond.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexSecond.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexSecond.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexSecond.drop.iloc[]": "", "IndexSecond.drop.loc[]": "", "IndexSecond.[]": "Extract a new index given an iloc key.", "IndexSecond.iloc[]": "", "IndexSecond.loc[]": "", "IndexSecond.iter_label()": "", "IndexSecond.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexSecond.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexSecond.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexSecond.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexSecond.__add__()": "", "IndexSecond.__and__()": "", "IndexSecond.__eq__()": "", "IndexSecond.__floordiv__()": "", "IndexSecond.__ge__()": "", "IndexSecond.__gt__()": "", "IndexSecond.__le__()": "", "IndexSecond.__lt__()": "", "IndexSecond.__matmul__()": "", "IndexSecond.__mod__()": "", "IndexSecond.__mul__()": "", "IndexSecond.__ne__()": "", "IndexSecond.__or__()": "", "IndexSecond.__pow__()": "", "IndexSecond.__radd__()": "", "IndexSecond.__rfloordiv__()": "", "IndexSecond.__rmatmul__()": "", "IndexSecond.__rmul__()": "", "IndexSecond.__rshift__()": "", "IndexSecond.__rsub__()": "", "IndexSecond.__rtruediv__()": "", "IndexSecond.__sub__()": "", "IndexSecond.__truediv__()": "", "IndexSecond.__xor__()": "", "IndexSecond.__abs__()": "", "IndexSecond.__invert__()": "", "IndexSecond.__neg__()": "", "IndexSecond.__pos__()": "", "IndexSecond.via_values.apply()": "", "IndexSecond.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexSecond.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexSecond.via_dt.year": "Return the year of each element.", "IndexSecond.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexSecond.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexSecond.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexSecond.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexSecond.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexSecond.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexSecond.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexSecond.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexSecond.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexSecond.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexSecond.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexSecond.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexSecond.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexSecond.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexSecond.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexSecond.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexSecond.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexSecond.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexSecond.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexSecond.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexSecond.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexSecond.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexSecond.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexSecond.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexSecond.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexSecond.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexSecond.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexSecond.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexSecond.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexSecond.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexSecond.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexSecond.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexSecond.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexSecond.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexSecond.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexSecond.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexSecond.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexSecond.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexSecond.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexSecond.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexSecond.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexSecond.via_str.len()": "Return the length of the string.", "IndexSecond.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexSecond.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexSecond.via_str.partition()": "Partition each element around sep.", "IndexSecond.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexSecond.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexSecond.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexSecond.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexSecond.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexSecond.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexSecond.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexSecond.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexSecond.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexSecond.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexSecond.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexSecond.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexSecond.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexSecond.via_str.zfill()": "Return the string left-filled with zeros.", "IndexSecond.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexSecond.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexSecond.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexSecond.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexSecond.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexSecond.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexSecond.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexSecond.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexSecond.via_hashlib().md5()": "", "IndexSecond.via_hashlib().sha256()": "", "IndexSecond.via_hashlib().sha512()": "", "IndexSecond.via_hashlib().sha3_256()": "", "IndexSecond.via_hashlib().sha3_512()": "", "IndexSecond.via_hashlib().shake_128()": "", "IndexSecond.via_hashlib().shake_256()": "", "IndexSecond.via_hashlib().blake2b()": "", "IndexSecond.via_hashlib().blake2s()": "", "IndexSecondGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexSecondGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexSecondGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexSecondGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexSecondGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexSecondGO.to_pandas()": "Return a Pandas Index.", "IndexSecondGO.to_series()": "Return a Series with values from this Index's labels.", "IndexSecondGO.to_visidata()": "Open an interactive VisiData session.", "IndexSecondGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexSecondGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexSecondGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexSecondGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexSecondGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexSecondGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexSecondGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexSecondGO.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexSecondGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexSecondGO.ndim": "Return the number of dimensions. Returns: int", "IndexSecondGO.positions": "Return the immutable positions array.", "IndexSecondGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexSecondGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexSecondGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexSecondGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexSecondGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexSecondGO.__copy__()": "Return shallow copy of this Index.", "IndexSecondGO.__deepcopy__()": "", "IndexSecondGO.__len__()": "", "IndexSecondGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexSecondGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexSecondGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resol...", "IndexSecondGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexSecondGO.copy()": "Return shallow copy of this Index.", "IndexSecondGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexSecondGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexSecondGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexSecondGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexSecondGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexSecondGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexSecondGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexSecondGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexSecondGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexSecondGO.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexSecondGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexSecondGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexSecondGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexSecondGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexSecondGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexSecondGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexSecondGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexSecondGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexSecondGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexSecondGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexSecondGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexSecondGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexSecondGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexSecondGO.rename()": "Return a new Frame with an updated name attribute.", "IndexSecondGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexSecondGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexSecondGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexSecondGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexSecondGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexSecondGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexSecondGO.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexSecondGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexSecondGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexSecondGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexSecondGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexSecondGO.__iter__()": "Iterate over labels.", "IndexSecondGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexSecondGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexSecondGO.interface": "A Frame documenting the interface of this class.", "IndexSecondGO.__repr__()": "", "IndexSecondGO.__str__()": "Return str(self).", "IndexSecondGO.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexSecondGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexSecondGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexSecondGO.drop.iloc[]": "", "IndexSecondGO.drop.loc[]": "", "IndexSecondGO.[]": "Extract a new index given an iloc key.", "IndexSecondGO.iloc[]": "", "IndexSecondGO.loc[]": "", "IndexSecondGO.iter_label()": "", "IndexSecondGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexSecondGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexSecondGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexSecondGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexSecondGO.__add__()": "", "IndexSecondGO.__and__()": "", "IndexSecondGO.__eq__()": "", "IndexSecondGO.__floordiv__()": "", "IndexSecondGO.__ge__()": "", "IndexSecondGO.__gt__()": "", "IndexSecondGO.__le__()": "", "IndexSecondGO.__lt__()": "", "IndexSecondGO.__matmul__()": "", "IndexSecondGO.__mod__()": "", "IndexSecondGO.__mul__()": "", "IndexSecondGO.__ne__()": "", "IndexSecondGO.__or__()": "", "IndexSecondGO.__pow__()": "", "IndexSecondGO.__radd__()": "", "IndexSecondGO.__rfloordiv__()": "", "IndexSecondGO.__rmatmul__()": "", "IndexSecondGO.__rmul__()": "", "IndexSecondGO.__rshift__()": "", "IndexSecondGO.__rsub__()": "", "IndexSecondGO.__rtruediv__()": "", "IndexSecondGO.__sub__()": "", "IndexSecondGO.__truediv__()": "", "IndexSecondGO.__xor__()": "", "IndexSecondGO.__abs__()": "", "IndexSecondGO.__invert__()": "", "IndexSecondGO.__neg__()": "", "IndexSecondGO.__pos__()": "", "IndexSecondGO.via_values.apply()": "", "IndexSecondGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexSecondGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexSecondGO.via_dt.year": "Return the year of each element.", "IndexSecondGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexSecondGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexSecondGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexSecondGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexSecondGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexSecondGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexSecondGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexSecondGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexSecondGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexSecondGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexSecondGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexSecondGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexSecondGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexSecondGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexSecondGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexSecondGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexSecondGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexSecondGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexSecondGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexSecondGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexSecondGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexSecondGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexSecondGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexSecondGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexSecondGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexSecondGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexSecondGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexSecondGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexSecondGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexSecondGO.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexSecondGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexSecondGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexSecondGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexSecondGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexSecondGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexSecondGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexSecondGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexSecondGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexSecondGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexSecondGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexSecondGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexSecondGO.via_str.len()": "Return the length of the string.", "IndexSecondGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexSecondGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexSecondGO.via_str.partition()": "Partition each element around sep.", "IndexSecondGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexSecondGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexSecondGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexSecondGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexSecondGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexSecondGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexSecondGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexSecondGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexSecondGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexSecondGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexSecondGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexSecondGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexSecondGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexSecondGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexSecondGO.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexSecondGO.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexSecondGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexSecondGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexSecondGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexSecondGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexSecondGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexSecondGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexSecondGO.via_hashlib().md5()": "", "IndexSecondGO.via_hashlib().sha256()": "", "IndexSecondGO.via_hashlib().sha512()": "", "IndexSecondGO.via_hashlib().sha3_256()": "", "IndexSecondGO.via_hashlib().sha3_512()": "", "IndexSecondGO.via_hashlib().shake_128()": "", "IndexSecondGO.via_hashlib().shake_256()": "", "IndexSecondGO.via_hashlib().blake2b()": "", "IndexSecondGO.via_hashlib().blake2s()": "", "IndexMillisecond.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexMillisecond.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexMillisecond.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexMillisecond.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexMillisecond.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexMillisecond.to_pandas()": "Return a Pandas Index.", "IndexMillisecond.to_series()": "Return a Series with values from this Index's labels.", "IndexMillisecond.to_visidata()": "Open an interactive VisiData session.", "IndexMillisecond.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexMillisecond.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexMillisecond.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexMillisecond.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexMillisecond.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexMillisecond.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexMillisecond.name": "A hashable label attached to this container. Returns: Hashable", "IndexMillisecond.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexMillisecond.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexMillisecond.ndim": "Return the number of dimensions. Returns: int", "IndexMillisecond.positions": "Return the immutable positions array.", "IndexMillisecond.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexMillisecond.size": "Return the size of the underlying NumPy array. Returns: int", "IndexMillisecond.__array__()": "Support the __array__ interface, returning an array of values.", "IndexMillisecond.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexMillisecond.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexMillisecond.__copy__()": "Return shallow copy of this Index.", "IndexMillisecond.__deepcopy__()": "", "IndexMillisecond.__len__()": "", "IndexMillisecond.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexMillisecond.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexMillisecond.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexMillisecond.copy()": "Return shallow copy of this Index.", "IndexMillisecond.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexMillisecond.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexMillisecond.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexMillisecond.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexMillisecond.dropna()": "Return a new Index after removing values of NaN or None.", "IndexMillisecond.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexMillisecond.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexMillisecond.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexMillisecond.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexMillisecond.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexMillisecond.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexMillisecond.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexMillisecond.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexMillisecond.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexMillisecond.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexMillisecond.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexMillisecond.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMillisecond.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexMillisecond.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexMillisecond.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMillisecond.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMillisecond.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexMillisecond.rename()": "Return a new Frame with an updated name attribute.", "IndexMillisecond.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexMillisecond.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexMillisecond.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexMillisecond.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexMillisecond.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexMillisecond.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexMillisecond.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexMillisecond.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexMillisecond.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexMillisecond.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexMillisecond.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexMillisecond.__iter__()": "Iterate over labels.", "IndexMillisecond.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexMillisecond.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexMillisecond.interface": "A Frame documenting the interface of this class.", "IndexMillisecond.__repr__()": "", "IndexMillisecond.__str__()": "Return str(self).", "IndexMillisecond.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexMillisecond.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexMillisecond.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexMillisecond.drop.iloc[]": "", "IndexMillisecond.drop.loc[]": "", "IndexMillisecond.[]": "Extract a new index given an iloc key.", "IndexMillisecond.iloc[]": "", "IndexMillisecond.loc[]": "", "IndexMillisecond.iter_label()": "", "IndexMillisecond.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexMillisecond.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexMillisecond.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexMillisecond.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexMillisecond.__add__()": "", "IndexMillisecond.__and__()": "", "IndexMillisecond.__eq__()": "", "IndexMillisecond.__floordiv__()": "", "IndexMillisecond.__ge__()": "", "IndexMillisecond.__gt__()": "", "IndexMillisecond.__le__()": "", "IndexMillisecond.__lt__()": "", "IndexMillisecond.__matmul__()": "", "IndexMillisecond.__mod__()": "", "IndexMillisecond.__mul__()": "", "IndexMillisecond.__ne__()": "", "IndexMillisecond.__or__()": "", "IndexMillisecond.__pow__()": "", "IndexMillisecond.__radd__()": "", "IndexMillisecond.__rfloordiv__()": "", "IndexMillisecond.__rmatmul__()": "", "IndexMillisecond.__rmul__()": "", "IndexMillisecond.__rshift__()": "", "IndexMillisecond.__rsub__()": "", "IndexMillisecond.__rtruediv__()": "", "IndexMillisecond.__sub__()": "", "IndexMillisecond.__truediv__()": "", "IndexMillisecond.__xor__()": "", "IndexMillisecond.__abs__()": "", "IndexMillisecond.__invert__()": "", "IndexMillisecond.__neg__()": "", "IndexMillisecond.__pos__()": "", "IndexMillisecond.via_values.apply()": "", "IndexMillisecond.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexMillisecond.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexMillisecond.via_dt.year": "Return the year of each element.", "IndexMillisecond.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexMillisecond.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexMillisecond.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexMillisecond.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexMillisecond.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexMillisecond.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexMillisecond.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexMillisecond.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexMillisecond.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexMillisecond.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexMillisecond.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexMillisecond.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexMillisecond.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexMillisecond.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexMillisecond.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexMillisecond.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexMillisecond.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexMillisecond.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexMillisecond.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexMillisecond.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexMillisecond.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexMillisecond.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexMillisecond.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexMillisecond.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexMillisecond.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMillisecond.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexMillisecond.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexMillisecond.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMillisecond.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexMillisecond.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexMillisecond.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexMillisecond.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexMillisecond.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexMillisecond.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexMillisecond.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexMillisecond.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexMillisecond.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexMillisecond.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexMillisecond.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexMillisecond.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexMillisecond.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexMillisecond.via_str.len()": "Return the length of the string.", "IndexMillisecond.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexMillisecond.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexMillisecond.via_str.partition()": "Partition each element around sep.", "IndexMillisecond.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexMillisecond.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexMillisecond.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexMillisecond.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexMillisecond.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexMillisecond.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexMillisecond.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexMillisecond.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexMillisecond.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMillisecond.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexMillisecond.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMillisecond.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMillisecond.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMillisecond.via_str.zfill()": "Return the string left-filled with zeros.", "IndexMillisecond.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexMillisecond.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexMillisecond.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexMillisecond.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexMillisecond.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexMillisecond.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexMillisecond.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexMillisecond.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexMillisecond.via_hashlib().md5()": "", "IndexMillisecond.via_hashlib().sha256()": "", "IndexMillisecond.via_hashlib().sha512()": "", "IndexMillisecond.via_hashlib().sha3_256()": "", "IndexMillisecond.via_hashlib().sha3_512()": "", "IndexMillisecond.via_hashlib().shake_128()": "", "IndexMillisecond.via_hashlib().shake_256()": "", "IndexMillisecond.via_hashlib().blake2b()": "", "IndexMillisecond.via_hashlib().blake2s()": "", "IndexMillisecondGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexMillisecondGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexMillisecondGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexMillisecondGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexMillisecondGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexMillisecondGO.to_pandas()": "Return a Pandas Index.", "IndexMillisecondGO.to_series()": "Return a Series with values from this Index's labels.", "IndexMillisecondGO.to_visidata()": "Open an interactive VisiData session.", "IndexMillisecondGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexMillisecondGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexMillisecondGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexMillisecondGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexMillisecondGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexMillisecondGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexMillisecondGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexMillisecondGO.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexMillisecondGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexMillisecondGO.ndim": "Return the number of dimensions. Returns: int", "IndexMillisecondGO.positions": "Return the immutable positions array.", "IndexMillisecondGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexMillisecondGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexMillisecondGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexMillisecondGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexMillisecondGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexMillisecondGO.__copy__()": "Return shallow copy of this Index.", "IndexMillisecondGO.__deepcopy__()": "", "IndexMillisecondGO.__len__()": "", "IndexMillisecondGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexMillisecondGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexMillisecondGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resol...", "IndexMillisecondGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexMillisecondGO.copy()": "Return shallow copy of this Index.", "IndexMillisecondGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexMillisecondGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexMillisecondGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexMillisecondGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexMillisecondGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexMillisecondGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexMillisecondGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexMillisecondGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexMillisecondGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexMillisecondGO.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexMillisecondGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexMillisecondGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexMillisecondGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexMillisecondGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexMillisecondGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexMillisecondGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexMillisecondGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexMillisecondGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMillisecondGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexMillisecondGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexMillisecondGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMillisecondGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMillisecondGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexMillisecondGO.rename()": "Return a new Frame with an updated name attribute.", "IndexMillisecondGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexMillisecondGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexMillisecondGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexMillisecondGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexMillisecondGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexMillisecondGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexMillisecondGO.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexMillisecondGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexMillisecondGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexMillisecondGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexMillisecondGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexMillisecondGO.__iter__()": "Iterate over labels.", "IndexMillisecondGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexMillisecondGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexMillisecondGO.interface": "A Frame documenting the interface of this class.", "IndexMillisecondGO.__repr__()": "", "IndexMillisecondGO.__str__()": "Return str(self).", "IndexMillisecondGO.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexMillisecondGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexMillisecondGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexMillisecondGO.drop.iloc[]": "", "IndexMillisecondGO.drop.loc[]": "", "IndexMillisecondGO.[]": "Extract a new index given an iloc key.", "IndexMillisecondGO.iloc[]": "", "IndexMillisecondGO.loc[]": "", "IndexMillisecondGO.iter_label()": "", "IndexMillisecondGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexMillisecondGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexMillisecondGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexMillisecondGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexMillisecondGO.__add__()": "", "IndexMillisecondGO.__and__()": "", "IndexMillisecondGO.__eq__()": "", "IndexMillisecondGO.__floordiv__()": "", "IndexMillisecondGO.__ge__()": "", "IndexMillisecondGO.__gt__()": "", "IndexMillisecondGO.__le__()": "", "IndexMillisecondGO.__lt__()": "", "IndexMillisecondGO.__matmul__()": "", "IndexMillisecondGO.__mod__()": "", "IndexMillisecondGO.__mul__()": "", "IndexMillisecondGO.__ne__()": "", "IndexMillisecondGO.__or__()": "", "IndexMillisecondGO.__pow__()": "", "IndexMillisecondGO.__radd__()": "", "IndexMillisecondGO.__rfloordiv__()": "", "IndexMillisecondGO.__rmatmul__()": "", "IndexMillisecondGO.__rmul__()": "", "IndexMillisecondGO.__rshift__()": "", "IndexMillisecondGO.__rsub__()": "", "IndexMillisecondGO.__rtruediv__()": "", "IndexMillisecondGO.__sub__()": "", "IndexMillisecondGO.__truediv__()": "", "IndexMillisecondGO.__xor__()": "", "IndexMillisecondGO.__abs__()": "", "IndexMillisecondGO.__invert__()": "", "IndexMillisecondGO.__neg__()": "", "IndexMillisecondGO.__pos__()": "", "IndexMillisecondGO.via_values.apply()": "", "IndexMillisecondGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexMillisecondGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexMillisecondGO.via_dt.year": "Return the year of each element.", "IndexMillisecondGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexMillisecondGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexMillisecondGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexMillisecondGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexMillisecondGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexMillisecondGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexMillisecondGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexMillisecondGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexMillisecondGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexMillisecondGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexMillisecondGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexMillisecondGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexMillisecondGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexMillisecondGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexMillisecondGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexMillisecondGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexMillisecondGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexMillisecondGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexMillisecondGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexMillisecondGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexMillisecondGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexMillisecondGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexMillisecondGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexMillisecondGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexMillisecondGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMillisecondGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexMillisecondGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexMillisecondGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMillisecondGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexMillisecondGO.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexMillisecondGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexMillisecondGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexMillisecondGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexMillisecondGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexMillisecondGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexMillisecondGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexMillisecondGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexMillisecondGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexMillisecondGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexMillisecondGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexMillisecondGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexMillisecondGO.via_str.len()": "Return the length of the string.", "IndexMillisecondGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexMillisecondGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexMillisecondGO.via_str.partition()": "Partition each element around sep.", "IndexMillisecondGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexMillisecondGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexMillisecondGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexMillisecondGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexMillisecondGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexMillisecondGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexMillisecondGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexMillisecondGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexMillisecondGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMillisecondGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexMillisecondGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMillisecondGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMillisecondGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMillisecondGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexMillisecondGO.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexMillisecondGO.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexMillisecondGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexMillisecondGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexMillisecondGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexMillisecondGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexMillisecondGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexMillisecondGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexMillisecondGO.via_hashlib().md5()": "", "IndexMillisecondGO.via_hashlib().sha256()": "", "IndexMillisecondGO.via_hashlib().sha512()": "", "IndexMillisecondGO.via_hashlib().sha3_256()": "", "IndexMillisecondGO.via_hashlib().sha3_512()": "", "IndexMillisecondGO.via_hashlib().shake_128()": "", "IndexMillisecondGO.via_hashlib().shake_256()": "", "IndexMillisecondGO.via_hashlib().blake2b()": "", "IndexMillisecondGO.via_hashlib().blake2s()": "", "IndexMicrosecond.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexMicrosecond.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexMicrosecond.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexMicrosecond.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexMicrosecond.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexMicrosecond.to_pandas()": "Return a Pandas Index.", "IndexMicrosecond.to_series()": "Return a Series with values from this Index's labels.", "IndexMicrosecond.to_visidata()": "Open an interactive VisiData session.", "IndexMicrosecond.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexMicrosecond.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexMicrosecond.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexMicrosecond.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexMicrosecond.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexMicrosecond.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexMicrosecond.name": "A hashable label attached to this container. Returns: Hashable", "IndexMicrosecond.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexMicrosecond.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexMicrosecond.ndim": "Return the number of dimensions. Returns: int", "IndexMicrosecond.positions": "Return the immutable positions array.", "IndexMicrosecond.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexMicrosecond.size": "Return the size of the underlying NumPy array. Returns: int", "IndexMicrosecond.__array__()": "Support the __array__ interface, returning an array of values.", "IndexMicrosecond.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexMicrosecond.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexMicrosecond.__copy__()": "Return shallow copy of this Index.", "IndexMicrosecond.__deepcopy__()": "", "IndexMicrosecond.__len__()": "", "IndexMicrosecond.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexMicrosecond.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexMicrosecond.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexMicrosecond.copy()": "Return shallow copy of this Index.", "IndexMicrosecond.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexMicrosecond.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexMicrosecond.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexMicrosecond.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexMicrosecond.dropna()": "Return a new Index after removing values of NaN or None.", "IndexMicrosecond.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexMicrosecond.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexMicrosecond.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexMicrosecond.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexMicrosecond.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexMicrosecond.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexMicrosecond.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexMicrosecond.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexMicrosecond.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexMicrosecond.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexMicrosecond.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexMicrosecond.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMicrosecond.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexMicrosecond.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexMicrosecond.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMicrosecond.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMicrosecond.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexMicrosecond.rename()": "Return a new Frame with an updated name attribute.", "IndexMicrosecond.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexMicrosecond.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexMicrosecond.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexMicrosecond.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexMicrosecond.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexMicrosecond.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexMicrosecond.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexMicrosecond.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexMicrosecond.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexMicrosecond.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexMicrosecond.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexMicrosecond.__iter__()": "Iterate over labels.", "IndexMicrosecond.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexMicrosecond.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexMicrosecond.interface": "A Frame documenting the interface of this class.", "IndexMicrosecond.__repr__()": "", "IndexMicrosecond.__str__()": "Return str(self).", "IndexMicrosecond.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexMicrosecond.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexMicrosecond.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexMicrosecond.drop.iloc[]": "", "IndexMicrosecond.drop.loc[]": "", "IndexMicrosecond.[]": "Extract a new index given an iloc key.", "IndexMicrosecond.iloc[]": "", "IndexMicrosecond.loc[]": "", "IndexMicrosecond.iter_label()": "", "IndexMicrosecond.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexMicrosecond.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexMicrosecond.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexMicrosecond.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexMicrosecond.__add__()": "", "IndexMicrosecond.__and__()": "", "IndexMicrosecond.__eq__()": "", "IndexMicrosecond.__floordiv__()": "", "IndexMicrosecond.__ge__()": "", "IndexMicrosecond.__gt__()": "", "IndexMicrosecond.__le__()": "", "IndexMicrosecond.__lt__()": "", "IndexMicrosecond.__matmul__()": "", "IndexMicrosecond.__mod__()": "", "IndexMicrosecond.__mul__()": "", "IndexMicrosecond.__ne__()": "", "IndexMicrosecond.__or__()": "", "IndexMicrosecond.__pow__()": "", "IndexMicrosecond.__radd__()": "", "IndexMicrosecond.__rfloordiv__()": "", "IndexMicrosecond.__rmatmul__()": "", "IndexMicrosecond.__rmul__()": "", "IndexMicrosecond.__rshift__()": "", "IndexMicrosecond.__rsub__()": "", "IndexMicrosecond.__rtruediv__()": "", "IndexMicrosecond.__sub__()": "", "IndexMicrosecond.__truediv__()": "", "IndexMicrosecond.__xor__()": "", "IndexMicrosecond.__abs__()": "", "IndexMicrosecond.__invert__()": "", "IndexMicrosecond.__neg__()": "", "IndexMicrosecond.__pos__()": "", "IndexMicrosecond.via_values.apply()": "", "IndexMicrosecond.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexMicrosecond.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexMicrosecond.via_dt.year": "Return the year of each element.", "IndexMicrosecond.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexMicrosecond.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexMicrosecond.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexMicrosecond.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexMicrosecond.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexMicrosecond.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexMicrosecond.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexMicrosecond.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexMicrosecond.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexMicrosecond.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexMicrosecond.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexMicrosecond.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexMicrosecond.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexMicrosecond.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexMicrosecond.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexMicrosecond.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexMicrosecond.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexMicrosecond.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexMicrosecond.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexMicrosecond.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexMicrosecond.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexMicrosecond.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexMicrosecond.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexMicrosecond.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexMicrosecond.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMicrosecond.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexMicrosecond.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexMicrosecond.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMicrosecond.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexMicrosecond.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexMicrosecond.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexMicrosecond.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexMicrosecond.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexMicrosecond.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexMicrosecond.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexMicrosecond.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexMicrosecond.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexMicrosecond.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexMicrosecond.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexMicrosecond.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexMicrosecond.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexMicrosecond.via_str.len()": "Return the length of the string.", "IndexMicrosecond.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexMicrosecond.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexMicrosecond.via_str.partition()": "Partition each element around sep.", "IndexMicrosecond.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexMicrosecond.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexMicrosecond.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexMicrosecond.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexMicrosecond.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexMicrosecond.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexMicrosecond.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexMicrosecond.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexMicrosecond.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMicrosecond.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexMicrosecond.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMicrosecond.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMicrosecond.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMicrosecond.via_str.zfill()": "Return the string left-filled with zeros.", "IndexMicrosecond.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexMicrosecond.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexMicrosecond.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexMicrosecond.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexMicrosecond.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexMicrosecond.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexMicrosecond.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexMicrosecond.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexMicrosecond.via_hashlib().md5()": "", "IndexMicrosecond.via_hashlib().sha256()": "", "IndexMicrosecond.via_hashlib().sha512()": "", "IndexMicrosecond.via_hashlib().sha3_256()": "", "IndexMicrosecond.via_hashlib().sha3_512()": "", "IndexMicrosecond.via_hashlib().shake_128()": "", "IndexMicrosecond.via_hashlib().shake_256()": "", "IndexMicrosecond.via_hashlib().blake2b()": "", "IndexMicrosecond.via_hashlib().blake2s()": "", "IndexMicrosecondGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexMicrosecondGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexMicrosecondGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexMicrosecondGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexMicrosecondGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexMicrosecondGO.to_pandas()": "Return a Pandas Index.", "IndexMicrosecondGO.to_series()": "Return a Series with values from this Index's labels.", "IndexMicrosecondGO.to_visidata()": "Open an interactive VisiData session.", "IndexMicrosecondGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexMicrosecondGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexMicrosecondGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexMicrosecondGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexMicrosecondGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexMicrosecondGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexMicrosecondGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexMicrosecondGO.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexMicrosecondGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexMicrosecondGO.ndim": "Return the number of dimensions. Returns: int", "IndexMicrosecondGO.positions": "Return the immutable positions array.", "IndexMicrosecondGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexMicrosecondGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexMicrosecondGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexMicrosecondGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexMicrosecondGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexMicrosecondGO.__copy__()": "Return shallow copy of this Index.", "IndexMicrosecondGO.__deepcopy__()": "", "IndexMicrosecondGO.__len__()": "", "IndexMicrosecondGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexMicrosecondGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexMicrosecondGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resol...", "IndexMicrosecondGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexMicrosecondGO.copy()": "Return shallow copy of this Index.", "IndexMicrosecondGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexMicrosecondGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexMicrosecondGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexMicrosecondGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexMicrosecondGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexMicrosecondGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexMicrosecondGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexMicrosecondGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexMicrosecondGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexMicrosecondGO.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexMicrosecondGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexMicrosecondGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexMicrosecondGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexMicrosecondGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexMicrosecondGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexMicrosecondGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexMicrosecondGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexMicrosecondGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMicrosecondGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexMicrosecondGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexMicrosecondGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMicrosecondGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexMicrosecondGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexMicrosecondGO.rename()": "Return a new Frame with an updated name attribute.", "IndexMicrosecondGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexMicrosecondGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexMicrosecondGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexMicrosecondGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexMicrosecondGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexMicrosecondGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexMicrosecondGO.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexMicrosecondGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexMicrosecondGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexMicrosecondGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexMicrosecondGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexMicrosecondGO.__iter__()": "Iterate over labels.", "IndexMicrosecondGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexMicrosecondGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexMicrosecondGO.interface": "A Frame documenting the interface of this class.", "IndexMicrosecondGO.__repr__()": "", "IndexMicrosecondGO.__str__()": "Return str(self).", "IndexMicrosecondGO.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexMicrosecondGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexMicrosecondGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexMicrosecondGO.drop.iloc[]": "", "IndexMicrosecondGO.drop.loc[]": "", "IndexMicrosecondGO.[]": "Extract a new index given an iloc key.", "IndexMicrosecondGO.iloc[]": "", "IndexMicrosecondGO.loc[]": "", "IndexMicrosecondGO.iter_label()": "", "IndexMicrosecondGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexMicrosecondGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexMicrosecondGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexMicrosecondGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexMicrosecondGO.__add__()": "", "IndexMicrosecondGO.__and__()": "", "IndexMicrosecondGO.__eq__()": "", "IndexMicrosecondGO.__floordiv__()": "", "IndexMicrosecondGO.__ge__()": "", "IndexMicrosecondGO.__gt__()": "", "IndexMicrosecondGO.__le__()": "", "IndexMicrosecondGO.__lt__()": "", "IndexMicrosecondGO.__matmul__()": "", "IndexMicrosecondGO.__mod__()": "", "IndexMicrosecondGO.__mul__()": "", "IndexMicrosecondGO.__ne__()": "", "IndexMicrosecondGO.__or__()": "", "IndexMicrosecondGO.__pow__()": "", "IndexMicrosecondGO.__radd__()": "", "IndexMicrosecondGO.__rfloordiv__()": "", "IndexMicrosecondGO.__rmatmul__()": "", "IndexMicrosecondGO.__rmul__()": "", "IndexMicrosecondGO.__rshift__()": "", "IndexMicrosecondGO.__rsub__()": "", "IndexMicrosecondGO.__rtruediv__()": "", "IndexMicrosecondGO.__sub__()": "", "IndexMicrosecondGO.__truediv__()": "", "IndexMicrosecondGO.__xor__()": "", "IndexMicrosecondGO.__abs__()": "", "IndexMicrosecondGO.__invert__()": "", "IndexMicrosecondGO.__neg__()": "", "IndexMicrosecondGO.__pos__()": "", "IndexMicrosecondGO.via_values.apply()": "", "IndexMicrosecondGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexMicrosecondGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexMicrosecondGO.via_dt.year": "Return the year of each element.", "IndexMicrosecondGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexMicrosecondGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexMicrosecondGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexMicrosecondGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexMicrosecondGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexMicrosecondGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexMicrosecondGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexMicrosecondGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexMicrosecondGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexMicrosecondGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexMicrosecondGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexMicrosecondGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexMicrosecondGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexMicrosecondGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexMicrosecondGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexMicrosecondGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexMicrosecondGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexMicrosecondGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexMicrosecondGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexMicrosecondGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexMicrosecondGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexMicrosecondGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexMicrosecondGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexMicrosecondGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexMicrosecondGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMicrosecondGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexMicrosecondGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexMicrosecondGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMicrosecondGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexMicrosecondGO.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexMicrosecondGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexMicrosecondGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexMicrosecondGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexMicrosecondGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexMicrosecondGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexMicrosecondGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexMicrosecondGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexMicrosecondGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexMicrosecondGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexMicrosecondGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexMicrosecondGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexMicrosecondGO.via_str.len()": "Return the length of the string.", "IndexMicrosecondGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexMicrosecondGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexMicrosecondGO.via_str.partition()": "Partition each element around sep.", "IndexMicrosecondGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexMicrosecondGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexMicrosecondGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexMicrosecondGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexMicrosecondGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexMicrosecondGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexMicrosecondGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexMicrosecondGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexMicrosecondGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexMicrosecondGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexMicrosecondGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMicrosecondGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMicrosecondGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexMicrosecondGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexMicrosecondGO.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexMicrosecondGO.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexMicrosecondGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexMicrosecondGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexMicrosecondGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexMicrosecondGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexMicrosecondGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexMicrosecondGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexMicrosecondGO.via_hashlib().md5()": "", "IndexMicrosecondGO.via_hashlib().sha256()": "", "IndexMicrosecondGO.via_hashlib().sha512()": "", "IndexMicrosecondGO.via_hashlib().sha3_256()": "", "IndexMicrosecondGO.via_hashlib().sha3_512()": "", "IndexMicrosecondGO.via_hashlib().shake_128()": "", "IndexMicrosecondGO.via_hashlib().shake_256()": "", "IndexMicrosecondGO.via_hashlib().blake2b()": "", "IndexMicrosecondGO.via_hashlib().blake2s()": "", "IndexNanosecond.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexNanosecond.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexNanosecond.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexNanosecond.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexNanosecond.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexNanosecond.to_pandas()": "Return a Pandas Index.", "IndexNanosecond.to_series()": "Return a Series with values from this Index's labels.", "IndexNanosecond.to_visidata()": "Open an interactive VisiData session.", "IndexNanosecond.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexNanosecond.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexNanosecond.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexNanosecond.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexNanosecond.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexNanosecond.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexNanosecond.name": "A hashable label attached to this container. Returns: Hashable", "IndexNanosecond.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexNanosecond.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexNanosecond.ndim": "Return the number of dimensions. Returns: int", "IndexNanosecond.positions": "Return the immutable positions array.", "IndexNanosecond.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexNanosecond.size": "Return the size of the underlying NumPy array. Returns: int", "IndexNanosecond.__array__()": "Support the __array__ interface, returning an array of values.", "IndexNanosecond.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexNanosecond.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexNanosecond.__copy__()": "Return shallow copy of this Index.", "IndexNanosecond.__deepcopy__()": "", "IndexNanosecond.__len__()": "", "IndexNanosecond.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexNanosecond.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexNanosecond.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexNanosecond.copy()": "Return shallow copy of this Index.", "IndexNanosecond.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexNanosecond.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexNanosecond.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexNanosecond.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexNanosecond.dropna()": "Return a new Index after removing values of NaN or None.", "IndexNanosecond.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexNanosecond.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexNanosecond.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexNanosecond.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexNanosecond.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexNanosecond.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexNanosecond.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexNanosecond.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexNanosecond.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexNanosecond.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexNanosecond.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexNanosecond.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexNanosecond.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexNanosecond.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexNanosecond.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexNanosecond.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexNanosecond.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexNanosecond.rename()": "Return a new Frame with an updated name attribute.", "IndexNanosecond.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexNanosecond.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexNanosecond.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexNanosecond.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexNanosecond.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexNanosecond.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexNanosecond.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexNanosecond.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexNanosecond.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexNanosecond.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexNanosecond.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexNanosecond.__iter__()": "Iterate over labels.", "IndexNanosecond.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexNanosecond.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexNanosecond.interface": "A Frame documenting the interface of this class.", "IndexNanosecond.__repr__()": "", "IndexNanosecond.__str__()": "Return str(self).", "IndexNanosecond.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexNanosecond.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexNanosecond.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexNanosecond.drop.iloc[]": "", "IndexNanosecond.drop.loc[]": "", "IndexNanosecond.[]": "Extract a new index given an iloc key.", "IndexNanosecond.iloc[]": "", "IndexNanosecond.loc[]": "", "IndexNanosecond.iter_label()": "", "IndexNanosecond.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexNanosecond.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexNanosecond.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexNanosecond.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexNanosecond.__add__()": "", "IndexNanosecond.__and__()": "", "IndexNanosecond.__eq__()": "", "IndexNanosecond.__floordiv__()": "", "IndexNanosecond.__ge__()": "", "IndexNanosecond.__gt__()": "", "IndexNanosecond.__le__()": "", "IndexNanosecond.__lt__()": "", "IndexNanosecond.__matmul__()": "", "IndexNanosecond.__mod__()": "", "IndexNanosecond.__mul__()": "", "IndexNanosecond.__ne__()": "", "IndexNanosecond.__or__()": "", "IndexNanosecond.__pow__()": "", "IndexNanosecond.__radd__()": "", "IndexNanosecond.__rfloordiv__()": "", "IndexNanosecond.__rmatmul__()": "", "IndexNanosecond.__rmul__()": "", "IndexNanosecond.__rshift__()": "", "IndexNanosecond.__rsub__()": "", "IndexNanosecond.__rtruediv__()": "", "IndexNanosecond.__sub__()": "", "IndexNanosecond.__truediv__()": "", "IndexNanosecond.__xor__()": "", "IndexNanosecond.__abs__()": "", "IndexNanosecond.__invert__()": "", "IndexNanosecond.__neg__()": "", "IndexNanosecond.__pos__()": "", "IndexNanosecond.via_values.apply()": "", "IndexNanosecond.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexNanosecond.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexNanosecond.via_dt.year": "Return the year of each element.", "IndexNanosecond.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexNanosecond.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexNanosecond.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexNanosecond.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexNanosecond.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexNanosecond.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexNanosecond.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexNanosecond.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexNanosecond.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexNanosecond.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexNanosecond.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexNanosecond.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexNanosecond.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexNanosecond.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexNanosecond.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexNanosecond.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexNanosecond.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexNanosecond.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexNanosecond.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexNanosecond.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexNanosecond.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexNanosecond.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexNanosecond.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexNanosecond.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexNanosecond.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexNanosecond.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexNanosecond.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexNanosecond.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexNanosecond.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexNanosecond.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexNanosecond.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexNanosecond.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexNanosecond.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexNanosecond.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexNanosecond.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexNanosecond.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexNanosecond.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexNanosecond.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexNanosecond.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexNanosecond.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexNanosecond.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexNanosecond.via_str.len()": "Return the length of the string.", "IndexNanosecond.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexNanosecond.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexNanosecond.via_str.partition()": "Partition each element around sep.", "IndexNanosecond.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexNanosecond.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexNanosecond.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexNanosecond.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexNanosecond.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexNanosecond.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexNanosecond.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexNanosecond.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexNanosecond.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexNanosecond.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexNanosecond.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexNanosecond.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexNanosecond.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexNanosecond.via_str.zfill()": "Return the string left-filled with zeros.", "IndexNanosecond.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexNanosecond.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexNanosecond.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexNanosecond.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexNanosecond.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexNanosecond.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexNanosecond.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexNanosecond.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexNanosecond.via_hashlib().md5()": "", "IndexNanosecond.via_hashlib().sha256()": "", "IndexNanosecond.via_hashlib().sha512()": "", "IndexNanosecond.via_hashlib().sha3_256()": "", "IndexNanosecond.via_hashlib().sha3_512()": "", "IndexNanosecond.via_hashlib().shake_128()": "", "IndexNanosecond.via_hashlib().shake_256()": "", "IndexNanosecond.via_hashlib().blake2b()": "", "IndexNanosecond.via_hashlib().blake2s()": "", "IndexNanosecondGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index l...", "IndexNanosecondGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. P...", "IndexNanosecondGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexNanosecondGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and...", "IndexNanosecondGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS libr...", "IndexNanosecondGO.to_pandas()": "Return a Pandas Index.", "IndexNanosecondGO.to_series()": "Return a Series with values from this Index's labels.", "IndexNanosecondGO.to_visidata()": "Open an interactive VisiData session.", "IndexNanosecondGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "IndexNanosecondGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "IndexNanosecondGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexNanosecondGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexNanosecondGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compoun...", "IndexNanosecondGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexNanosecondGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexNanosecondGO.names": "Provide a suitable iterable of names for usage in output formats that require a...", "IndexNanosecondGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexNanosecondGO.ndim": "Return the number of dimensions. Returns: int", "IndexNanosecondGO.positions": "Return the immutable positions array.", "IndexNanosecondGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.T...", "IndexNanosecondGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexNanosecondGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexNanosecondGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexNanosecondGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truethy evaluation.", "IndexNanosecondGO.__copy__()": "Return shallow copy of this Index.", "IndexNanosecondGO.__deepcopy__()": "", "IndexNanosecondGO.__len__()": "", "IndexNanosecondGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting t...", "IndexNanosecondGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to...", "IndexNanosecondGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resol...", "IndexNanosecondGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is...", "IndexNanosecondGO.copy()": "Return shallow copy of this Index.", "IndexNanosecondGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, default...", "IndexNanosecondGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting...", "IndexNanosecondGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexNanosecondGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexNanosecondGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexNanosecondGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include e...", "IndexNanosecondGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexNanosecondGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value...", "IndexNanosecondGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args:...", "IndexNanosecondGO.head()": "Return a Index consisting only of the top elements as specified by count. Args:...", "IndexNanosecondGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion...", "IndexNanosecondGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identica...", "IndexNanosecondGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is...", "IndexNanosecondGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the count of that label f...", "IndexNanosecondGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to us...", "IndexNanosecondGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in...", "IndexNanosecondGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a B...", "IndexNanosecondGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexNanosecondGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0...", "IndexNanosecondGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis...", "IndexNanosecondGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexNanosecondGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axi...", "IndexNanosecondGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will b...", "IndexNanosecondGO.rename()": "Return a new Frame with an updated name attribute.", "IndexNanosecondGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive s...", "IndexNanosecondGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from th...", "IndexNanosecondGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in asc...", "IndexNanosecondGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, default...", "IndexNanosecondGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. ski...", "IndexNanosecondGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Arg...", "IndexNanosecondGO.union()": "Perform union with another Index, container, or NumPy array. Identical compariso...", "IndexNanosecondGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for...", "IndexNanosecondGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexNanosecondGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to ax...", "IndexNanosecondGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to...", "IndexNanosecondGO.__iter__()": "Iterate over labels.", "IndexNanosecondGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexNanosecondGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype...", "IndexNanosecondGO.interface": "A Frame documenting the interface of this class.", "IndexNanosecondGO.__repr__()": "", "IndexNanosecondGO.__str__()": "Return str(self).", "IndexNanosecondGO.display()": "Return a Display, capable of providing a string representation. Args: config: A...", "IndexNanosecondGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string...", "IndexNanosecondGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a strin...", "IndexNanosecondGO.drop.iloc[]": "", "IndexNanosecondGO.drop.loc[]": "", "IndexNanosecondGO.[]": "Extract a new index given an iloc key.", "IndexNanosecondGO.iloc[]": "", "IndexNanosecondGO.loc[]": "", "IndexNanosecondGO.iter_label()": "", "IndexNanosecondGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function...", "IndexNanosecondGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A f...", "IndexNanosecondGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args:...", "IndexNanosecondGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the Proce...", "IndexNanosecondGO.__add__()": "", "IndexNanosecondGO.__and__()": "", "IndexNanosecondGO.__eq__()": "", "IndexNanosecondGO.__floordiv__()": "", "IndexNanosecondGO.__ge__()": "", "IndexNanosecondGO.__gt__()": "", "IndexNanosecondGO.__le__()": "", "IndexNanosecondGO.__lt__()": "", "IndexNanosecondGO.__matmul__()": "", "IndexNanosecondGO.__mod__()": "", "IndexNanosecondGO.__mul__()": "", "IndexNanosecondGO.__ne__()": "", "IndexNanosecondGO.__or__()": "", "IndexNanosecondGO.__pow__()": "", "IndexNanosecondGO.__radd__()": "", "IndexNanosecondGO.__rfloordiv__()": "", "IndexNanosecondGO.__rmatmul__()": "", "IndexNanosecondGO.__rmul__()": "", "IndexNanosecondGO.__rshift__()": "", "IndexNanosecondGO.__rsub__()": "", "IndexNanosecondGO.__rtruediv__()": "", "IndexNanosecondGO.__sub__()": "", "IndexNanosecondGO.__truediv__()": "", "IndexNanosecondGO.__xor__()": "", "IndexNanosecondGO.__abs__()": "", "IndexNanosecondGO.__invert__()": "", "IndexNanosecondGO.__neg__()": "", "IndexNanosecondGO.__pos__()": "", "IndexNanosecondGO.via_values.apply()": "", "IndexNanosecondGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arr...", "IndexNanosecondGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify...", "IndexNanosecondGO.via_dt.year": "Return the year of each element.", "IndexNanosecondGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexNanosecondGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexNanosecondGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given mo...", "IndexNanosecondGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexNanosecondGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexNanosecondGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexNanosecondGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexNanosecondGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is qua...", "IndexNanosecondGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexNanosecondGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexNanosecondGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexNanosecondGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexNanosecondGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexNanosecondGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexNanosecondGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexNanosecondGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexNanosecondGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexNanosecondGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexNanosecondGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexNanosecondGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexNanosecondGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexNanosecondGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexNanosecondGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexNanosecondGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexNanosecondGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexNanosecondGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexNanosecondGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexNanosecondGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexNanosecondGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is f...", "IndexNanosecondGO.via_str.format()": "For each element, return a string resulting from calling the string format argum...", "IndexNanosecondGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexNanosecondGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric a...", "IndexNanosecondGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and...", "IndexNanosecondGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the elemen...", "IndexNanosecondGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and the...", "IndexNanosecondGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercas...", "IndexNanosecondGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in th...", "IndexNanosecondGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the str...", "IndexNanosecondGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is...", "IndexNanosecondGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercas...", "IndexNanosecondGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexNanosecondGO.via_str.len()": "Return the length of the string.", "IndexNanosecondGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexNanosecondGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexNanosecondGO.via_str.partition()": "Partition each element around sep.", "IndexNanosecondGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexNanosecondGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is...", "IndexNanosecondGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexNanosecondGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexNanosecondGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexNanosecondGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexNanosecondGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexNanosecondGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the de...", "IndexNanosecondGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring...", "IndexNanosecondGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed...", "IndexNanosecondGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexNanosecondGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexNanosecondGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice ver...", "IndexNanosecondGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexNanosecondGO.via_re().search()": "Scan through string looking for the first location where this regular expression...", "IndexNanosecondGO.via_re().match()": "If zero or more characters at the beginning of string match this regular express...", "IndexNanosecondGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. No...", "IndexNanosecondGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in...", "IndexNanosecondGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings....", "IndexNanosecondGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences...", "IndexNanosecondGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_s...", "IndexNanosecondGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptogr...", "IndexNanosecondGO.via_hashlib().md5()": "", "IndexNanosecondGO.via_hashlib().sha256()": "", "IndexNanosecondGO.via_hashlib().sha512()": "", "IndexNanosecondGO.via_hashlib().sha3_256()": "", "IndexNanosecondGO.via_hashlib().sha3_512()": "", "IndexNanosecondGO.via_hashlib().shake_128()": "", "IndexNanosecondGO.via_hashlib().shake_256()": "", "IndexNanosecondGO.via_hashlib().blake2b()": "", "IndexNanosecondGO.via_hashlib().blake2s()": "", "HLoc.__init__()": "", "HLoc.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "HLoc.key": "Built-in immutable sequence. If no argument is given, the constructor returns an...", "HLoc.__len__()": "", "HLoc.__iter__()": "", "HLoc.__repr__()": "", "HLoc.__str__()": "Return str(self).", "ILoc.__init__()": "", "ILoc.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "ILoc.key": "Built-in immutable sequence. If no argument is given, the constructor returns an...", "ILoc.__repr__()": "", "ILoc.__str__()": "Return str(self).", "WWW.__init__()": "Initialize self. See help(type(self)) for accurate signature.", "WWW.from_file()": "Given a URL, return a loadable component, either as an in-memory store (a String...", "WWW.from_gzip()": "Given a URL, return a loadable component, either as an in-memory store (a String...", "WWW.from_zip()": "Given a URL, return a loadable component, either as an in-memory store (a String...", "WWW.__repr__()": "Return repr(self).", "WWW.__str__()": "Return str(self).", "FillValueAuto.__init__()": "Args: b: fill value for bool kind i: fill value for integer kind u: fill value f...", "FillValueAuto.from_default()": "Create a FileValueAuto instance based on a default selected to prohibit type coe...", "FillValueAuto.M": "The base class of the class hierarchy. When called, it accepts no arguments and...", "FillValueAuto.O": "The base class of the class hierarchy. When called, it accepts no arguments and...", "FillValueAuto.S": "The base class of the class hierarchy. When called, it accepts no arguments and...", "FillValueAuto.U": "The base class of the class hierarchy. When called, it accepts no arguments and...", "FillValueAuto.V": "The base class of the class hierarchy. When called, it accepts no arguments and...", "FillValueAuto.b": "Built-in immutable sequence. If no argument is given, the constructor returns an...", "FillValueAuto.c": "The base class of the class hierarchy. When called, it accepts no arguments and...", "FillValueAuto.f": "The base class of the class hierarchy. When called, it accepts no arguments and...", "FillValueAuto.i": "The base class of the class hierarchy. When called, it accepts no arguments and...", "FillValueAuto.m": "The base class of the class hierarchy. When called, it accepts no arguments and...", "FillValueAuto.u": "The base class of the class hierarchy. When called, it accepts no arguments and...", "FillValueAuto.__repr__()": "Return repr(self).", "FillValueAuto.__str__()": "Return str(self).", "FillValueAuto.[]": "", "DisplayActive.__init__()": "Initialize self. See help(type(self)) for accurate signature.", "DisplayActive.FILE_NAME": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a...", "DisplayActive.read()": "", "DisplayActive.set()": "", "DisplayActive.update()": "", "DisplayActive.write()": "", "DisplayActive.get()": "", "DisplayActive.__repr__()": "Return repr(self).", "DisplayActive.__str__()": "Return str(self).", "DisplayConfig.__init__()": "", "DisplayConfig.from_default()": "", "DisplayConfig.from_file()": "", "DisplayConfig.from_json()": "", "DisplayConfig.to_dict()": "", "DisplayConfig.to_display_config()": "", "DisplayConfig.to_json()": "", "DisplayConfig.to_transpose()": "", "DisplayConfig.cell_align_left": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "DisplayConfig.cell_max_width": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.cell_max_width_leftmost": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.cell_placeholder": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a...", "DisplayConfig.display_columns": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.display_format": "Define display output format.", "DisplayConfig.display_rows": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.include_columns": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "DisplayConfig.include_index": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "DisplayConfig.type_color": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "DisplayConfig.type_color_bool": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.type_color_bus": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.type_color_complex": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.type_color_datetime": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.type_color_default": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.type_color_float": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.type_color_frame": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.type_color_index": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.type_color_int": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.type_color_object": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.type_color_quilt": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.type_color_series": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.type_color_str": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.type_color_timedelta": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "DisplayConfig.type_delimiter_left": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a...", "DisplayConfig.type_delimiter_right": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a...", "DisplayConfig.type_show": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "DisplayConfig.value_format_complex_positional": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a...", "DisplayConfig.value_format_complex_scientific": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a...", "DisplayConfig.value_format_float_positional": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a...", "DisplayConfig.value_format_float_scientific": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a...", "DisplayConfig.write()": "Write a JSON file.", "DisplayConfig.interface": "A Frame documenting the interface of this class.", "DisplayConfig.__repr__()": "", "DisplayConfig.__str__()": "Return str(self).", "StoreConfig.__init__()": "", "StoreConfig.from_frame()": "Derive a config from a Frame.", "StoreConfig.to_store_config_he()": "Return a StoreConfigHE version of this StoreConfig.", "StoreConfig.columns_constructors": "", "StoreConfig.columns_depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "StoreConfig.columns_name_depth_level": "", "StoreConfig.columns_select": "", "StoreConfig.consolidate_blocks": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "StoreConfig.dtypes": "", "StoreConfig.include_columns": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "StoreConfig.include_columns_name": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "StoreConfig.include_index": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "StoreConfig.include_index_name": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "StoreConfig.index_constructors": "", "StoreConfig.index_depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "StoreConfig.index_name_depth_level": "", "StoreConfig.label_decoder": "", "StoreConfig.label_encoder": "", "StoreConfig.merge_hierarchical_labels": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "StoreConfig.read_chunksize": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "StoreConfig.read_max_workers": "", "StoreConfig.skip_footer": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "StoreConfig.skip_header": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "StoreConfig.trim_nadir": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The b...", "StoreConfig.write_chunksize": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an...", "StoreConfig.write_max_workers": "", "StoreConfig.label_decode()": "", "StoreConfig.label_encode()": "", "StoreConfig.interface": "A Frame documenting the interface of this class.", "StoreConfig.__repr__()": "Return repr(self).", "StoreConfig.__str__()": "Return str(self).", "StoreFilter.__init__()": "", "StoreFilter.from_type_filter_array()": "Given an array, replace types with strings", "StoreFilter.from_type_filter_element()": "Filter single values to string.", "StoreFilter.to_type_filter_array()": "Given an array, replace strings with types.", "StoreFilter.to_type_filter_element()": "Given a value wich may be an encoded string, decode into a type.", "StoreFilter.from_nan": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a...", "StoreFilter.from_nat": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a...", "StoreFilter.from_neginf": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a...", "StoreFilter.from_none": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a...", "StoreFilter.from_posinf": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a...", "StoreFilter.to_nan": "frozenset() -> empty frozenset object frozenset(iterable) -> frozenset object Bu...", "StoreFilter.to_nat": "frozenset() -> empty frozenset object frozenset(iterable) -> frozenset object Bu...", "StoreFilter.to_neginf": "frozenset() -> empty frozenset object frozenset(iterable) -> frozenset object Bu...", "StoreFilter.to_none": "frozenset() -> empty frozenset object frozenset(iterable) -> frozenset object Bu...", "StoreFilter.to_posinf": "frozenset() -> empty frozenset object frozenset(iterable) -> frozenset object Bu...", "StoreFilter.value_format_complex_positional": "", "StoreFilter.value_format_complex_scientific": "", "StoreFilter.value_format_float_positional": "", "StoreFilter.value_format_float_scientific": "", "StoreFilter.interface": "A Frame documenting the interface of this class.", "StoreFilter.__repr__()": "Return repr(self).", "StoreFilter.__str__()": "Return str(self).", "IndexAutoFactory.__init__()": "", "IndexAutoFactory.from_optional_constructor()": "", "IndexAutoFactory.to_index()": "Called by index_from_optional_constructor.", "IndexAutoFactory.__repr__()": "Return repr(self).", "IndexAutoFactory.__str__()": "Return str(self).", "IndexDefaultConstructorFactory.__init__()": "", "IndexDefaultConstructorFactory.__call__()": "Call the passed constructor with the name.", "IndexDefaultConstructorFactory.__repr__()": "Return repr(self).", "IndexDefaultConstructorFactory.__str__()": "Return str(self).", "IndexAutoConstructorFactory.__init__()": "", "IndexAutoConstructorFactory.to_index()": "Create and return the Index based on the array dtype", "IndexAutoConstructorFactory.__call__()": "Call the passeed constructor with the name.", "IndexAutoConstructorFactory.__repr__()": "Return repr(self).", "IndexAutoConstructorFactory.__str__()": "Return str(self).", "NPZ.__init__()": "", "NPZ.from_arrays()": "Given an iterable of arrays, write out an NPZ or NPY directly, without building...", "NPZ.from_frames()": "Given an iterable of Frames, write out an NPZ or NPY directly, without building...", "NPZ.contents": "Return a Frame indicating name, dtype, shape, and bytes, of Archive components.", "NPZ.nbytes": "Return numer of bytes stored in this archive.", "NPZ.__enter__()": "When entering a context manager, a handle to this instance is returned.", "NPZ.__exit__()": "When exiting a context manager, resources are closed as necessary.", "NPZ.interface": "A Frame documenting the interface of this class.", "NPZ.__repr__()": "Return repr(self).", "NPZ.__str__()": "Return str(self).", "NPY.__init__()": "", "NPY.from_arrays()": "Given an iterable of arrays, write out an NPZ or NPY directly, without building...", "NPY.from_frames()": "Given an iterable of Frames, write out an NPZ or NPY directly, without building...", "NPY.contents": "Return a Frame indicating name, dtype, shape, and bytes, of Archive components.", "NPY.nbytes": "Return numer of bytes stored in this archive.", "NPY.__enter__()": "When entering a context manager, a handle to this instance is returned.", "NPY.__exit__()": "When exiting a context manager, resources are closed as necessary.", "NPY.interface": "A Frame documenting the interface of this class.", "NPY.__repr__()": "Return repr(self).", "NPY.__str__()": "Return str(self).", "MemoryDisplay.__init__()": "Initialize an instance with a Frame of byte counts.", "MemoryDisplay.from_any()": "Given any slotted object, return a MemoryDisplay instance.", "MemoryDisplay.to_frame()": "Return a Frame of byte counts.", "MemoryDisplay.__repr__()": "", "MemoryDisplay.__str__()": "Return str(self).", "Platform.__init__()": "Initialize self. See help(type(self)) for accurate signature.", "Platform.to_series()": "", "Platform.__repr__()": "Return repr(self).", "Platform.__str__()": "Return str(self).", "Platform.display()": ""}