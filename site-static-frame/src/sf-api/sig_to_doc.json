{"Series.__init__()": "Initializer. Args: values: An iterable of values to be aligned with the supplied (or automatically generated) index. index: Optional index initializer. If provided in addition to data values, lengths must be compatible. name: dtype: index_constructor: own_index: Flag the passed index as ownable by this Series. Primarily used by internal clients.", "Series.from_concat()": "Concatenate multiple Series into a new Series. Args: containers: Iterable of Series from which values in the new Series are drawn. index: If None, the resultant index will be the concatenation of all indices (assuming they are unique in combination). If IndexAutoFactory, the resultant index is a auto-incremented integer index. Otherwise, the value is used as a index initializer. index_constructor: name: Returns: Series", "Series.from_concat_items()": "Produce a Series with a hierarchical index from an iterable of pairs of labels, Series. The IndexHierarchy is formed from the provided labels and the Index if each Series. Args: items: Iterable of pairs of label, Series Returns: Series", "Series.from_delimited()": "Series construction from a delimited string. Args: dtype: if None, dtype will be inferred.", "Series.from_dict()": "Series construction from a dictionary, where the first pair value is the index and the second is the value. Args: mapping: a dictionary or similar mapping interface. dtype: dtype or valid dtype specifier. Returns: Series", "Series.from_element()": "Create a Series from a single element. The size of the resultant container will be determined by the index argument. Returns: Series", "Series.from_items()": "Series construction from an iterator or generator of pairs, where the first pair value is the index and the second is the value. Args: pairs: Iterable of pairs of index, value. dtype: dtype or valid dtype specifier. name: index_constructor: Returns: Series", "Series.from_overlay()": "Return a new Series made by overlaying containers, aligned values are filled with values from subsequent containers with left-to-right precedence. Values are filled based on a passed function that must return a Boolean array. By default, that function is isna_array, returning True for missing values (NaN and None). Args: containers: Iterable of Series. * index: An Index or IndexHierarchy, or index initializer, to be used as the index upon which all containers are aligned. IndexAutoFactory is not supported. union: If True, and no index argument is supplied, a union index from containers will be used; if False, the intersection index will be used. name: func: fill_value:", "Series.from_pandas()": "Given a Pandas Series, return a Series. Args: value: Pandas Series. * index_constructor: name: own_data: If True, the underlying NumPy data array will be made immutable and used without a copy. Returns: Series", "Series.to_frame()": "Return a Frame view of this Series. As underlying data is immutable, this is a no-copy operation. Args: axis: Axis 1 (default) creates a single-column Frame with the same index: axis 0 creates a single-row Frame with the index as columns. * index_constructor: columns_constructor: name: Returns: Frame", "Series.to_frame_go()": "Return FrameGO view of this Series. As underlying data is immutable, this is a no-copy operation. Args: axis: * index_constructor: columns_constructor: Returns: FrameGO", "Series.to_frame_he()": "Return FrameHE view of this Series. As underlying data is immutable, this is a no-copy operation. Args: axis: * index_constructor: columns_constructor: Returns: FrameHE", "Series.to_html()": "Return an HTML table representation of this Series using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "Series.to_html_datatables()": "Return a complete HTML representation of this Series using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "Series.to_pairs()": "Return a tuple of tuples, where each inner tuple is a pair of index label, value. Returns: tp.Iterable[tp.Tuple[TLabel, tp.Any]]", "Series.to_pandas()": "Return a Pandas Series. Returns: pandas.Series", "Series.to_series_he()": "Return a SeriesHE from this Series.", "Series.to_visidata()": "Open an interactive VisiData session.", "Series.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "Series.T": "Transpose. For a 1D immutable container, this returns a reference to self. Returns: Series", "Series.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "Series.index": "The index instance assigned to this container. Returns: Index", "Series.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "Series.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "Series.name": "A hashable label attached to this container. Returns: Hashable", "Series.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "Series.ndim": "Return the number of dimensions, which for a Series is always 1. Returns: int", "Series.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: Tuple[int]", "Series.size": "Return the size of the underlying NumPy array. Returns: int", "Series.__array__()": "Support the __array__ interface, returning an array of values.", "Series.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "Series.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "Series.__deepcopy__()": "", "Series.__len__()": "Length of values.", "Series.__round__()": "Return a Series rounded to the given decimals. Negative decimals round to the left of the decimal point. Args: decimals: number of decimals to round to. Returns: Series", "Series.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Series.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Series.astype()": "Return a Series with type determined by dtype argument. Note that for Series, this is a simple function, whereas for Frame, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. Returns: Series", "Series.clip()": "Apply a clip operation to this Series. Note that clip operations can be applied to object types, but cannot be applied to non-numerical objects (e.g., strings, None) Args: lower: value or Series to define the inclusive lower bound. upper: value or Series to define the inclusive upper bound. Returns: Series", "Series.corr()": "Return the index-aligned correlation to the supplied Series. Args: other: Series to be correlated with by selection on corresponding labels.", "Series.count()": "Return the count of non-NA, non-falsy, and/or unique elements. Args: skipna: skip NA (NaN, None) values. skipfalsy: skip falsu values (0, '', False, None, NaN) unique: Count unique items after optionally applying skipna or skipfalsy removals.", "Series.cov()": "Return the index-aligned covariance to the supplied Series. Args: ddof: Delta degrees of freedom, defaults to 1.", "Series.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Series.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Series.drop_duplicated()": "Return a Series with duplicated values removed. Args: exclude_first: Boolean to select if the first duplicated value is excluded. exclude_last: Boolean to select if the last duplicated value is excluded. Returns: Series", "Series.dropfalsy()": "Return a new Series after removing values of falsy.", "Series.dropna()": "Return a new Series after removing values of NaN or None.", "Series.duplicated()": "Return a same-sized Boolean Series that shows True for all values that are duplicated. Args: exclude_first: Boolean to select if the first duplicated value is excluded. exclude_last: Boolean to select if the last duplicated value is excluded. Returns: numpy.ndarray", "Series.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "Series.fillfalsy()": "Return a new Series after replacing falsy values with the supplied value. The value can be an element or Series. Args: value: Value to be used to replace missing values (NaN or None).", "Series.fillfalsy_backward()": "Return a new Series after feeding backward the last non-falsy observation across contiguous falsy values. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit.", "Series.fillfalsy_forward()": "Return a new Series after feeding forward the last non-falsy observation across contiguous falsy values. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit.", "Series.fillfalsy_leading()": "Return a new Series after filling leading (and only leading) falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "Series.fillfalsy_trailing()": "Return a new Series after filling trailing (and only trailing) falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "Series.fillna()": "Return a new Series after replacing NA (NaN or None) with the supplied value. The value can be an element or Series. Args: value: Value to be used to replace missing values (NaN or None).", "Series.fillna_backward()": "Return a new Series after feeding backward the last non-null (NaN or None) observation across contiguous nulls. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit.", "Series.fillna_forward()": "Return a new Series after feeding forward the last non-null (NaN or None) observation across contiguous nulls. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit.", "Series.fillna_leading()": "Return a new Series after filling leading (and only leading) null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "Series.fillna_trailing()": "Return a new Series after filling trailing (and only trailing) null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "Series.head()": "Return a Series consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Series Returns: Series", "Series.iloc_max()": "Return the integer index corresponding to the maximum value. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. Returns: int", "Series.iloc_min()": "Return the integer index corresponding to the minimum value found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. Returns: int", "Series.iloc_notfalsy_first()": "Return the position corresponding to the first non-falsy (including nan) value found. Args: {fill_value} Returns: TLabel", "Series.iloc_notfalsy_last()": "Return the position corresponding to the last non-falsy (including nan) value found. Args: {fill_value} Returns: TLabel", "Series.iloc_notna_first()": "Return the position corresponding to the first not NA (None or nan) value found. Args: {fill_value} Returns: TLabel", "Series.iloc_notna_last()": "Return the position corresponding to the last not NA (None or nan) value found. Args: {fill_value} Returns: TLabel", "Series.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "Series.insert_after()": "Create a new Series by inserting a Series at the position after the label specified by key. Args: key: Label after which the new container will be inserted. container: Container to be inserted. Returns: Series", "Series.insert_before()": "Create a new Series by inserting a Series at the position before the label specified by key. Args: key: Label before which the new container will be inserted. container: Container to be inserted. Returns: Series", "Series.isfalsy()": "Return a same-indexed, Boolean Series indicating which values are falsy.", "Series.isin()": "Return a same-sized Boolean Series that shows if the same-positioned element is in the iterable passed to the function. Returns: Series", "Series.isna()": "Return a same-indexed, Boolean Series indicating which values are NaN or None.", "Series.loc_max()": "Return the label corresponding to the maximum value found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. Returns: TLabel", "Series.loc_min()": "Return the label corresponding to the minimum value found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. Returns: TLabel", "Series.loc_notfalsy_first()": "Return the label corresponding to the first non-falsy (including nan) value found. Args: {fill_value} Returns: TLabel", "Series.loc_notfalsy_last()": "Return the label corresponding to the last non-falsy (including nan) value found. Args: {fill_value} Returns: TLabel", "Series.loc_notna_first()": "Return the label corresponding to the first not NA (None or nan) value found. Args: {fill_value} Returns: TLabel", "Series.loc_notna_last()": "Return the label corresponding to the last not NA (None or nan) value found. Args: {fill_value} Returns: TLabel", "Series.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "Series.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Series.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Series.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Series.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Series.notfalsy()": "Return a same-indexed, Boolean Series indicating which values are falsy.", "Series.notna()": "Return a same-indexed, Boolean Series indicating which values are NaN or None.", "Series.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Series.rank_dense()": "Rank values as compactly as possible, where ties get the same value, and ranks are contiguous (potentially non-unique) integers. Args: skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: If True, the lowest ranks correspond to the lowest values. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Series", "Series.rank_max()": "Rank values where tied values are assigned the maximum ordinal rank; ranks are potentially non-contiguous and non-unique integers. Args: skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: If True, the lowest ranks correspond to the lowest values. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Series", "Series.rank_mean()": "Rank values where tied values are assigned the mean of the ordinal ranks; ranks are potentially non-contiguous and non-unique floats. Args: skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: If True, the lowest ranks correspond to the lowest values. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Series", "Series.rank_min()": "Rank values where tied values are assigned the minimum ordinal rank; ranks are potentially non-contiguous and non-unique integers. Args: skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: If True, the lowest ranks correspond to the lowest values. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Series", "Series.rank_ordinal()": "Rank values distinctly, where ties get distinct values that maintain their ordering, and ranks are contiguous unique integers. Args: skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: If True, the lowest ranks correspond to the lowest values. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Series", "Series.rehierarch()": "Return a new Series with new a hierarchy based on the supplied depth_map.", "Series.reindex()": "Return a new Series with labels defined by the provided index. The size and ordering of the data is determined by the newly provided index, where data will continue to be aligned under labels found in both the new and the old index. Labels found only in the new index will be filled with fill_value. Args: index: An iterable of unique, hashable values, or another Index or IndexHierarchy, to be used as the labels of the index. columns: An iterable of unique, hashable values, or another Index or IndexHierarchy, to be used as the labels of the index. fill_value: A value to be used to fill space created by a new index that has values not found in the previous index. own_index: Flag the passed index as ownable by this Series. Primarily used by internal clients.", "Series.relabel()": "Return a new Series with transformed labels on the index. The size and ordering of the data is never changed in a relabeling operation. The resulting index must be unique. Args: index: One of the following types, used to create new index labels with the same size as the previous index. (a) A mapping (as a dictionary or Series), used to lookup and transform the labels in the previous index. Labels not found in the mapping will be reused. (b) A function, returning a hashable, that is applied to each label in the previous index. (c) The IndexAutoFactory type, to apply auto-incremented integer labels. (d) An Index initializer, i.e., either an iterable of hashables or an Index instance.", "Series.relabel_flat()": "Return a new Series, where an IndexHierarchy (if defined) is replaced with a flat, one-dimension index of tuples.", "Series.relabel_level_add()": "Return a new Series, adding a new root level to an existing IndexHierarchy, or creating an IndexHierarchy if one is not yet defined. Args: level: A hashable value to be used as a new root level, extending or creating an IndexHierarchy", "Series.relabel_level_drop()": "Return a new Series, dropping one or more levels from a either the root or the leaves of an IndexHierarchy. The resulting index must be unique. Args: count: A positive integer drops that many outer-most (root) levels; a negative integer drops that many inner-most (leaf)levels.", "Series.rename()": "Return a new Series with an updated name attribute.", "Series.roll()": "Return a Series with values rotated forward and wrapped around the index (with a positive shift) or backward and wrapped around the index (with a negative shift). Args: shift: Positive or negative integer shift. include_index: Determine if the Index is shifted with the underlying data. Returns: Series", "Series.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "Series.shift()": "Return a Series with values shifted forward on the index (with a positive shift) or backward on the index (with a negative shift). Args: shift: Positive or negative integer shift. fill_value: Value to be used to fill data missing after the shift. Returns: Series", "Series.sort_index()": "Return a new Series ordered by the sorted Index. Args: * ascendings: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by. Returns: Series", "Series.sort_values()": "Return a new Series ordered by the sorted values. Args: * ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by. Returns: Series", "Series.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Series.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Series.tail()": "Return a Series consisting only of the bottom elements as specified by count. s Args: count: Number of elements to be returned from the bottom of the Series Returns: Series", "Series.transpose()": "Transpose. For a 1D immutable container, this returns a reference to self. Returns: Series", "Series.unique()": "Return a NumPy array of unique values. Returns: numpy.ndarray", "Series.unique_enumerated()": "Given a collection of values, return two NumPy arrays: the first provides index positions for lookup of observed values; the second provides those observed, unique, values. Sometimes called \"factorize\". Args: retain_order: Boolean. If True, observed order is retained. If False, order may be sorted or observed, depending on the dtype and values. Retaining order may decrease performance. func: A callable that takes an element and returns a Boolean if that element should be treated as missing, excluded from the unique value collection, and given a -1 indexer position. The NumPy function np.isnan or the StaticFrame sf.isna_element are examples of suitable functions.", "Series.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Series.__contains__()": "Inclusion of value in index labels. Returns: bool", "Series.__iter__()": "Iterator of index labels, same as Series.keys. Returns: Iterator[Hashasble]", "Series.__reversed__()": "Returns a reverse iterator on the series' index. Returns: Index", "Series.get()": "Return the value found at the index key, else the default if the key is not found. Returns: Any", "Series.items()": "Iterator of pairs of index label and value. Returns: Iterator[Tuple[Hashable, Any]]", "Series.keys()": "Iterator of index labels. Returns: Iterator[TLabel]", "Series.values": "ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array, zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method (ndarray(...)) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters ---------- (for the __new__ method; see Notes below) shape : tuple of ints Shape of created array. dtype : data-type, optional Any object that can be interpreted as a numpy data type. buffer : object exposing buffer interface, optional Used to fill the array with data. offset : int, optional Offset of array data in buffer. strides : tuple of ints, optional Strides of data in memory. order : {'C', 'F'}, optional Row-major (C-style) or column-major (Fortran-style) order. Attributes ---------- T : ndarray Transpose of the array. data : buffer The array's elements, in memory. dtype : dtype object Describes the format of the elements in the array. flags : dict Dictionary containing information related to memory use, e.g., 'C_CONTIGUOUS', 'OWNDATA', 'WRITEABLE', etc. flat : numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag : ndarray Imaginary part of the array. real : ndarray Real part of the array. size : int Number of elements in the array. itemsize : int The memory use of each array element in bytes. nbytes : int The total number of bytes required to store the array data, i.e., itemsize * size. ndim : int The array's number of dimensions. shape : tuple of ints Shape of the array. strides : tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2). This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time (2 * 4). ctypes : ctypes object Class containing properties of the array needed for interaction with ctypes. base : ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also -------- array : Construct an array. zeros : Create an array, each element of which is zero. empty : Create an array, but leave its allocated memory unchanged (i.e., it contains \"garbage\"). dtype : Create a data-type. numpy.typing.NDArray : An ndarray alias :term:generic <generic type> w.r.t. its dtype.type <numpy.dtype.type>. Notes ----- There are two modes of creating an array using __new__: 1. If buffer is None, then only shape, dtype, and order are used. 2. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples -------- These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3])", "Series.interface": "A Frame documenting the interface of this class.", "Series.__repr__()": "", "Series.__str__()": "Return str(self).", "Series.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Series.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Series.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Series.assign[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "Series.assign[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. *. fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Series.assign[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Series.assign[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Series.assign.iloc[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "Series.assign.iloc[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. *. fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Series.assign.iloc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Series.assign.iloc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Series.assign.loc[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "Series.assign.loc[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. *. fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Series.assign.loc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Series.assign.loc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Series.drop[]": "Label-based selection.", "Series.drop.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "Series.drop.loc[]": "", "Series.mask[]": "Label-based selection.", "Series.mask.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "Series.mask.loc[]": "", "Series.masked_array[]": "Label-based selection.", "Series.masked_array.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "Series.masked_array.loc[]": "", "Series.[]": "Selector of values by label. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array. Compatibility: Pandas supports using both loc and iloc style selections with the __getitem__ interface on Series. This is undesirable, so here we only expose the loc interface (making the Series dictionary like, but unlike the Index, where __getitem__ is an iloc).", "Series.iloc[]": "Interface for position-based selection.", "Series.loc[]": "Interface for label-based selection.", "Series.iter_element()": "Iterator of elements.", "Series.iter_element().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_element().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_element().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_element().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_element().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_element().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "Series.iter_element().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "Series.iter_element().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_element().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "Series.iter_element().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "Series.iter_element().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_element().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "Series.iter_element().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "Series.iter_element_items()": "Iterator of label, element pairs.", "Series.iter_element_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_element_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_element_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_element_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_element_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_element_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "Series.iter_element_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "Series.iter_element_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_element_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "Series.iter_element_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "Series.iter_element_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_element_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "Series.iter_element_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "Series.iter_group()": "Iterator of Series, where each Series matches unique values.", "Series.iter_group().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_group().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_group().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_group().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_group_array()": "Iterator of Series, where each Series matches unique values.", "Series.iter_group_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_group_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_group_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_group_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_group_array_items()": "", "Series.iter_group_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_group_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_group_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_group_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_group_items()": "", "Series.iter_group_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_group_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_group_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_group_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_group_labels()": "", "Series.iter_group_labels().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_group_labels().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_group_labels().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_group_labels().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_group_labels_array()": "", "Series.iter_group_labels_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_group_labels_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_group_labels_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_group_labels_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_group_labels_array_items()": "", "Series.iter_group_labels_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_group_labels_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_group_labels_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_group_labels_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_group_labels_items()": "", "Series.iter_group_labels_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_group_labels_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_group_labels_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_group_labels_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_group_other()": "Iterator of Series, grouped by unique values found in the passed container.", "Series.iter_group_other().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_group_other().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_group_other().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_group_other().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_group_other_array()": "", "Series.iter_group_other_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_group_other_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_group_other_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_group_other_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_group_other_array_items()": "", "Series.iter_group_other_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_group_other_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_group_other_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_group_other_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_group_other_items()": "Iterator of pairs of label, Series, grouped by unique values found in the passed container.", "Series.iter_group_other_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_group_other_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_group_other_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_group_other_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_window()": "", "Series.iter_window().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_window().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_window().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_window().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_window_array()": "", "Series.iter_window_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_window_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_window_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_window_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_window_array_items()": "", "Series.iter_window_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_window_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_window_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_window_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.iter_window_items()": "", "Series.iter_window_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Series.iter_window_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Series.iter_window_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Series.iter_window_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Series.__add__()": "", "Series.__and__()": "", "Series.__eq__()": "", "Series.__floordiv__()": "", "Series.__ge__()": "", "Series.__gt__()": "", "Series.__le__()": "", "Series.__lt__()": "", "Series.__matmul__()": "", "Series.__mod__()": "", "Series.__mul__()": "", "Series.__ne__()": "", "Series.__or__()": "", "Series.__pow__()": "", "Series.__radd__()": "", "Series.__rfloordiv__()": "", "Series.__rmatmul__()": "", "Series.__rmul__()": "", "Series.__rshift__()": "", "Series.__rsub__()": "", "Series.__rtruediv__()": "", "Series.__sub__()": "", "Series.__truediv__()": "", "Series.__xor__()": "", "Series.__abs__()": "", "Series.__invert__()": "", "Series.__neg__()": "", "Series.__pos__()": "", "Series.abs()": "", "Series.via_values.apply()": "", "Series.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "Series.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "Series.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "Series.via_dt.year": "Return the year of each element.", "Series.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "Series.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "Series.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "Series.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "Series.via_dt.hour": "Return the hour of each element, between 0 and 24.", "Series.via_dt.minute": "Return the minute of each element, between 0 and 60.", "Series.via_dt.second": "Return the second of each element, between 0 and 60.", "Series.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "Series.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "Series.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "Series.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "Series.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "Series.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "Series.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "Series.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "Series.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "Series.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "Series.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "Series.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "Series.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "Series.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "Series.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "Series.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "Series.via_str.center()": "Return a container with its elements centered in a string of length width.", "Series.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "Series.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "Series.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "Series.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "Series.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "Series.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "Series.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "Series.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "Series.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "Series.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "Series.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "Series.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "Series.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "Series.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "Series.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "Series.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "Series.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "Series.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "Series.via_str.len()": "Return the length of the string.", "Series.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "Series.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "Series.via_str.partition()": "Partition each element around sep.", "Series.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "Series.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "Series.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "Series.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "Series.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "Series.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "Series.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "Series.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "Series.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "Series.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "Series.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "Series.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "Series.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "Series.via_str.zfill()": "Return the string left-filled with zeros.", "Series.via_fill_value().loc": "Label-based selection where labels not specified will define a new container containing those labels filled with the fill value.", "Series.via_fill_value().__getitem__()": "Label-based selection where labels not specified will define a new container containing those labels filled with the fill value.", "Series.via_fill_value().via_T": "Interface for using binary operators with one-dimensional sequences, where the opperand is applied column-wise.", "Series.via_fill_value().__add__()": "", "Series.via_fill_value().__sub__()": "", "Series.via_fill_value().__mul__()": "", "Series.via_fill_value().__truediv__()": "", "Series.via_fill_value().__floordiv__()": "", "Series.via_fill_value().__mod__()": "", "Series.via_fill_value().__pow__()": "", "Series.via_fill_value().__lshift__()": "", "Series.via_fill_value().__rshift__()": "", "Series.via_fill_value().__and__()": "", "Series.via_fill_value().__xor__()": "", "Series.via_fill_value().__or__()": "", "Series.via_fill_value().__lt__()": "", "Series.via_fill_value().__le__()": "", "Series.via_fill_value().__eq__()": "", "Series.via_fill_value().__ne__()": "", "Series.via_fill_value().__gt__()": "", "Series.via_fill_value().__ge__()": "", "Series.via_fill_value().__radd__()": "", "Series.via_fill_value().__rsub__()": "", "Series.via_fill_value().__rmul__()": "", "Series.via_fill_value().__rtruediv__()": "", "Series.via_fill_value().__rfloordiv__()": "", "Series.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "Series.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "Series.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "Series.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "Series.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "Series.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "Series.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "Series.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "Series.via_hashlib().md5()": "", "Series.via_hashlib().sha256()": "", "Series.via_hashlib().sha512()": "", "Series.via_hashlib().sha3_256()": "", "Series.via_hashlib().sha3_512()": "", "Series.via_hashlib().shake_128()": "", "Series.via_hashlib().shake_256()": "", "Series.via_hashlib().blake2b()": "", "Series.via_hashlib().blake2s()": "", "Series.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "Series.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "Series.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "Series.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "Series.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "Series.via_mapping.__getitem__()": "", "Series.via_mapping.__iter__()": "", "Series.via_mapping.__len__()": "", "Series.via_mapping.__contains__()": "", "Series.via_mapping.__repr__()": "", "Series.via_mapping.keys()": "", "Series.via_mapping.values()": "", "Series.via_mapping.items()": "", "SeriesHE.__init__()": "Initializer. Args: values: An iterable of values to be aligned with the supplied (or automatically generated) index. index: Optional index initializer. If provided in addition to data values, lengths must be compatible. name: dtype: index_constructor: own_index: Flag the passed index as ownable by this Series. Primarily used by internal clients.", "SeriesHE.from_concat()": "Concatenate multiple Series into a new Series. Args: containers: Iterable of Series from which values in the new Series are drawn. index: If None, the resultant index will be the concatenation of all indices (assuming they are unique in combination). If IndexAutoFactory, the resultant index is a auto-incremented integer index. Otherwise, the value is used as a index initializer. index_constructor: name: Returns: Series", "SeriesHE.from_concat_items()": "Produce a Series with a hierarchical index from an iterable of pairs of labels, Series. The IndexHierarchy is formed from the provided labels and the Index if each Series. Args: items: Iterable of pairs of label, Series Returns: Series", "SeriesHE.from_delimited()": "Series construction from a delimited string. Args: dtype: if None, dtype will be inferred.", "SeriesHE.from_dict()": "Series construction from a dictionary, where the first pair value is the index and the second is the value. Args: mapping: a dictionary or similar mapping interface. dtype: dtype or valid dtype specifier. Returns: Series", "SeriesHE.from_element()": "Create a Series from a single element. The size of the resultant container will be determined by the index argument. Returns: Series", "SeriesHE.from_items()": "Series construction from an iterator or generator of pairs, where the first pair value is the index and the second is the value. Args: pairs: Iterable of pairs of index, value. dtype: dtype or valid dtype specifier. name: index_constructor: Returns: Series", "SeriesHE.from_overlay()": "Return a new Series made by overlaying containers, aligned values are filled with values from subsequent containers with left-to-right precedence. Values are filled based on a passed function that must return a Boolean array. By default, that function is isna_array, returning True for missing values (NaN and None). Args: containers: Iterable of Series. * index: An Index or IndexHierarchy, or index initializer, to be used as the index upon which all containers are aligned. IndexAutoFactory is not supported. union: If True, and no index argument is supplied, a union index from containers will be used; if False, the intersection index will be used. name: func: fill_value:", "SeriesHE.from_pandas()": "Given a Pandas Series, return a Series. Args: value: Pandas Series. * index_constructor: name: own_data: If True, the underlying NumPy data array will be made immutable and used without a copy. Returns: Series", "SeriesHE.to_frame()": "Return a Frame view of this Series. As underlying data is immutable, this is a no-copy operation. Args: axis: Axis 1 (default) creates a single-column Frame with the same index: axis 0 creates a single-row Frame with the index as columns. * index_constructor: columns_constructor: name: Returns: Frame", "SeriesHE.to_frame_go()": "Return FrameGO view of this Series. As underlying data is immutable, this is a no-copy operation. Args: axis: * index_constructor: columns_constructor: Returns: FrameGO", "SeriesHE.to_frame_he()": "Return FrameHE view of this Series. As underlying data is immutable, this is a no-copy operation. Args: axis: * index_constructor: columns_constructor: Returns: FrameHE", "SeriesHE.to_html()": "Return an HTML table representation of this Series using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "SeriesHE.to_html_datatables()": "Return a complete HTML representation of this Series using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "SeriesHE.to_pairs()": "Return a tuple of tuples, where each inner tuple is a pair of index label, value. Returns: tp.Iterable[tp.Tuple[TLabel, tp.Any]]", "SeriesHE.to_pandas()": "Return a Pandas Series. Returns: pandas.Series", "SeriesHE.to_series()": "Return a Series from this SeriesHE.", "SeriesHE.to_series_he()": "Return a SeriesHE from this Series.", "SeriesHE.to_visidata()": "Open an interactive VisiData session.", "SeriesHE.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "SeriesHE.T": "Transpose. For a 1D immutable container, this returns a reference to self. Returns: Series", "SeriesHE.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "SeriesHE.index": "The index instance assigned to this container. Returns: Index", "SeriesHE.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "SeriesHE.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "SeriesHE.name": "A hashable label attached to this container. Returns: Hashable", "SeriesHE.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "SeriesHE.ndim": "Return the number of dimensions, which for a Series is always 1. Returns: int", "SeriesHE.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: Tuple[int]", "SeriesHE.size": "Return the size of the underlying NumPy array. Returns: int", "SeriesHE.__array__()": "Support the __array__ interface, returning an array of values.", "SeriesHE.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "SeriesHE.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "SeriesHE.__deepcopy__()": "", "SeriesHE.__len__()": "Length of values.", "SeriesHE.__round__()": "Return a Series rounded to the given decimals. Negative decimals round to the left of the decimal point. Args: decimals: number of decimals to round to. Returns: Series", "SeriesHE.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "SeriesHE.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "SeriesHE.astype()": "Return a Series with type determined by dtype argument. Note that for Series, this is a simple function, whereas for Frame, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. Returns: Series", "SeriesHE.clip()": "Apply a clip operation to this Series. Note that clip operations can be applied to object types, but cannot be applied to non-numerical objects (e.g., strings, None) Args: lower: value or Series to define the inclusive lower bound. upper: value or Series to define the inclusive upper bound. Returns: Series", "SeriesHE.corr()": "Return the index-aligned correlation to the supplied Series. Args: other: Series to be correlated with by selection on corresponding labels.", "SeriesHE.count()": "Return the count of non-NA, non-falsy, and/or unique elements. Args: skipna: skip NA (NaN, None) values. skipfalsy: skip falsu values (0, '', False, None, NaN) unique: Count unique items after optionally applying skipna or skipfalsy removals.", "SeriesHE.cov()": "Return the index-aligned covariance to the supplied Series. Args: ddof: Delta degrees of freedom, defaults to 1.", "SeriesHE.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "SeriesHE.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "SeriesHE.drop_duplicated()": "Return a Series with duplicated values removed. Args: exclude_first: Boolean to select if the first duplicated value is excluded. exclude_last: Boolean to select if the last duplicated value is excluded. Returns: Series", "SeriesHE.dropfalsy()": "Return a new Series after removing values of falsy.", "SeriesHE.dropna()": "Return a new Series after removing values of NaN or None.", "SeriesHE.duplicated()": "Return a same-sized Boolean Series that shows True for all values that are duplicated. Args: exclude_first: Boolean to select if the first duplicated value is excluded. exclude_last: Boolean to select if the last duplicated value is excluded. Returns: numpy.ndarray", "SeriesHE.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "SeriesHE.fillfalsy()": "Return a new Series after replacing falsy values with the supplied value. The value can be an element or Series. Args: value: Value to be used to replace missing values (NaN or None).", "SeriesHE.fillfalsy_backward()": "Return a new Series after feeding backward the last non-falsy observation across contiguous falsy values. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit.", "SeriesHE.fillfalsy_forward()": "Return a new Series after feeding forward the last non-falsy observation across contiguous falsy values. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit.", "SeriesHE.fillfalsy_leading()": "Return a new Series after filling leading (and only leading) falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "SeriesHE.fillfalsy_trailing()": "Return a new Series after filling trailing (and only trailing) falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "SeriesHE.fillna()": "Return a new Series after replacing NA (NaN or None) with the supplied value. The value can be an element or Series. Args: value: Value to be used to replace missing values (NaN or None).", "SeriesHE.fillna_backward()": "Return a new Series after feeding backward the last non-null (NaN or None) observation across contiguous nulls. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit.", "SeriesHE.fillna_forward()": "Return a new Series after feeding forward the last non-null (NaN or None) observation across contiguous nulls. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit.", "SeriesHE.fillna_leading()": "Return a new Series after filling leading (and only leading) null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "SeriesHE.fillna_trailing()": "Return a new Series after filling trailing (and only trailing) null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "SeriesHE.head()": "Return a Series consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Series Returns: Series", "SeriesHE.iloc_max()": "Return the integer index corresponding to the maximum value. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. Returns: int", "SeriesHE.iloc_min()": "Return the integer index corresponding to the minimum value found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. Returns: int", "SeriesHE.iloc_notfalsy_first()": "Return the position corresponding to the first non-falsy (including nan) value found. Args: {fill_value} Returns: TLabel", "SeriesHE.iloc_notfalsy_last()": "Return the position corresponding to the last non-falsy (including nan) value found. Args: {fill_value} Returns: TLabel", "SeriesHE.iloc_notna_first()": "Return the position corresponding to the first not NA (None or nan) value found. Args: {fill_value} Returns: TLabel", "SeriesHE.iloc_notna_last()": "Return the position corresponding to the last not NA (None or nan) value found. Args: {fill_value} Returns: TLabel", "SeriesHE.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "SeriesHE.insert_after()": "Create a new Series by inserting a Series at the position after the label specified by key. Args: key: Label after which the new container will be inserted. container: Container to be inserted. Returns: Series", "SeriesHE.insert_before()": "Create a new Series by inserting a Series at the position before the label specified by key. Args: key: Label before which the new container will be inserted. container: Container to be inserted. Returns: Series", "SeriesHE.isfalsy()": "Return a same-indexed, Boolean Series indicating which values are falsy.", "SeriesHE.isin()": "Return a same-sized Boolean Series that shows if the same-positioned element is in the iterable passed to the function. Returns: Series", "SeriesHE.isna()": "Return a same-indexed, Boolean Series indicating which values are NaN or None.", "SeriesHE.loc_max()": "Return the label corresponding to the maximum value found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. Returns: TLabel", "SeriesHE.loc_min()": "Return the label corresponding to the minimum value found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. Returns: TLabel", "SeriesHE.loc_notfalsy_first()": "Return the label corresponding to the first non-falsy (including nan) value found. Args: {fill_value} Returns: TLabel", "SeriesHE.loc_notfalsy_last()": "Return the label corresponding to the last non-falsy (including nan) value found. Args: {fill_value} Returns: TLabel", "SeriesHE.loc_notna_first()": "Return the label corresponding to the first not NA (None or nan) value found. Args: {fill_value} Returns: TLabel", "SeriesHE.loc_notna_last()": "Return the label corresponding to the last not NA (None or nan) value found. Args: {fill_value} Returns: TLabel", "SeriesHE.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "SeriesHE.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "SeriesHE.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "SeriesHE.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "SeriesHE.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "SeriesHE.notfalsy()": "Return a same-indexed, Boolean Series indicating which values are falsy.", "SeriesHE.notna()": "Return a same-indexed, Boolean Series indicating which values are NaN or None.", "SeriesHE.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "SeriesHE.rank_dense()": "Rank values as compactly as possible, where ties get the same value, and ranks are contiguous (potentially non-unique) integers. Args: skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: If True, the lowest ranks correspond to the lowest values. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Series", "SeriesHE.rank_max()": "Rank values where tied values are assigned the maximum ordinal rank; ranks are potentially non-contiguous and non-unique integers. Args: skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: If True, the lowest ranks correspond to the lowest values. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Series", "SeriesHE.rank_mean()": "Rank values where tied values are assigned the mean of the ordinal ranks; ranks are potentially non-contiguous and non-unique floats. Args: skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: If True, the lowest ranks correspond to the lowest values. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Series", "SeriesHE.rank_min()": "Rank values where tied values are assigned the minimum ordinal rank; ranks are potentially non-contiguous and non-unique integers. Args: skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: If True, the lowest ranks correspond to the lowest values. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Series", "SeriesHE.rank_ordinal()": "Rank values distinctly, where ties get distinct values that maintain their ordering, and ranks are contiguous unique integers. Args: skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: If True, the lowest ranks correspond to the lowest values. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Series", "SeriesHE.rehierarch()": "Return a new Series with new a hierarchy based on the supplied depth_map.", "SeriesHE.reindex()": "Return a new Series with labels defined by the provided index. The size and ordering of the data is determined by the newly provided index, where data will continue to be aligned under labels found in both the new and the old index. Labels found only in the new index will be filled with fill_value. Args: index: An iterable of unique, hashable values, or another Index or IndexHierarchy, to be used as the labels of the index. columns: An iterable of unique, hashable values, or another Index or IndexHierarchy, to be used as the labels of the index. fill_value: A value to be used to fill space created by a new index that has values not found in the previous index. own_index: Flag the passed index as ownable by this Series. Primarily used by internal clients.", "SeriesHE.relabel()": "Return a new Series with transformed labels on the index. The size and ordering of the data is never changed in a relabeling operation. The resulting index must be unique. Args: index: One of the following types, used to create new index labels with the same size as the previous index. (a) A mapping (as a dictionary or Series), used to lookup and transform the labels in the previous index. Labels not found in the mapping will be reused. (b) A function, returning a hashable, that is applied to each label in the previous index. (c) The IndexAutoFactory type, to apply auto-incremented integer labels. (d) An Index initializer, i.e., either an iterable of hashables or an Index instance.", "SeriesHE.relabel_flat()": "Return a new Series, where an IndexHierarchy (if defined) is replaced with a flat, one-dimension index of tuples.", "SeriesHE.relabel_level_add()": "Return a new Series, adding a new root level to an existing IndexHierarchy, or creating an IndexHierarchy if one is not yet defined. Args: level: A hashable value to be used as a new root level, extending or creating an IndexHierarchy", "SeriesHE.relabel_level_drop()": "Return a new Series, dropping one or more levels from a either the root or the leaves of an IndexHierarchy. The resulting index must be unique. Args: count: A positive integer drops that many outer-most (root) levels; a negative integer drops that many inner-most (leaf)levels.", "SeriesHE.rename()": "Return a new Series with an updated name attribute.", "SeriesHE.roll()": "Return a Series with values rotated forward and wrapped around the index (with a positive shift) or backward and wrapped around the index (with a negative shift). Args: shift: Positive or negative integer shift. include_index: Determine if the Index is shifted with the underlying data. Returns: Series", "SeriesHE.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "SeriesHE.shift()": "Return a Series with values shifted forward on the index (with a positive shift) or backward on the index (with a negative shift). Args: shift: Positive or negative integer shift. fill_value: Value to be used to fill data missing after the shift. Returns: Series", "SeriesHE.sort_index()": "Return a new Series ordered by the sorted Index. Args: * ascendings: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by. Returns: Series", "SeriesHE.sort_values()": "Return a new Series ordered by the sorted values. Args: * ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by. Returns: Series", "SeriesHE.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "SeriesHE.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "SeriesHE.tail()": "Return a Series consisting only of the bottom elements as specified by count. s Args: count: Number of elements to be returned from the bottom of the Series Returns: Series", "SeriesHE.transpose()": "Transpose. For a 1D immutable container, this returns a reference to self. Returns: Series", "SeriesHE.unique()": "Return a NumPy array of unique values. Returns: numpy.ndarray", "SeriesHE.unique_enumerated()": "Given a collection of values, return two NumPy arrays: the first provides index positions for lookup of observed values; the second provides those observed, unique, values. Sometimes called \"factorize\". Args: retain_order: Boolean. If True, observed order is retained. If False, order may be sorted or observed, depending on the dtype and values. Retaining order may decrease performance. func: A callable that takes an element and returns a Boolean if that element should be treated as missing, excluded from the unique value collection, and given a -1 indexer position. The NumPy function np.isnan or the StaticFrame sf.isna_element are examples of suitable functions.", "SeriesHE.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "SeriesHE.__contains__()": "Inclusion of value in index labels. Returns: bool", "SeriesHE.__iter__()": "Iterator of index labels, same as Series.keys. Returns: Iterator[Hashasble]", "SeriesHE.__reversed__()": "Returns a reverse iterator on the series' index. Returns: Index", "SeriesHE.get()": "Return the value found at the index key, else the default if the key is not found. Returns: Any", "SeriesHE.items()": "Iterator of pairs of index label and value. Returns: Iterator[Tuple[Hashable, Any]]", "SeriesHE.keys()": "Iterator of index labels. Returns: Iterator[TLabel]", "SeriesHE.values": "ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array, zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method (ndarray(...)) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters ---------- (for the __new__ method; see Notes below) shape : tuple of ints Shape of created array. dtype : data-type, optional Any object that can be interpreted as a numpy data type. buffer : object exposing buffer interface, optional Used to fill the array with data. offset : int, optional Offset of array data in buffer. strides : tuple of ints, optional Strides of data in memory. order : {'C', 'F'}, optional Row-major (C-style) or column-major (Fortran-style) order. Attributes ---------- T : ndarray Transpose of the array. data : buffer The array's elements, in memory. dtype : dtype object Describes the format of the elements in the array. flags : dict Dictionary containing information related to memory use, e.g., 'C_CONTIGUOUS', 'OWNDATA', 'WRITEABLE', etc. flat : numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag : ndarray Imaginary part of the array. real : ndarray Real part of the array. size : int Number of elements in the array. itemsize : int The memory use of each array element in bytes. nbytes : int The total number of bytes required to store the array data, i.e., itemsize * size. ndim : int The array's number of dimensions. shape : tuple of ints Shape of the array. strides : tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2). This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time (2 * 4). ctypes : ctypes object Class containing properties of the array needed for interaction with ctypes. base : ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also -------- array : Construct an array. zeros : Create an array, each element of which is zero. empty : Create an array, but leave its allocated memory unchanged (i.e., it contains \"garbage\"). dtype : Create a data-type. numpy.typing.NDArray : An ndarray alias :term:generic <generic type> w.r.t. its dtype.type <numpy.dtype.type>. Notes ----- There are two modes of creating an array using __new__: 1. If buffer is None, then only shape, dtype, and order are used. 2. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples -------- These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3])", "SeriesHE.interface": "A Frame documenting the interface of this class.", "SeriesHE.__repr__()": "", "SeriesHE.__str__()": "Return str(self).", "SeriesHE.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "SeriesHE.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "SeriesHE.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "SeriesHE.assign[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "SeriesHE.assign[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. *. fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "SeriesHE.assign[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "SeriesHE.assign[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "SeriesHE.assign.iloc[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "SeriesHE.assign.iloc[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. *. fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "SeriesHE.assign.iloc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "SeriesHE.assign.iloc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "SeriesHE.assign.loc[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "SeriesHE.assign.loc[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. *. fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "SeriesHE.assign.loc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "SeriesHE.assign.loc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "SeriesHE.drop[]": "Label-based selection.", "SeriesHE.drop.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "SeriesHE.drop.loc[]": "", "SeriesHE.mask[]": "Label-based selection.", "SeriesHE.mask.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "SeriesHE.mask.loc[]": "", "SeriesHE.masked_array[]": "Label-based selection.", "SeriesHE.masked_array.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "SeriesHE.masked_array.loc[]": "", "SeriesHE.[]": "Selector of values by label. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array. Compatibility: Pandas supports using both loc and iloc style selections with the __getitem__ interface on Series. This is undesirable, so here we only expose the loc interface (making the Series dictionary like, but unlike the Index, where __getitem__ is an iloc).", "SeriesHE.iloc[]": "Interface for position-based selection.", "SeriesHE.loc[]": "Interface for label-based selection.", "SeriesHE.iter_element()": "Iterator of elements.", "SeriesHE.iter_element().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_element().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_element().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_element().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_element().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_element().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "SeriesHE.iter_element().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "SeriesHE.iter_element().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_element().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "SeriesHE.iter_element().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "SeriesHE.iter_element().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_element().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "SeriesHE.iter_element().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "SeriesHE.iter_element_items()": "Iterator of label, element pairs.", "SeriesHE.iter_element_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_element_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_element_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_element_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_element_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_element_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "SeriesHE.iter_element_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "SeriesHE.iter_element_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_element_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "SeriesHE.iter_element_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "SeriesHE.iter_element_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_element_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "SeriesHE.iter_element_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "SeriesHE.iter_group()": "Iterator of Series, where each Series matches unique values.", "SeriesHE.iter_group().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_group().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_group().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_group().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_group_array()": "Iterator of Series, where each Series matches unique values.", "SeriesHE.iter_group_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_group_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_group_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_group_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_group_array_items()": "", "SeriesHE.iter_group_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_group_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_group_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_group_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_group_items()": "", "SeriesHE.iter_group_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_group_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_group_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_group_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_group_labels()": "", "SeriesHE.iter_group_labels().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_group_labels().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_group_labels().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_group_labels().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_group_labels_array()": "", "SeriesHE.iter_group_labels_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_group_labels_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_group_labels_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_group_labels_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_group_labels_array_items()": "", "SeriesHE.iter_group_labels_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_group_labels_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_group_labels_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_group_labels_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_group_labels_items()": "", "SeriesHE.iter_group_labels_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_group_labels_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_group_labels_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_group_labels_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_group_other()": "Iterator of Series, grouped by unique values found in the passed container.", "SeriesHE.iter_group_other().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_group_other().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_group_other().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_group_other().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_group_other_array()": "", "SeriesHE.iter_group_other_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_group_other_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_group_other_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_group_other_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_group_other_array_items()": "", "SeriesHE.iter_group_other_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_group_other_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_group_other_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_group_other_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_group_other_items()": "Iterator of pairs of label, Series, grouped by unique values found in the passed container.", "SeriesHE.iter_group_other_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_group_other_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_group_other_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_group_other_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_window()": "", "SeriesHE.iter_window().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_window().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_window().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_window().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_window_array()": "", "SeriesHE.iter_window_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_window_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_window_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_window_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_window_array_items()": "", "SeriesHE.iter_window_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_window_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_window_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_window_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.iter_window_items()": "", "SeriesHE.iter_window_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "SeriesHE.iter_window_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "SeriesHE.iter_window_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "SeriesHE.iter_window_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "SeriesHE.__add__()": "", "SeriesHE.__and__()": "", "SeriesHE.__eq__()": "Return True if other is a Series with the same labels, values, and name. Container class and underlying dtypes are not independently compared.", "SeriesHE.__floordiv__()": "", "SeriesHE.__ge__()": "", "SeriesHE.__gt__()": "", "SeriesHE.__le__()": "", "SeriesHE.__lt__()": "", "SeriesHE.__matmul__()": "", "SeriesHE.__mod__()": "", "SeriesHE.__mul__()": "", "SeriesHE.__ne__()": "Return False if other is a Series with the same labels, values, and name. Container class and underlying dtypes are not independently compared.", "SeriesHE.__or__()": "", "SeriesHE.__pow__()": "", "SeriesHE.__radd__()": "", "SeriesHE.__rfloordiv__()": "", "SeriesHE.__rmatmul__()": "", "SeriesHE.__rmul__()": "", "SeriesHE.__rshift__()": "", "SeriesHE.__rsub__()": "", "SeriesHE.__rtruediv__()": "", "SeriesHE.__sub__()": "", "SeriesHE.__truediv__()": "", "SeriesHE.__xor__()": "", "SeriesHE.__abs__()": "", "SeriesHE.__invert__()": "", "SeriesHE.__neg__()": "", "SeriesHE.__pos__()": "", "SeriesHE.abs()": "", "SeriesHE.via_values.apply()": "", "SeriesHE.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "SeriesHE.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "SeriesHE.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "SeriesHE.via_dt.year": "Return the year of each element.", "SeriesHE.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "SeriesHE.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "SeriesHE.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "SeriesHE.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "SeriesHE.via_dt.hour": "Return the hour of each element, between 0 and 24.", "SeriesHE.via_dt.minute": "Return the minute of each element, between 0 and 60.", "SeriesHE.via_dt.second": "Return the second of each element, between 0 and 60.", "SeriesHE.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "SeriesHE.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "SeriesHE.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "SeriesHE.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "SeriesHE.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "SeriesHE.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "SeriesHE.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "SeriesHE.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "SeriesHE.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "SeriesHE.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "SeriesHE.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "SeriesHE.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "SeriesHE.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "SeriesHE.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "SeriesHE.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "SeriesHE.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "SeriesHE.via_str.center()": "Return a container with its elements centered in a string of length width.", "SeriesHE.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "SeriesHE.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "SeriesHE.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "SeriesHE.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "SeriesHE.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "SeriesHE.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "SeriesHE.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "SeriesHE.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "SeriesHE.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "SeriesHE.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "SeriesHE.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "SeriesHE.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "SeriesHE.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "SeriesHE.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "SeriesHE.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "SeriesHE.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "SeriesHE.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "SeriesHE.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "SeriesHE.via_str.len()": "Return the length of the string.", "SeriesHE.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "SeriesHE.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "SeriesHE.via_str.partition()": "Partition each element around sep.", "SeriesHE.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "SeriesHE.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "SeriesHE.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "SeriesHE.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "SeriesHE.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "SeriesHE.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "SeriesHE.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "SeriesHE.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "SeriesHE.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "SeriesHE.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "SeriesHE.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "SeriesHE.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "SeriesHE.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "SeriesHE.via_str.zfill()": "Return the string left-filled with zeros.", "SeriesHE.via_fill_value().loc": "Label-based selection where labels not specified will define a new container containing those labels filled with the fill value.", "SeriesHE.via_fill_value().__getitem__()": "Label-based selection where labels not specified will define a new container containing those labels filled with the fill value.", "SeriesHE.via_fill_value().via_T": "Interface for using binary operators with one-dimensional sequences, where the opperand is applied column-wise.", "SeriesHE.via_fill_value().__add__()": "", "SeriesHE.via_fill_value().__sub__()": "", "SeriesHE.via_fill_value().__mul__()": "", "SeriesHE.via_fill_value().__truediv__()": "", "SeriesHE.via_fill_value().__floordiv__()": "", "SeriesHE.via_fill_value().__mod__()": "", "SeriesHE.via_fill_value().__pow__()": "", "SeriesHE.via_fill_value().__lshift__()": "", "SeriesHE.via_fill_value().__rshift__()": "", "SeriesHE.via_fill_value().__and__()": "", "SeriesHE.via_fill_value().__xor__()": "", "SeriesHE.via_fill_value().__or__()": "", "SeriesHE.via_fill_value().__lt__()": "", "SeriesHE.via_fill_value().__le__()": "", "SeriesHE.via_fill_value().__eq__()": "", "SeriesHE.via_fill_value().__ne__()": "", "SeriesHE.via_fill_value().__gt__()": "", "SeriesHE.via_fill_value().__ge__()": "", "SeriesHE.via_fill_value().__radd__()": "", "SeriesHE.via_fill_value().__rsub__()": "", "SeriesHE.via_fill_value().__rmul__()": "", "SeriesHE.via_fill_value().__rtruediv__()": "", "SeriesHE.via_fill_value().__rfloordiv__()": "", "SeriesHE.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "SeriesHE.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "SeriesHE.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "SeriesHE.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "SeriesHE.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "SeriesHE.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "SeriesHE.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "SeriesHE.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "SeriesHE.via_hashlib().md5()": "", "SeriesHE.via_hashlib().sha256()": "", "SeriesHE.via_hashlib().sha512()": "", "SeriesHE.via_hashlib().sha3_256()": "", "SeriesHE.via_hashlib().sha3_512()": "", "SeriesHE.via_hashlib().shake_128()": "", "SeriesHE.via_hashlib().shake_256()": "", "SeriesHE.via_hashlib().blake2b()": "", "SeriesHE.via_hashlib().blake2s()": "", "SeriesHE.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "SeriesHE.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "SeriesHE.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "SeriesHE.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "SeriesHE.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "SeriesHE.via_mapping.__getitem__()": "", "SeriesHE.via_mapping.__iter__()": "", "SeriesHE.via_mapping.__len__()": "", "SeriesHE.via_mapping.__contains__()": "", "SeriesHE.via_mapping.__repr__()": "", "SeriesHE.via_mapping.keys()": "", "SeriesHE.via_mapping.values()": "", "SeriesHE.via_mapping.items()": "", "Frame.__init__()": "Initializer. Args: data: Default Frame initialization requires typed data such as a NumPy array. All other initialization should use specialized constructors. index: Optional index initializer. If provided in addition to data values, lengths must be compatible. columns: Optional column initializer. If provided in addition to data values, lengths must be compatible. index_constructor: columns_constructor: own_data: Flag the data values as ownable by this Frame. Primarily used by internal clients. own_index: Flag the passed index as ownable by this Frame. Primarily used by internal clients. own_columns: Flag the passed columns as ownable by this Frame. Primarily used by internal clients.", "Frame.from_arrow()": "Realize a Frame from an Arrow Table. Args: value: A pyarrow.Table instance. index_depth: integer specification of how many columns to use in forming the index. A value of 0 will select none; a value greater than 1 will create an IndexHierarchy. columns_depth: integer specification of how many rows to use in forming the columns. A value of 0 will select none; a value greater than 1 will create an IndexHierarchy. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "Frame.from_clipboard()": "Create a Frame from the contents of the clipboard (assuming a table is stored as delimited file). Returns: Frame", "Frame.from_concat()": "Concatenate multiple Frame or Series into a new Frame. If index or columns are provided and appropriately sized, the resulting Frame will use those indices. If the axis along concatenation (index for axis 0, columns for axis 1) is unique after concatenation, it will be preserved; otherwise, a new index or an IndexAutoFactory must be supplied. Args: frames: Iterable of Frames. axis: Integer specifying 0 to concatenate supplied Frames vertically (aligning on columns), 1 to concatenate horizontally (aligning on rows). union: If True, the union of the aligned indices is used; if False, the intersection is used. index: Optionally specify a new index. columns: Optionally specify new columns. index_constructor: Optionally apply a constructor to the derived or passed labels. columns_constructor: Optionally apply a constructor to the derived or passed labels. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "Frame.from_concat_items()": "Produce a Frame with a hierarchical index from an iterable of pairs of labels, Frame. The IndexHierarchy is formed from the provided labels and the Index if each Frame. Args: items: Iterable of pairs of label, Frame axis: union: name: fill_value: index_constructor: columns_constructor: consolidate_blocks:", "Frame.from_csv()": "Specialized version of Frame.from_delimited for CSV files. Returns: Frame", "Frame.from_delimited()": "Create a Frame from a file path or a file-like object defining a delimited (CSV, TSV) data file. Args: fp: A file path or a file-like object. delimiter: The character used to seperate row elements. index_depth: Specify the number of columns used to create the index labels; a value greater than 1 will attempt to create a hierarchical index. index_column_first: Optionally specify a column, by position in the realized columns, to become the start of the index if index_depth is greater than 0 and columns_depth is 0. index_name_depth_level: If columns_depth is greater than 0, interpret values over index as the index name. index_constructors: index_continuation_token: columns_depth: Specify the number of rows after the skip_header used to create the column labels. A value of 0 will be no header; a value greater than 1 will attempt to create a hierarchical index. columns_name_depth_level: If index_depth is greater than 0, interpret values over index as the columns name. columns_constructors: columns_continuation_token: columns_select: an iterable of columns to select by label or position; can only be used if index_depth is 0. skip_header: Number of leading lines to skip. skip_footer: Number of trailing lines to skip. store_filter: A StoreFilter instance, defining translation between unrepresentable strings and types. By default it is disabled, and only empty fields or \"NAN\" are intepreted as NaN. To force usage, set the type of the column to string. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "Frame.from_dict()": "Create a Frame from a dictionary (or any object that has an items() method) where keys are column labels and values are columns values (either sequence types or Series). Args: mapping: a dictionary or similar mapping interface. index: fill_value: dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. index_constructor: columns_constructor: consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays.", "Frame.from_dict_fields()": "Frame constructor from an iterable of dictionaries, where each dictionary represents a column; index labels will be derived from the union of all column dictionary keys. Args: fields: Iterable of column values, where column values are dictionaries. index: Optionally provide an iterable of index labels, equal in length to the number of fields. If a generator, this value will not be evaluated until after fields are loaded. columns: dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "Frame.from_dict_records()": "Frame constructor from an iterable of dictionaries, where each dictionary represents a row; column names will be derived from the union of all row dictionary keys. Args: records: Iterable of row values, where row values are dictionaries. index: Optionally provide an iterable of index labels, equal in length to the number of records. If a generator, this value will not be evaluated until after records are loaded. index: dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "Frame.from_dict_records_items()": "Frame constructor from iterable of pairs of index label, row, where row is a dictionary. Column names will be derived from the union of all row dictionary keys. Args: items: Iterable of pairs of index label, row values, where row values are arrays, tuples, lists, dictionaries, or namedtuples. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "Frame.from_element()": "Create a Frame from an element, i.e., a single value stored in a single cell. Both index and columns are required, and cannot be specified with IndexAutoFactory.", "Frame.from_element_items()": "Create a Frame from an iterable of key, value, where key is a pair of row, column labels. This function is partialed (setting the index and columns) and used by IterNodeDelegate as the apply constructor for doing application on element iteration. Args: items: an iterable of pairs of 2-tuples of row, column loc labels and values. axis: when None, items can be in an order; when 0, items must be well-formed and ordered row major; when 1, items must be well-formed and ordered columns major. Returns: Frame", "Frame.from_elements()": "Create a Frame from an iterable of elements, to be formed into a Frame with a single column.", "Frame.from_fields()": "Frame constructor from an iterator of columns, where columns are iterables. Series can be provided as values if an index argument is supplied. This constructor is similar to from_items(), though here columns are provided through an independent columns argument. Args: fields: Iterable of column values. index: Iterable of values to create an Index. fill_value: If pairs include Series, they will be reindexed with the provided index; reindexing will use this fill value. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "Frame.from_items()": "Frame constructor from an iterator of pairs, where the first value is the column label and the second value is an iterable of column values. Series can be provided as values if an index argument is supplied. Args: pairs: Iterable of pairs of column name, column values. index: Iterable of values to create an Index. fill_value: If pairs include Series, they will be reindexed with the provided index; reindexing will use this fill value. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. index_constructor: columns_constructor: consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "Frame.from_json_columns()": "Frame constructor from an in-memory JSON document in the following format: A JSON object keyed by column labels, where values are columns represented by an object mapping of index labels to values. Args: json_data: a string or StringIO of JSON data dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "Frame.from_json_index()": "Frame constructor from an in-memory JSON document in the following format: A JSON object keyed by index labels, where values are rows represented by an object mapping of column labels to values. Args: json_data: a string or StringIO of JSON data dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "Frame.from_json_records()": "Frame constructor from an in-memory JSON document in the following format: A JSON array of row objects, where column labels are repeated for each row, and no index labels are included. Args: json_data: a string or StringIO of JSON data dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "Frame.from_json_split()": "Frame constructor from an in-memory JSON document in the following format: A JSON object with a key for \"columns\", \"index\", and \"data\", where data is given as an array of arrays of row values. Args: json_data: a string or StringIO of JSON data dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "Frame.from_json_typed()": "Frame constructor from an in-memory JSON document in the following format: A JSON object with a key for \"columns\", \"index\", and \"data\", where data is given as an array of arrays of column values; additionally, a key for \"__meta__\" defines an object with complete metadata and typing information. Args: json_data: a string or StringIO of JSON data Returns: Frame", "Frame.from_json_values()": "Frame constructor from an in-memory JSON document in the following format: A JSON array of arrays of row values; no index or columns labels are included. Args: json_data: a string or StringIO of JSON data dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "Frame.from_npy()": "Create a Frame from an directory of npy files. Args: fp: The path to the NPY directory.", "Frame.from_npy_mmap()": "Create a Frame from an directory of npy files using memory maps. Args: fp: The path to the NPY directory. Returns: A tuple of Frame and the callable needed to close the open memory map objects. On some platforms this must be called before the process exits.", "Frame.from_npz()": "Create a Frame from an npz file.", "Frame.from_overlay()": "Return a new Frame made by overlaying containers, filling in values with aligned values from subsequent containers. Values are filled based on a passed function that must return a Boolean array. By default, that function is isna_array, returning True for missing values (NaN and None). Args: containers: Iterable of Frame. index: An optional Index, IndexHierarchy, or index initializer, to be used as the index upon which all containers are aligned. IndexAutoFactory is not supported. columns: An optional Index, IndexHierarchy, or columns initializer, to be used as the columns upon which all containers are aligned. IndexAutoFactory is not supported. union: If True, and no index or columns argument is supplied, a union index or columns from containers will be used; if False, the intersection index or columns will be used. name: func: A function that takes an array and returns a same-sized Boolean array, where True indicates availability for insertion.", "Frame.from_pandas()": "Given a Pandas DataFrame, return a Frame. Args: value: Pandas DataFrame. index_constructor: Optional class or constructor function to create the Index applied to the rows. columns_constructor: Optional class or constructor function to create the Index applied to the columns. dtypes: consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. own_data: If True, the underlying NumPy data array will be made immutable and used without a copy. Returns: Frame", "Frame.from_parquet()": "Realize a Frame from a Parquet file. Args: fp: A string file path or Path instance. index_depth: integer specification of how many columns to use in forming the index. A value of 0 will select none; a value greater than 1 will create an IndexHierarchy. index_name_depth_level: index_constructors: columns_depth: integer specification of how many rows to use in forming the columns. A value of 0 will select none; a value greater than 1 will create an IndexHierarchy. columns_name_depth_level: columns_constructors: columns_select: An optional iterable of column names to load. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays.", "Frame.from_pickle()": "Create a Frame from a pickle file. The pickle module is not secure. Only unpickle data you trust. Args: fp: The path to the pickle file.", "Frame.from_records()": "Construct a Frame from an iterable of rows, where rows are defined as iterables, including tuples, lists, and arrays. If each row is a NamedTuple, and columns is not provided, column names will be derived from the NamedTuple fields. Supplying dtypes will significantly improve performance, as otherwise columnar array types must be derived by element-wise examination. For records defined as Series, use Frame.from_concat; for records defined as dictionary, use Frame.from_dict_records; for creating a Frame from a single dictionary, where keys are column labels and values are columns, use Frame.from_dict. Args: records: Iterable of row values, where row values are arrays, tuples, lists, or namedtuples. For dictionary records, use Frame.from_dict_records. index: Optionally provide an iterable of index labels, equal in length to the number of records. If a generator, this value will not be evaluated until after records are loaded. columns: Optionally provide an iterable of column labels, equal in length to the number of elements in a row. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "Frame.from_records_items()": "Frame constructor from iterable of pairs of index value, row (where row is an iterable). Args: items: Iterable of pairs of index label, row values, where row values are arrays, tuples, lists, dictionaries, or namedtuples. columns: Optionally provide an iterable of column labels, equal in length to the length of each row. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "Frame.from_series()": "Frame constructor from a Series: Args: series: A Series instance, to be realized as single column, with the column label taken from the name attribute.", "Frame.from_sql()": "Frame constructor from an SQL query and a database connection object. Args: query: A query string. connection: A DBAPI2 (PEP 249) Connection object, such as those returned from SQLite (via the sqlite3 module) or PyODBC. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. index_depth: index_constructors: columns_depth: columns_select: An optional iterable of field names to extract from the results of the query. columns_constructors: name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. parameters: Provide a list of values for an SQL query expecting parameter substitution.", "Frame.from_sqlite()": "Load Frame from the contents of a table in an SQLite database file.", "Frame.from_structured_array()": "Convert a NumPy structed array into a Frame. Args: array: Structured NumPy array. index_depth: Depth if index levels, where (for example) 0 is no index, 1 is a single column index, and 2 is a two-columns IndexHierarchy. index_column_first: Optionally provide the name or position offset of the column to use as the index. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "Frame.from_tsv()": "Specialized version of Frame.from_delimited for TSV files. Returns: Frame", "Frame.from_xlsx()": "Load Frame from the contents of a sheet in an XLSX workbook. Args: label: Optionally provide the sheet name from which to read. If not provided, the first sheet will be used.", "Frame.to_arrow()": "Return a pyarrow.Table from this Frame.", "Frame.to_clipboard()": "Given a file path or file-like object, write the Frame as delimited text. The delimiter defaults to a tab. Args: A file path, PathLib instance, or file-like object. * delimiter: Character to be used for delimiterarating elements. include_index: If True, the index will be written. include_index_name: If including columns, populate the row above the index with the index name. Cannot be True if include_columns_name is True. include_columns: If True, the columns will be written. include_columns_name: If including index, populate the column to the left of the columns with the columns name. Cannot be True if include_index_name is True. encoding: Encoding type to be used when opening the file. line_terminator: The string used to terminate lines. quote_char: A one-character string used to quote fields containing special characters, such as the delimiter or quote_char, or which contain new-line characters. quote_double: Controls how instances of quote_char appearing inside a field should themselves be quoted. When True, the character is doubled. When False, the escape_char is used as a prefix to the quote_char. It defaults to True. escape_char: A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE_NONE and the quotechar if quote_double is False. quoting: Controls when quotes should be generated. It can take on any of the QUOTE_* constants from the standard library csv module. store_filter: A StoreFilter instance.", "Frame.to_csv()": "Given a file path or file-like object, write the Frame as delimited text. The delimiter is set to a comma. Args: A file path, PathLib instance, or file-like object. * include_index: If True, the index will be written. include_index_name: If including columns, populate the row above the index with the index name. Cannot be True if include_columns_name is True. include_columns: If True, the columns will be written. include_columns_name: If including index, populate the column to the left of the columns with the columns name. Cannot be True if include_index_name is True. encoding: Encoding type to be used when opening the file. line_terminator: The string used to terminate lines. quote_char: A one-character string used to quote fields containing special characters, such as the delimiter or quote_char, or which contain new-line characters. quote_double: Controls how instances of quote_char appearing inside a field should themselves be quoted. When True, the character is doubled. When False, the escape_char is used as a prefix to the quote_char. It defaults to True. escape_char: A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE_NONE and the quotechar if quote_double is False. quoting: Controls when quotes should be generated. It can take on any of the QUOTE_* constants from the standard library csv module. store_filter: A StoreFilter instance.", "Frame.to_delimited()": "Given a file path or file-like object, write the Frame as delimited text. A delimiter character must be specified. Args: A file path, PathLib instance, or file-like object. * delimiter: Character to be used for delimiterarating elements. include_index: If True, the index will be written. include_index_name: If including columns, populate the row above the index with the index name. Cannot be True if include_columns_name is True. include_columns: If True, the columns will be written. include_columns_name: If including index, populate the column to the left of the columns with the columns name. Cannot be True if include_index_name is True. encoding: Encoding type to be used when opening the file. line_terminator: The string used to terminate lines. quote_char: A one-character string used to quote fields containing special characters, such as the delimiter or quote_char, or which contain new-line characters. quote_double: Controls how instances of quote_char appearing inside a field should themselves be quoted. When True, the character is doubled. When False, the escape_char is used as a prefix to the quote_char. It defaults to True. escape_char: A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE_NONE and the quotechar if quote_double is False. quoting: Controls when quotes should be generated. It can take on any of the QUOTE_* constants from the standard library csv module. store_filter: A StoreFilter instance.", "Frame.to_frame()": "Return Frame instance from this Frame. If this Frame is immutable the same instance will be returned.", "Frame.to_frame_go()": "Return a FrameGO instance from this Frame.", "Frame.to_frame_he()": "Return a FrameHE instance from this Frame. If this Frame is immutable the same instance will be returned.", "Frame.to_html()": "Return an HTML table representation of this Frame using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "Frame.to_html_datatables()": "Return a complete HTML representation of this Frame using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "Frame.to_json_columns()": "Export a Frame as a JSON string constructed as follows: A JSON object keyed by column labels, where values are columns represented by an object mapping of index labels to values. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "Frame.to_json_index()": "Export a Frame as a JSON string constructed as follows: A JSON object keyed by index labels, where values are rows represented by an object mapping of column labels to values. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "Frame.to_json_records()": "Export a Frame as a JSON string constructed as follows: A JSON array of row objects, where column labels are repeated for each row, and no index labels are included. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "Frame.to_json_split()": "Export a Frame as a JSON string constructed as follows: A JSON object with a key for \"columns\", \"index\", and \"data\", where data is given as an array of arrays of row values. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "Frame.to_json_typed()": "Export a Frame as a JSON string constructed as follows: A JSON object with a key for \"columns\", \"index\", and \"data\", where data is given as an array of arrays of column values; additionally, a key for \"__meta__\" defines an object with complete metadata and typing information. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "Frame.to_json_values()": "Export a Frame as a JSON string constructed as follows: A JSON array of arrays of row values; no index or columns labels are included. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "Frame.to_latex()": "Display the Frame as a LaTeX formatted table.", "Frame.to_markdown()": "Display the Frame as a Markdown formatted table.", "Frame.to_npy()": "Write a Frame as a directory of npy file.", "Frame.to_npz()": "Write a Frame as an npz file.", "Frame.to_pairs()": "Return a tuple of major axis key, minor axis key vlaue pairs, where major axis is determined by the axis argument. Note that the returned object is eagerly constructed; use an iterator interface for lazy iteration.", "Frame.to_pandas()": "Return a Pandas DataFrame.", "Frame.to_parquet()": "Write an Arrow Parquet binary file.", "Frame.to_pickle()": "Write a Frame as a Python pickle. The pickle module is not secure. Only unpickle data you trust. Args: fp: file path to write. protocol: Pickle protocol to use.", "Frame.to_rst()": "Display the Frame as an RST formatted table.", "Frame.to_series()": "Return a Series representation of this Frame, where the index is extended with columns to from tuple labels for each element in the Frame. Args: index_constructor: Index constructor of the tuples produced by combining index and columns into one label. Providing IndexHierarchy.from_labels will produce a hierarchical index.", "Frame.to_sql()": "Write Frame to the database provided by connection. Connections to SQLite, PostgreSQL, MySQL, and MariaDB are fully supported. The table name can be provided by label, otherwise Frame.name will be used. If the target table does not exist, it will be created using optimal mappings to NumPy dtypes. If the target table exists, records will be appended. Parameterized insert queries are always used. Records will never be deleted, nor tables dropped. If using SQLAlchemy, pass the underlying DBAPI connection object (via the sqlalchemy.engine.Connection.connection attribute) as the conection. Args: label: Provide a name for the table; if not provided, Frame.name will be used if not None, else an exception will be raised. include_index: If True, the index will be included. schema: If provided, this string will be used as a database schema label to prefix the table name in all SQL queries. placeholder: String used as a placeholder in parameterized insert queries. Correct defaults are provided for SQLite, PostgreSQL, MySQL, and MariaDB. dtype_to_type_decl: Mapping from NumPy dtype to a string to be used in type declaration when creating tables. Sensible defaults are provided for SQLite, PostgreSQL, MySQL, and MariaDB.", "Frame.to_sqlite()": "Write the Frame as single-table SQLite file.", "Frame.to_tsv()": "Given a file path or file-like object, write the Frame as delimited text. The delimiter is set to a tab. Args: A file path, PathLib instance, or file-like object. * include_index: If True, the index will be written. include_index_name: If including columns, populate the row above the index with the index name. Cannot be True if include_columns_name is True. include_columns: If True, the columns will be written. include_columns_name: If including index, populate the column to the left of the columns with the columns name. Cannot be True if include_index_name is True. encoding: Encoding type to be used when opening the file. line_terminator: The string used to terminate lines. quote_char: A one-character string used to quote fields containing special characters, such as the delimiter or quote_char, or which contain new-line characters. quote_double: Controls how instances of quote_char appearing inside a field should themselves be quoted. When True, the character is doubled. When False, the escape_char is used as a prefix to the quote_char. It defaults to True. escape_char: A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE_NONE and the quotechar if quote_double is False. quoting: Controls when quotes should be generated. It can take on any of the QUOTE_* constants from the standard library csv module. store_filter: A StoreFilter instance.", "Frame.to_visidata()": "Open an interactive VisiData session.", "Frame.to_xarray()": "Return an xarray Dataset. In order to preserve columnar types, and following the precedent of Pandas, the Frame, with a 1D index, is translated as a Dataset of 1D arrays, where each DataArray is a 1D array. If the index is an IndexHierarchy, each column is mapped into an ND array of shape equal to the unique values found at each depth of the index.", "Frame.to_xlsx()": "Write the Frame as single-sheet XLSX file.", "Frame.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "Frame.T": "Transpose. Return a Frame with index as columns and vice versa.", "Frame.columns": "The IndexBase instance assigned for column labels.", "Frame.dtypes": "Return a Series of dytpes for each realizable column. Returns: Series", "Frame.index": "The IndexBase instance assigned for row labels.", "Frame.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "Frame.mloc": "The memory locations, represented as an array of integers, of the underlying NumPy arrays.", "Frame.name": "A hashable label attached to this container. Returns: Hashable", "Frame.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "Frame.ndim": "Return the number of dimensions, which for a Frame is always 2. Returns: int", "Frame.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int, int]", "Frame.size": "Return the size of the underlying NumPy array. Returns: int", "Frame.__array__()": "Support the __array__ interface, returning an array of values.", "Frame.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "Frame.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "Frame.__dataframe__()": "Return a data-frame interchange protocol compliant object. See https://data-apis.org/dataframe-protocol/latest for more information.", "Frame.__deepcopy__()": "", "Frame.__len__()": "Length of rows in values.", "Frame.__round__()": "Return a Frame rounded to the given decimals. Negative decimals round to the left of the decimal point. Args: decimals: number of decimals to round to. Returns: Frame", "Frame.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Frame.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Frame.astype[]()": "Selector of columns by label. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.", "Frame.astype()": "Apply a single dtype to all columns.", "Frame.clip()": "Apply a clip operation to this Frame. Note that clip operations can be applied to object types, but cannot be applied to non-numerical objects (e.g., strings, None) Args: lower: value, Series, Frame upper: value, Series, Frame axis: required if lower or upper are given as a Series.", "Frame.consolidate[]": "Return the full Frame, selecting with key a subset of columns for consolidation. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.", "Frame.consolidate()": "Apply consolidation to all columns.", "Frame.consolidate.status": "Display consolidation status of this Frame.", "Frame.corr()": "Compute a correlation matrix. Args: axis: if 0, each row represents a variable, with observations as columns; if 1, each column represents a variable, with observations as rows. Defaults to 1.", "Frame.count()": "Return the count of non-NA values along the provided axis, where 0 provides counts per column, 1 provides counts per row. Args: axis", "Frame.cov()": "Compute a covariance matrix. Args: axis: if 0, each row represents a variable, with observations as columns; if 1, each column represents a variable, with observations as rows. Defaults to 1. ddof: Delta degrees of freedom, defaults to 1.", "Frame.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Frame.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Frame.drop_duplicated()": "Return a Frame with duplicated rows (axis 0) or columns (axis 1) removed. All values in the row or column are compared to determine duplication. Args: axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. exclude_first: Boolean to select if the first duplicated value is excluded. exclude_last: Boolean to select if the last duplicated value is excluded.", "Frame.dropfalsy()": "Return a new Frame after removing rows (axis 0) or columns (axis 1) where any or all values are falsy. The condition is determined by a NumPy ufunc that process the Boolean array returned by isfalsy(); the default is np.all. Args: axis: condition:", "Frame.dropna()": "Return a new Frame after removing rows (axis 0) or columns (axis 1) where any or all values are NA (NaN or None). The condition is determined by a NumPy ufunc that process the Boolean array returned by isna(); the default is np.all. Args: axis: condition:", "Frame.duplicated()": "Return an axis-sized Boolean Series that shows True for all rows (axis 0) or columns (axis 1) duplicated. Args: axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. exclude_first: Boolean to select if the first duplicated value is excluded. exclude_last: Boolean to select if the last duplicated value is excluded.", "Frame.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "Frame.fillfalsy()": "Return a new Frame after replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "Frame.fillfalsy_backward()": "Return a new Frame after filling backward falsy values with the first observed value. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "Frame.fillfalsy_forward()": "Return a new Frame after filling forward falsy values with the last observed value. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "Frame.fillfalsy_leading()": "Return a new Frame after filling leading (and only leading) falsy values with the provided value. Args: value: Value to be used to replace missing values (NaN or None). axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "Frame.fillfalsy_trailing()": "Return a new Frame after filling trailing (and only trailing) falsy values with the provided value. Args: value: Value to be used to replace missing values (NaN or None). axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "Frame.fillna()": "Return a new Frame after replacing null (NaN or None) values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "Frame.fillna_backward()": "Return a new Frame after filling backward null (NaN or None) with the first observed value. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "Frame.fillna_forward()": "Return a new Frame after filling forward null (NaN or None) with the last observed value. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "Frame.fillna_leading()": "Return a new Frame after filling leading (and only leading) null (NaN or None) with the provided value. Args: value: Value to be used to replace missing values (NaN or None). axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "Frame.fillna_trailing()": "Return a new Frame after filling trailing (and only trailing) null (NaN or None) with the provided value. Args: value: Value to be used to replace missing values (NaN or None). axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "Frame.head()": "Return a Frame consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Frame", "Frame.iloc_max()": "Return the integer indices corresponding to the maximum values found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "Frame.iloc_min()": "Return the integer indices corresponding to the minimum values found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "Frame.iloc_notfalsy_first()": "Return the position corresponding to the first non-falsy (including nan) values along the selected axis. Args: {skipna} {axis}", "Frame.iloc_notfalsy_last()": "Return the position corresponding to the last non-falsy (including nan) values along the selected axis. Args: {skipna} {axis}", "Frame.iloc_notna_first()": "Return the position corresponding to the first non-missing values along the selected axis. Args: {skipna} {axis}", "Frame.iloc_notna_last()": "Return the position corresponding to the last non-missing values along the selected axis. Args: {skipna} {axis}", "Frame.insert_after()": "Create a new Frame by inserting a named Series or Frame at the position after the label specified by key. Args: key: Label after which the new container will be inserted. container: Container to be inserted. fill_value: A value to be used to fill space after reindexing the new container. Returns: Frame", "Frame.insert_before()": "Create a new Frame by inserting a named Series or Frame at the position before the label specified by key. Args: key: Label before which the new container will be inserted. container: Container to be inserted. fill_value: A value to be used to fill space after reindexing the new container. Returns: Frame", "Frame.isfalsy()": "Return a same-indexed, Boolean Frame indicating True which values are falsy.", "Frame.isin()": "Return a same-sized Boolean Frame that shows if the same-positioned element is in the passed iterable.", "Frame.isna()": "Return a same-indexed, Boolean Frame indicating True which values are NaN or None.", "Frame.join_inner()": "Perform an inner join. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "Frame.join_left()": "Perform a left outer join. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "Frame.join_outer()": "Perform an outer join. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "Frame.join_right()": "Perform a right outer join. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "Frame.loc_max()": "Return the labels corresponding to the maximum values found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "Frame.loc_min()": "Return the labels corresponding to the minimum value found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "Frame.loc_notfalsy_first()": "Return the labels corresponding to the first non-falsy (including nan) values along the selected axis. Args: {skipna} {axis}", "Frame.loc_notfalsy_last()": "Return the labels corresponding to the last non-falsy (including nan) values along the selected axis. Args: {skipna} {axis}", "Frame.loc_notna_first()": "Return the labels corresponding to the first non-missing values along the selected axis. Args: {skipna} {axis}", "Frame.loc_notna_last()": "Return the labels corresponding to the last non-missing values along the selected axis. Args: {skipna} {axis}", "Frame.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Frame.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Frame.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Frame.merge_inner()": "Perform an inner merge, an inner join where matched columns are coalesced. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. Provide a sequence of labels to be used for the merge fields. Must have a length equal to left and right selections. If not provided, merge fields will be named from the left. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "Frame.merge_left()": "Perform a left merge, a left join where matched columns are coalesced. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. Provide a sequence of labels to be used for the merge fields. Must have a length equal to left and right selections. If not provided, merge fields will be named from the left. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "Frame.merge_outer()": "Perform an outer merge, an outer join where matched columns are coalesced. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. Provide a sequence of labels to be used for the merge fields. Must have a length equal to left and right selections. If not provided, merge fields will be named from the left. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "Frame.merge_right()": "Perform a right merge, a right join where matched columns are coalesced. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. Provide a sequence of labels to be used for the merge fields. Must have a length equal to left and right selections. If not provided, merge fields will be named from the left. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "Frame.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Frame.notfalsy()": "Return a same-indexed, Boolean Frame indicating True which values are not falsy.", "Frame.notna()": "Return a same-indexed, Boolean Frame indicating True which values are not NaN or None.", "Frame.pivot()": "Produce a pivot table, where one or more columns is selected for each of index_fields, columns_fields, and data_fields. Unique values from the provided index_fields will be used to create a new index; unique values from the provided columns_fields will be used to create a new columns; if one data_fields value is selected, that is the value that will be displayed; if more than one values is given, those values will be presented with a hierarchical index on the columns; if data_fields is not provided, all unused fields will be displayed. Args: index_fields columns_fields data_fields * fill_value: If the index expansion produces coordinates that have no existing data value, fill that position with this value. func: function to apply to data_fields, or a dictionary of labelled functions to apply to data fields, producing an additional hierarchical level. index_constructor:", "Frame.pivot_stack()": "Move labels from the columns to the index, creating or extending an IndexHierarchy on the index. Args: depth_level: selection of columns depth or depth to move onto the index.", "Frame.pivot_unstack()": "Move labels from the index to the columns, creating or extending an IndexHierarchy on the columns. Args: depth_level: selection of index depth or depth to move onto the columns.", "Frame.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Frame.rank_dense()": "Rank values as compactly as possible, where ties get the same value, and ranks are contiguous (potentially non-unique) integers. Args: axis: Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row) skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Frame", "Frame.rank_max()": "Rank values where tied values are assigned the maximum ordinal rank; ranks are potentially non-contiguous and non-unique integers. Args: axis: Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row) skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Frame", "Frame.rank_mean()": "Rank values where tied values are assigned the mean of the ordinal ranks; ranks are potentially non-contiguous and non-unique floats. Args: axis: Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row) skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Frame", "Frame.rank_min()": "Rank values where tied values are assigned the minimum ordinal rank; ranks are potentially non-contiguous and non-unique integers. Args: axis: Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row) skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Frame", "Frame.rank_ordinal()": "Rank values distinctly, where ties get distinct values that maintain their ordering, and ranks are contiguous unique integers. Args: axis: Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row) skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Series", "Frame.rehierarch()": "Produce a new Frame with index and/or columns constructed with a transformed hierarchy. Args: index: Depth level specifier columns: Depth level specifier", "Frame.reindex()": "Return a new Frame with labels defined by the provided index. The size and ordering of the data is determined by the newly provided index, where data will continue to be aligned under labels found in both the new and the old index. Labels found only in the new index will be filled with fill_value. Args: index: An iterable of unique, hashable values, or another Index or IndexHierarchy, to be used as the labels of the index. columns: An iterable of unique, hashable values, or another Index or IndexHierarchy, to be used as the labels of the index. fill_value: A value to be used to fill space created by a new index that has values not found in the previous index. own_index: Flag the passed index as ownable by this Frame. Primarily used by internal clients. own_columns: Flag the passed columns as ownable by this Frame. Primarily used by internal clients. check_equals:", "Frame.relabel()": "Return a new Frame with transformed labels on the index. The size and ordering of the data is never changed in a relabeling operation. The resulting index must be unique. Args: index: One of the following types, used to create new index labels with the same size as the previous index. (a) A mapping (as a dictionary or Series), used to lookup and transform the labels in the previous index. Labels not found in the mapping will be reused. (b) A function, returning a hashable, that is applied to each label in the previous index. (c) The IndexAutoFactory type, to apply auto-incremented integer labels. (d) An Index initializer, i.e., either an iterable of hashables or an Index instance. columns: One of the following types, used to create new columns labels with the same size as the previous columns. (a) A mapping (as a dictionary or Series), used to lookup and transform the labels in the previous columns. Labels not found in the mapping will be reused. (b) A function, returning a hashable, that is applied to each label in the previous columns. (c) The IndexAutoFactory type, to apply auto-incremented integer labels. (d) An Index initializer, i.e., either an iterable of hashables or an Index instance.", "Frame.relabel_flat()": "Return a new Frame, where an IndexHierarchy (if defined) is replaced with a flat, one-dimension index of tuples. Args: index: Boolean to flag flatening on the index. columns: Boolean to flag flatening on the columns.", "Frame.relabel_level_add()": "Return a new Frame, adding a new root level to an existing IndexHierarchy, or creating an IndexHierarchy if one is not yet defined. Args: index: A hashable value to be used as a new root level, extending or creating an IndexHierarchy columns: A hashable value to be used as a new root level, extending or creating an IndexHierarchy * index_constructor: columns_constructor:", "Frame.relabel_level_drop()": "Return a new Frame, dropping one or more levels from a either the root or the leaves of an IndexHierarchy. The resulting index must be unique. Args: index: A positive integer drops that many outer-most (root) levels; a negative integer drops that many inner-most (leaf)levels. Default is zero. columns: A positive integer drops that many outer-most (root) levels; a negative integer drops that many inner-most (leaf)levels. Default is zero.", "Frame.relabel_shift_in()": "Create, or augment, an IndexHierarchy by providing one or more selections from the Frame (via axis-appropriate loc selections) to move into the Index. Args: key: a loc-style selection on the opposite axis. axis: 0 modifies the index by selecting columns with key; 1 modifies the columns by selecting rows with key.", "Frame.relabel_shift_out()": "Shift values from an index on an axis to the Frame by providing one or more depth level selections. Args: dpeth_level: an iloc-style selection on the Index of the specified axis. axis: 0 modifies the index by selecting columns with depth_level; 1 modifies the columns by selecting rows with depth_level.", "Frame.rename()": "Return a new Frame with an updated name attribute. Optionally update the name attribute of index and columns.", "Frame.roll()": "Roll columns and/or rows by positive or negative integer counts, where columns and/or rows roll around the axis. Args: include_index: Determine if index is included in index-wise rotation. include_columns: Determine if column index is included in index-wise rotation.", "Frame.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of labels to select from the index. Number of labels to select from the columns. Initial state of random selection.", "Frame.set_columns()": "Return a new Frame produced by setting the given row as the columns, optionally removing that row from the new Frame. Args: index: * drop: columns_constructor:", "Frame.set_columns_hierarchy()": "Given an iterable of index labels, return a new Frame with those rows as an IndexHierarchy on the columns. Args: index: Iterable of index labels. drop: Boolean to determine if selected rows should be removed from the data. columns_constructors: Optionally provide a sequence of Index constructors, of length equal to depth, to be used in converting row Index components in the IndexHierarchy. reorder_for_hierarchy: reorder the columns to produce a hierarchible Index from the selected columns. Returns: Frame", "Frame.set_index()": "Return a new Frame produced by setting the given column as the index, optionally removing that column from the new Frame. Args: column: * drop: index_constructor:", "Frame.set_index_hierarchy()": "Given an iterable of column labels, return a new Frame with those columns as an IndexHierarchy on the index. Args: columns: Iterable of column labels. drop: Boolean to determine if selected columns should be removed from the data. index_constructors: Optionally provide a sequence of Index constructors, of length equal to depth, to be used in converting columns Index components in the IndexHierarchy. reorder_for_hierarchy: reorder the rows to produce a hierarchible Index from the selected columns, assuming hierarchability is possible. Returns: Frame", "Frame.shift()": "Shift columns and/or rows by positive or negative integer counts, where columns and/or rows fall of the axis and introduce missing values, filled by fill_value.", "Frame.sort_columns()": "Return a new Frame ordered by the sorted columns. Args: ascendings: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "Frame.sort_index()": "Return a new Frame ordered by the sorted Index. Args: ascendings: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "Frame.sort_values()": "Return a new Frame ordered by the sorted values, where values are given by single column or iterable of columns. Args: label: A label or iterable of labels to select the columns (for axis 1) or rows (for axis 0) to sort. * ascendings: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. axis: Axis upon which to sort; 0 orders columns based on one or more rows; 1 orders rows based on one or more columns. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "Frame.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Frame.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Frame.tail()": "Return a Frame consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Frame", "Frame.transpose()": "Transpose. Return a Frame with index as columns and vice versa.", "Frame.unique()": "Return a NumPy array of unqiue values. If the axis argument is provided, uniqueness is determined by columns or row.", "Frame.unique_enumerated()": "{doc} {args}", "Frame.unset_columns()": "Return a new Frame where columns are added to the top of the data, and an IndexAutoFactory is used to populate new columns. This operation potentially forces a complete copy of all data. Args: names: An sequence of hashables to be used to name the unset columns. If an Index, a single hashable should be provided; if an IndexHierarchy, as many hashables as the depth must be provided. index_constructors:", "Frame.unset_index()": "Return a new Frame where the index is added to the front of the data, and an IndexAutoFactory is used to populate a new index. If the Index has a name, that name will be used for the column name, otherwise a suitable default will be used. As underlying NumPy arrays are immutable, data is not copied. Args: names: An iterable of hashables to be used to name the unset index. If an Index, a single hashable should be provided; if an IndexHierarchy, as many hashables as the depth must be provided. consolidate_blocks: columns_constructors:", "Frame.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Frame.__contains__()": "Inclusion of value in column labels.", "Frame.__iter__()": "Iterator of column labels, same as Frame.keys.", "Frame.__reversed__()": "Returns a reverse iterator on the frame's columns.", "Frame.get()": "Return the value found at the columns key, else the default if the key is not found. This method is implemented to complete the dictionary-like interface.", "Frame.items()": "Iterator of pairs of column label and corresponding column Series.", "Frame.keys()": "Iterator of column labels.", "Frame.values": "A 2D NumPy array of all values in the Frame. As this is a single array, heterogenous columnar types might be coerced to a compatible type.", "Frame.interface": "A Frame documenting the interface of this class.", "Frame.__repr__()": "", "Frame.__str__()": "Return str(self).", "Frame.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Frame.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Frame.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Frame.assign[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, Frame, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "Frame.assign[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Frame.assign[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Frame.assign[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Frame.assign.iloc[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, Frame, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "Frame.assign.iloc[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Frame.assign.iloc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Frame.assign.iloc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Frame.assign.loc[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, Frame, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "Frame.assign.loc[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Frame.assign.loc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Frame.assign.loc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Frame.assign.bloc[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, Frame, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "Frame.assign.bloc[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Frame.assign.bloc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Frame.assign.bloc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "Frame.bloc[]": "", "Frame.drop[]": "Label-based selection.", "Frame.drop.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "Frame.drop.loc[]": "", "Frame.mask[]": "Label-based selection.", "Frame.mask.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "Frame.mask.loc[]": "", "Frame.masked_array[]": "Label-based selection.", "Frame.masked_array.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "Frame.masked_array.loc[]": "", "Frame.[]": "Selector of columns by label. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.", "Frame.iloc[]": "", "Frame.loc[]": "", "Frame.iter_array()": "Iterator of np.array, where arrays are drawn from columns (axis=0) or rows (axis=1)", "Frame.iter_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_array_items()": "Iterator of pairs of label, np.array, where arrays are drawn from columns (axis=0) or rows (axis=1)", "Frame.iter_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_element()": "Iterator of elements, ordered by row then column.", "Frame.iter_element().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_element().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_element().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_element().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_element().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_element().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "Frame.iter_element().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "Frame.iter_element().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_element().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "Frame.iter_element().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "Frame.iter_element().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_element().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "Frame.iter_element().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "Frame.iter_element_items()": "Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.", "Frame.iter_element_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_element_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_element_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_element_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_element_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_element_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "Frame.iter_element_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "Frame.iter_element_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_element_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "Frame.iter_element_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "Frame.iter_element_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_element_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "Frame.iter_element_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "Frame.iter_group()": "Iterator of Frame grouped by unique values found in one or more columns (axis=0) or rows (axis=1).", "Frame.iter_group().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_group().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_group().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_group().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_group().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group().reduce.from_map_func().keys()": "", "Frame.iter_group().reduce.from_map_func().__iter__()": "", "Frame.iter_group().reduce.from_map_func().items()": "", "Frame.iter_group().reduce.from_map_func().values()": "", "Frame.iter_group().reduce.from_map_func().to_frame()": "", "Frame.iter_group().reduce.from_label_map().keys()": "", "Frame.iter_group().reduce.from_label_map().__iter__()": "", "Frame.iter_group().reduce.from_label_map().items()": "", "Frame.iter_group().reduce.from_label_map().values()": "", "Frame.iter_group().reduce.from_label_map().to_frame()": "", "Frame.iter_group().reduce.from_label_pair_map().keys()": "", "Frame.iter_group().reduce.from_label_pair_map().__iter__()": "", "Frame.iter_group().reduce.from_label_pair_map().items()": "", "Frame.iter_group().reduce.from_label_pair_map().values()": "", "Frame.iter_group().reduce.from_label_pair_map().to_frame()": "", "Frame.iter_group_array()": "Iterator of np.ndarray grouped by unique values found in one or more columns (axis=0) or rows (axis=1).", "Frame.iter_group_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_group_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_group_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_group_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_group_array().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_array().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_array().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_array().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_array().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_array().reduce.from_map_func().keys()": "", "Frame.iter_group_array().reduce.from_map_func().__iter__()": "", "Frame.iter_group_array().reduce.from_map_func().items()": "", "Frame.iter_group_array().reduce.from_map_func().values()": "", "Frame.iter_group_array().reduce.from_map_func().to_frame()": "", "Frame.iter_group_array().reduce.from_label_map().keys()": "", "Frame.iter_group_array().reduce.from_label_map().__iter__()": "", "Frame.iter_group_array().reduce.from_label_map().items()": "", "Frame.iter_group_array().reduce.from_label_map().values()": "", "Frame.iter_group_array().reduce.from_label_map().to_frame()": "", "Frame.iter_group_array().reduce.from_label_pair_map().keys()": "", "Frame.iter_group_array().reduce.from_label_pair_map().__iter__()": "", "Frame.iter_group_array().reduce.from_label_pair_map().items()": "", "Frame.iter_group_array().reduce.from_label_pair_map().values()": "", "Frame.iter_group_array().reduce.from_label_pair_map().to_frame()": "", "Frame.iter_group_array_items()": "Iterator of pairs of label, np.ndarray grouped by unique values found in one or more columns (axis=0) or rows (axis=1).", "Frame.iter_group_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_group_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_group_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_group_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_group_array_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_array_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_array_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_array_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_array_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_array_items().reduce.from_map_func().keys()": "", "Frame.iter_group_array_items().reduce.from_map_func().__iter__()": "", "Frame.iter_group_array_items().reduce.from_map_func().items()": "", "Frame.iter_group_array_items().reduce.from_map_func().values()": "", "Frame.iter_group_array_items().reduce.from_map_func().to_frame()": "", "Frame.iter_group_array_items().reduce.from_label_map().keys()": "", "Frame.iter_group_array_items().reduce.from_label_map().__iter__()": "", "Frame.iter_group_array_items().reduce.from_label_map().items()": "", "Frame.iter_group_array_items().reduce.from_label_map().values()": "", "Frame.iter_group_array_items().reduce.from_label_map().to_frame()": "", "Frame.iter_group_array_items().reduce.from_label_pair_map().keys()": "", "Frame.iter_group_array_items().reduce.from_label_pair_map().__iter__()": "", "Frame.iter_group_array_items().reduce.from_label_pair_map().items()": "", "Frame.iter_group_array_items().reduce.from_label_pair_map().values()": "", "Frame.iter_group_array_items().reduce.from_label_pair_map().to_frame()": "", "Frame.iter_group_items()": "Iterator of pairs of label, Frame grouped by unique values found in one or more columns (axis=0) or rows (axis=1).", "Frame.iter_group_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_group_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_group_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_group_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_group_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_items().reduce.from_map_func().keys()": "", "Frame.iter_group_items().reduce.from_map_func().__iter__()": "", "Frame.iter_group_items().reduce.from_map_func().items()": "", "Frame.iter_group_items().reduce.from_map_func().values()": "", "Frame.iter_group_items().reduce.from_map_func().to_frame()": "", "Frame.iter_group_items().reduce.from_label_map().keys()": "", "Frame.iter_group_items().reduce.from_label_map().__iter__()": "", "Frame.iter_group_items().reduce.from_label_map().items()": "", "Frame.iter_group_items().reduce.from_label_map().values()": "", "Frame.iter_group_items().reduce.from_label_map().to_frame()": "", "Frame.iter_group_items().reduce.from_label_pair_map().keys()": "", "Frame.iter_group_items().reduce.from_label_pair_map().__iter__()": "", "Frame.iter_group_items().reduce.from_label_pair_map().items()": "", "Frame.iter_group_items().reduce.from_label_pair_map().values()": "", "Frame.iter_group_items().reduce.from_label_pair_map().to_frame()": "", "Frame.iter_group_labels()": "Iterator of Frame grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).", "Frame.iter_group_labels().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_group_labels().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_group_labels().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_group_labels().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_group_labels_array()": "Iterator of np.ndarray grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).", "Frame.iter_group_labels_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_group_labels_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_group_labels_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_group_labels_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_group_labels_array_items()": "Iterator of pairs of label, np.ndarray grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).", "Frame.iter_group_labels_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_group_labels_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_group_labels_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_group_labels_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_group_labels_items()": "Iterator of pairs of label, Frame grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).", "Frame.iter_group_labels_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_group_labels_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_group_labels_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_group_labels_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_group_other()": "Iterator of Frame grouped by unique values found in a supplied container.", "Frame.iter_group_other().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_group_other().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_group_other().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_group_other().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_group_other().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other().reduce.from_map_func().keys()": "", "Frame.iter_group_other().reduce.from_map_func().__iter__()": "", "Frame.iter_group_other().reduce.from_map_func().items()": "", "Frame.iter_group_other().reduce.from_map_func().values()": "", "Frame.iter_group_other().reduce.from_map_func().to_frame()": "", "Frame.iter_group_other().reduce.from_label_map().keys()": "", "Frame.iter_group_other().reduce.from_label_map().__iter__()": "", "Frame.iter_group_other().reduce.from_label_map().items()": "", "Frame.iter_group_other().reduce.from_label_map().values()": "", "Frame.iter_group_other().reduce.from_label_map().to_frame()": "", "Frame.iter_group_other().reduce.from_label_pair_map().keys()": "", "Frame.iter_group_other().reduce.from_label_pair_map().__iter__()": "", "Frame.iter_group_other().reduce.from_label_pair_map().items()": "", "Frame.iter_group_other().reduce.from_label_pair_map().values()": "", "Frame.iter_group_other().reduce.from_label_pair_map().to_frame()": "", "Frame.iter_group_other_array()": "Iterator of Frame grouped by unique values found in a supplied container.", "Frame.iter_group_other_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_group_other_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_group_other_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_group_other_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_group_other_array().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other_array().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other_array().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other_array().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other_array().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other_array().reduce.from_map_func().keys()": "", "Frame.iter_group_other_array().reduce.from_map_func().__iter__()": "", "Frame.iter_group_other_array().reduce.from_map_func().items()": "", "Frame.iter_group_other_array().reduce.from_map_func().values()": "", "Frame.iter_group_other_array().reduce.from_map_func().to_frame()": "", "Frame.iter_group_other_array().reduce.from_label_map().keys()": "", "Frame.iter_group_other_array().reduce.from_label_map().__iter__()": "", "Frame.iter_group_other_array().reduce.from_label_map().items()": "", "Frame.iter_group_other_array().reduce.from_label_map().values()": "", "Frame.iter_group_other_array().reduce.from_label_map().to_frame()": "", "Frame.iter_group_other_array().reduce.from_label_pair_map().keys()": "", "Frame.iter_group_other_array().reduce.from_label_pair_map().__iter__()": "", "Frame.iter_group_other_array().reduce.from_label_pair_map().items()": "", "Frame.iter_group_other_array().reduce.from_label_pair_map().values()": "", "Frame.iter_group_other_array().reduce.from_label_pair_map().to_frame()": "", "Frame.iter_group_other_array_items()": "Iterator of Frame grouped by unique values found in a supplied container.", "Frame.iter_group_other_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_group_other_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_group_other_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_group_other_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_group_other_array_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other_array_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other_array_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other_array_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other_array_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other_array_items().reduce.from_map_func().keys()": "", "Frame.iter_group_other_array_items().reduce.from_map_func().__iter__()": "", "Frame.iter_group_other_array_items().reduce.from_map_func().items()": "", "Frame.iter_group_other_array_items().reduce.from_map_func().values()": "", "Frame.iter_group_other_array_items().reduce.from_map_func().to_frame()": "", "Frame.iter_group_other_array_items().reduce.from_label_map().keys()": "", "Frame.iter_group_other_array_items().reduce.from_label_map().__iter__()": "", "Frame.iter_group_other_array_items().reduce.from_label_map().items()": "", "Frame.iter_group_other_array_items().reduce.from_label_map().values()": "", "Frame.iter_group_other_array_items().reduce.from_label_map().to_frame()": "", "Frame.iter_group_other_array_items().reduce.from_label_pair_map().keys()": "", "Frame.iter_group_other_array_items().reduce.from_label_pair_map().__iter__()": "", "Frame.iter_group_other_array_items().reduce.from_label_pair_map().items()": "", "Frame.iter_group_other_array_items().reduce.from_label_pair_map().values()": "", "Frame.iter_group_other_array_items().reduce.from_label_pair_map().to_frame()": "", "Frame.iter_group_other_items()": "Iterator of Frame grouped by unique values found in a supplied container.", "Frame.iter_group_other_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_group_other_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_group_other_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_group_other_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_group_other_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_group_other_items().reduce.from_map_func().keys()": "", "Frame.iter_group_other_items().reduce.from_map_func().__iter__()": "", "Frame.iter_group_other_items().reduce.from_map_func().items()": "", "Frame.iter_group_other_items().reduce.from_map_func().values()": "", "Frame.iter_group_other_items().reduce.from_map_func().to_frame()": "", "Frame.iter_group_other_items().reduce.from_label_map().keys()": "", "Frame.iter_group_other_items().reduce.from_label_map().__iter__()": "", "Frame.iter_group_other_items().reduce.from_label_map().items()": "", "Frame.iter_group_other_items().reduce.from_label_map().values()": "", "Frame.iter_group_other_items().reduce.from_label_map().to_frame()": "", "Frame.iter_group_other_items().reduce.from_label_pair_map().keys()": "", "Frame.iter_group_other_items().reduce.from_label_pair_map().__iter__()": "", "Frame.iter_group_other_items().reduce.from_label_pair_map().items()": "", "Frame.iter_group_other_items().reduce.from_label_pair_map().values()": "", "Frame.iter_group_other_items().reduce.from_label_pair_map().to_frame()": "", "Frame.iter_series()": "Iterator of Series, where Series are drawn from columns (axis=0) or rows (axis=1)", "Frame.iter_series().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_series().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_series().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_series().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_series_items()": "Iterator of pairs of label, Series, where Series are drawn from columns (axis=0) or rows (axis=1)", "Frame.iter_series_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_series_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_series_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_series_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_tuple()": "Iterator of NamedTuple, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional constructor callable can be used to provide a NamedTuple class (or any other constructor called with a single iterable) to be used to create each yielded axis value.", "Frame.iter_tuple().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_tuple().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_tuple().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_tuple().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_tuple().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_tuple().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "Frame.iter_tuple().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "Frame.iter_tuple().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_tuple().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "Frame.iter_tuple().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "Frame.iter_tuple().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_tuple().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "Frame.iter_tuple().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "Frame.iter_tuple_items()": "Iterator of pairs of label, NamedTuple, where tuples are drawn from columns (axis=0) or rows (axis=1)", "Frame.iter_tuple_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_tuple_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_tuple_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_tuple_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_tuple_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_tuple_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "Frame.iter_tuple_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "Frame.iter_tuple_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_tuple_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "Frame.iter_tuple_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "Frame.iter_tuple_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_tuple_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "Frame.iter_tuple_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "Frame.iter_window()": "Iterator of windowed values, where values are given as a Frame. Args: size: Elements per window, given as an integer greater than 0. axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. step: Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the size will result in non-overlapping windows. window_sized: if True, windows with fewer elements than size are skipped. window_func: Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window. window_valid: Function that, given an array window, returns True if the window is valid; invalid windows are skipped. label_shift: A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, label_shift can be set to one less than size. label_missing_skips: If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label. label_missing_raises: If True, a window that cannot derive a label will raise an exception. start_shift: A shift to determine the first element where window collection begins. size_increment: A value to be added to size with each window after the first, so as to, in combination with setting step to 0, permit iterating over expanding windows.", "Frame.iter_window().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_window().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_window().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_window().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_window().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window().reduce.from_map_func().keys()": "", "Frame.iter_window().reduce.from_map_func().__iter__()": "", "Frame.iter_window().reduce.from_map_func().items()": "", "Frame.iter_window().reduce.from_map_func().values()": "", "Frame.iter_window().reduce.from_map_func().to_frame()": "", "Frame.iter_window().reduce.from_label_map().keys()": "", "Frame.iter_window().reduce.from_label_map().__iter__()": "", "Frame.iter_window().reduce.from_label_map().items()": "", "Frame.iter_window().reduce.from_label_map().values()": "", "Frame.iter_window().reduce.from_label_map().to_frame()": "", "Frame.iter_window().reduce.from_label_pair_map().keys()": "", "Frame.iter_window().reduce.from_label_pair_map().__iter__()": "", "Frame.iter_window().reduce.from_label_pair_map().items()": "", "Frame.iter_window().reduce.from_label_pair_map().values()": "", "Frame.iter_window().reduce.from_label_pair_map().to_frame()": "", "Frame.iter_window_array()": "Iterator of windowed values, where values are given as a np.array. Args: size: Elements per window, given as an integer greater than 0. axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. step: Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the size will result in non-overlapping windows. window_sized: if True, windows with fewer elements than size are skipped. window_func: Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window. window_valid: Function that, given an array window, returns True if the window is valid; invalid windows are skipped. label_shift: A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, label_shift can be set to one less than size. label_missing_skips: If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label. label_missing_raises: If True, a window that cannot derive a label will raise an exception. start_shift: A shift to determine the first element where window collection begins. size_increment: A value to be added to size with each window after the first, so as to, in combination with setting step to 0, permit iterating over expanding windows.", "Frame.iter_window_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_window_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_window_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_window_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_window_array().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window_array().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window_array().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window_array().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window_array().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window_array().reduce.from_map_func().keys()": "", "Frame.iter_window_array().reduce.from_map_func().__iter__()": "", "Frame.iter_window_array().reduce.from_map_func().items()": "", "Frame.iter_window_array().reduce.from_map_func().values()": "", "Frame.iter_window_array().reduce.from_map_func().to_frame()": "", "Frame.iter_window_array().reduce.from_label_map().keys()": "", "Frame.iter_window_array().reduce.from_label_map().__iter__()": "", "Frame.iter_window_array().reduce.from_label_map().items()": "", "Frame.iter_window_array().reduce.from_label_map().values()": "", "Frame.iter_window_array().reduce.from_label_map().to_frame()": "", "Frame.iter_window_array().reduce.from_label_pair_map().keys()": "", "Frame.iter_window_array().reduce.from_label_pair_map().__iter__()": "", "Frame.iter_window_array().reduce.from_label_pair_map().items()": "", "Frame.iter_window_array().reduce.from_label_pair_map().values()": "", "Frame.iter_window_array().reduce.from_label_pair_map().to_frame()": "", "Frame.iter_window_array_items()": "Iterator of pairs of label, windowed values, where values are given as a np.array. Args: size: Elements per window, given as an integer greater than 0. axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. step: Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the size will result in non-overlapping windows. window_sized: if True, windows with fewer elements than size are skipped. window_func: Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window. window_valid: Function that, given an array window, returns True if the window is valid; invalid windows are skipped. label_shift: A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, label_shift can be set to one less than size. label_missing_skips: If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label. label_missing_raises: If True, a window that cannot derive a label will raise an exception. start_shift: A shift to determine the first element where window collection begins. size_increment: A value to be added to size with each window after the first, so as to, in combination with setting step to 0, permit iterating over expanding windows.", "Frame.iter_window_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_window_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_window_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_window_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_window_array_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window_array_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window_array_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window_array_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window_array_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window_array_items().reduce.from_map_func().keys()": "", "Frame.iter_window_array_items().reduce.from_map_func().__iter__()": "", "Frame.iter_window_array_items().reduce.from_map_func().items()": "", "Frame.iter_window_array_items().reduce.from_map_func().values()": "", "Frame.iter_window_array_items().reduce.from_map_func().to_frame()": "", "Frame.iter_window_array_items().reduce.from_label_map().keys()": "", "Frame.iter_window_array_items().reduce.from_label_map().__iter__()": "", "Frame.iter_window_array_items().reduce.from_label_map().items()": "", "Frame.iter_window_array_items().reduce.from_label_map().values()": "", "Frame.iter_window_array_items().reduce.from_label_map().to_frame()": "", "Frame.iter_window_array_items().reduce.from_label_pair_map().keys()": "", "Frame.iter_window_array_items().reduce.from_label_pair_map().__iter__()": "", "Frame.iter_window_array_items().reduce.from_label_pair_map().items()": "", "Frame.iter_window_array_items().reduce.from_label_pair_map().values()": "", "Frame.iter_window_array_items().reduce.from_label_pair_map().to_frame()": "", "Frame.iter_window_items()": "Iterator of pairs of label, windowed values, where values are given as a Frame. Args: size: Elements per window, given as an integer greater than 0. axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. step: Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the size will result in non-overlapping windows. window_sized: if True, windows with fewer elements than size are skipped. window_func: Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window. window_valid: Function that, given an array window, returns True if the window is valid; invalid windows are skipped. label_shift: A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, label_shift can be set to one less than size. label_missing_skips: If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label. label_missing_raises: If True, a window that cannot derive a label will raise an exception. start_shift: A shift to determine the first element where window collection begins. size_increment: A value to be added to size with each window after the first, so as to, in combination with setting step to 0, permit iterating over expanding windows.", "Frame.iter_window_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Frame.iter_window_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Frame.iter_window_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Frame.iter_window_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Frame.iter_window_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.iter_window_items().reduce.from_map_func().keys()": "", "Frame.iter_window_items().reduce.from_map_func().__iter__()": "", "Frame.iter_window_items().reduce.from_map_func().items()": "", "Frame.iter_window_items().reduce.from_map_func().values()": "", "Frame.iter_window_items().reduce.from_map_func().to_frame()": "", "Frame.iter_window_items().reduce.from_label_map().keys()": "", "Frame.iter_window_items().reduce.from_label_map().__iter__()": "", "Frame.iter_window_items().reduce.from_label_map().items()": "", "Frame.iter_window_items().reduce.from_label_map().values()": "", "Frame.iter_window_items().reduce.from_label_map().to_frame()": "", "Frame.iter_window_items().reduce.from_label_pair_map().keys()": "", "Frame.iter_window_items().reduce.from_label_pair_map().__iter__()": "", "Frame.iter_window_items().reduce.from_label_pair_map().items()": "", "Frame.iter_window_items().reduce.from_label_pair_map().values()": "", "Frame.iter_window_items().reduce.from_label_pair_map().to_frame()": "", "Frame.__add__()": "", "Frame.__and__()": "", "Frame.__eq__()": "", "Frame.__floordiv__()": "", "Frame.__ge__()": "", "Frame.__gt__()": "", "Frame.__le__()": "", "Frame.__lt__()": "", "Frame.__matmul__()": "", "Frame.__mod__()": "", "Frame.__mul__()": "", "Frame.__ne__()": "", "Frame.__or__()": "", "Frame.__pow__()": "", "Frame.__radd__()": "", "Frame.__rfloordiv__()": "", "Frame.__rmatmul__()": "", "Frame.__rmul__()": "", "Frame.__rshift__()": "", "Frame.__rsub__()": "", "Frame.__rtruediv__()": "", "Frame.__sub__()": "", "Frame.__truediv__()": "", "Frame.__xor__()": "", "Frame.__abs__()": "", "Frame.__invert__()": "", "Frame.__neg__()": "", "Frame.__pos__()": "", "Frame.abs()": "", "Frame.via_values.apply()": "", "Frame.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "Frame.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "Frame.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "Frame.via_dt.year": "Return the year of each element.", "Frame.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "Frame.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "Frame.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "Frame.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "Frame.via_dt.hour": "Return the hour of each element, between 0 and 24.", "Frame.via_dt.minute": "Return the minute of each element, between 0 and 60.", "Frame.via_dt.second": "Return the second of each element, between 0 and 60.", "Frame.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "Frame.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "Frame.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "Frame.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "Frame.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "Frame.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "Frame.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "Frame.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "Frame.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "Frame.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "Frame.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "Frame.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "Frame.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "Frame.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "Frame.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "Frame.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "Frame.via_str.center()": "Return a container with its elements centered in a string of length width.", "Frame.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "Frame.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "Frame.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "Frame.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "Frame.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "Frame.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "Frame.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "Frame.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "Frame.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "Frame.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "Frame.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "Frame.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "Frame.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "Frame.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "Frame.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "Frame.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "Frame.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "Frame.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "Frame.via_str.len()": "Return the length of the string.", "Frame.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "Frame.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "Frame.via_str.partition()": "Partition each element around sep.", "Frame.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "Frame.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "Frame.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "Frame.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "Frame.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "Frame.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "Frame.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "Frame.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "Frame.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "Frame.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "Frame.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "Frame.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "Frame.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "Frame.via_str.zfill()": "Return the string left-filled with zeros.", "Frame.via_T.via_fill_value()": "Interface for using binary operators and methods with a pre-defined fill value.", "Frame.via_T.__add__()": "", "Frame.via_T.__sub__()": "", "Frame.via_T.__mul__()": "", "Frame.via_T.__truediv__()": "", "Frame.via_T.__floordiv__()": "", "Frame.via_T.__mod__()": "", "Frame.via_T.__pow__()": "", "Frame.via_T.__lshift__()": "", "Frame.via_T.__rshift__()": "", "Frame.via_T.__and__()": "", "Frame.via_T.__xor__()": "", "Frame.via_T.__or__()": "", "Frame.via_T.__lt__()": "", "Frame.via_T.__le__()": "", "Frame.via_T.__eq__()": "", "Frame.via_T.__ne__()": "", "Frame.via_T.__gt__()": "", "Frame.via_T.__ge__()": "", "Frame.via_T.__radd__()": "", "Frame.via_T.__rsub__()": "", "Frame.via_T.__rmul__()": "", "Frame.via_T.__rtruediv__()": "", "Frame.via_T.__rfloordiv__()": "", "Frame.via_fill_value().loc": "Label-based selection where labels not specified will define a new container containing those labels filled with the fill value.", "Frame.via_fill_value().__getitem__()": "Label-based selection where labels not specified will define a new container containing those labels filled with the fill value.", "Frame.via_fill_value().via_T": "Interface for using binary operators with one-dimensional sequences, where the opperand is applied column-wise.", "Frame.via_fill_value().__add__()": "", "Frame.via_fill_value().__sub__()": "", "Frame.via_fill_value().__mul__()": "", "Frame.via_fill_value().__truediv__()": "", "Frame.via_fill_value().__floordiv__()": "", "Frame.via_fill_value().__mod__()": "", "Frame.via_fill_value().__pow__()": "", "Frame.via_fill_value().__lshift__()": "", "Frame.via_fill_value().__rshift__()": "", "Frame.via_fill_value().__and__()": "", "Frame.via_fill_value().__xor__()": "", "Frame.via_fill_value().__or__()": "", "Frame.via_fill_value().__lt__()": "", "Frame.via_fill_value().__le__()": "", "Frame.via_fill_value().__eq__()": "", "Frame.via_fill_value().__ne__()": "", "Frame.via_fill_value().__gt__()": "", "Frame.via_fill_value().__ge__()": "", "Frame.via_fill_value().__radd__()": "", "Frame.via_fill_value().__rsub__()": "", "Frame.via_fill_value().__rmul__()": "", "Frame.via_fill_value().__rtruediv__()": "", "Frame.via_fill_value().__rfloordiv__()": "", "Frame.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "Frame.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "Frame.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "Frame.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "Frame.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "Frame.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "Frame.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "Frame.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "Frame.via_hashlib().md5()": "", "Frame.via_hashlib().sha256()": "", "Frame.via_hashlib().sha512()": "", "Frame.via_hashlib().sha3_256()": "", "Frame.via_hashlib().sha3_512()": "", "Frame.via_hashlib().shake_128()": "", "Frame.via_hashlib().shake_256()": "", "Frame.via_hashlib().blake2b()": "", "Frame.via_hashlib().blake2s()": "", "Frame.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "Frame.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "Frame.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "Frame.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "Frame.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "Frame.reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Frame.reduce.from_map_func().keys()": "For each Frame, reduce by applying, for each column, a function that reduces to (0-dimensional) elements, where the column label and function are given as a mapping. Column labels are retained.", "Frame.reduce.from_map_func().__iter__()": "For each Frame, reduce by applying, for each column, a function that reduces to (0-dimensional) elements, where the column label and function are given as a mapping. Column labels are retained.", "Frame.reduce.from_map_func().items()": "For each Frame, reduce by applying, for each column, a function that reduces to (0-dimensional) elements, where the column label and function are given as a mapping. Column labels are retained.", "Frame.reduce.from_map_func().values()": "For each Frame, reduce by applying, for each column, a function that reduces to (0-dimensional) elements, where the column label and function are given as a mapping. Column labels are retained.", "Frame.reduce.from_map_func().to_frame()": "For each Frame, reduce by applying, for each column, a function that reduces to (0-dimensional) elements, where the column label and function are given as a mapping. Column labels are retained.", "Frame.reduce.from_label_map().keys()": "For Frame, reduce by applying a function to each column, where the column label and function are given as a mapping. Column labels are retained. Args: func_map: a mapping of column labels to functions.", "Frame.reduce.from_label_map().__iter__()": "For Frame, reduce by applying a function to each column, where the column label and function are given as a mapping. Column labels are retained. Args: func_map: a mapping of column labels to functions.", "Frame.reduce.from_label_map().items()": "For Frame, reduce by applying a function to each column, where the column label and function are given as a mapping. Column labels are retained. Args: func_map: a mapping of column labels to functions.", "Frame.reduce.from_label_map().values()": "For Frame, reduce by applying a function to each column, where the column label and function are given as a mapping. Column labels are retained. Args: func_map: a mapping of column labels to functions.", "Frame.reduce.from_label_map().to_frame()": "For Frame, reduce by applying a function to each column, where the column label and function are given as a mapping. Column labels are retained. Args: func_map: a mapping of column labels to functions.", "Frame.reduce.from_label_pair_map().keys()": "For Frame, reduce by applying a function to a column and assigning the result a new label. Functions are provided as values in a mapping, where the key is tuple of source label, destination label. Args: func_map: a mapping of pairs of source label, destination label, to a function.", "Frame.reduce.from_label_pair_map().__iter__()": "For Frame, reduce by applying a function to a column and assigning the result a new label. Functions are provided as values in a mapping, where the key is tuple of source label, destination label. Args: func_map: a mapping of pairs of source label, destination label, to a function.", "Frame.reduce.from_label_pair_map().items()": "For Frame, reduce by applying a function to a column and assigning the result a new label. Functions are provided as values in a mapping, where the key is tuple of source label, destination label. Args: func_map: a mapping of pairs of source label, destination label, to a function.", "Frame.reduce.from_label_pair_map().values()": "For Frame, reduce by applying a function to a column and assigning the result a new label. Functions are provided as values in a mapping, where the key is tuple of source label, destination label. Args: func_map: a mapping of pairs of source label, destination label, to a function.", "Frame.reduce.from_label_pair_map().to_frame()": "For Frame, reduce by applying a function to a column and assigning the result a new label. Functions are provided as values in a mapping, where the key is tuple of source label, destination label. Args: func_map: a mapping of pairs of source label, destination label, to a function.", "FrameGO.__init__()": "Initializer. Args: data: Default Frame initialization requires typed data such as a NumPy array. All other initialization should use specialized constructors. index: Optional index initializer. If provided in addition to data values, lengths must be compatible. columns: Optional column initializer. If provided in addition to data values, lengths must be compatible. index_constructor: columns_constructor: own_data: Flag the data values as ownable by this Frame. Primarily used by internal clients. own_index: Flag the passed index as ownable by this Frame. Primarily used by internal clients. own_columns: Flag the passed columns as ownable by this Frame. Primarily used by internal clients.", "FrameGO.from_arrow()": "Realize a Frame from an Arrow Table. Args: value: A pyarrow.Table instance. index_depth: integer specification of how many columns to use in forming the index. A value of 0 will select none; a value greater than 1 will create an IndexHierarchy. columns_depth: integer specification of how many rows to use in forming the columns. A value of 0 will select none; a value greater than 1 will create an IndexHierarchy. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameGO.from_clipboard()": "Create a Frame from the contents of the clipboard (assuming a table is stored as delimited file). Returns: Frame", "FrameGO.from_concat()": "Concatenate multiple Frame or Series into a new Frame. If index or columns are provided and appropriately sized, the resulting Frame will use those indices. If the axis along concatenation (index for axis 0, columns for axis 1) is unique after concatenation, it will be preserved; otherwise, a new index or an IndexAutoFactory must be supplied. Args: frames: Iterable of Frames. axis: Integer specifying 0 to concatenate supplied Frames vertically (aligning on columns), 1 to concatenate horizontally (aligning on rows). union: If True, the union of the aligned indices is used; if False, the intersection is used. index: Optionally specify a new index. columns: Optionally specify new columns. index_constructor: Optionally apply a constructor to the derived or passed labels. columns_constructor: Optionally apply a constructor to the derived or passed labels. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameGO.from_concat_items()": "Produce a Frame with a hierarchical index from an iterable of pairs of labels, Frame. The IndexHierarchy is formed from the provided labels and the Index if each Frame. Args: items: Iterable of pairs of label, Frame axis: union: name: fill_value: index_constructor: columns_constructor: consolidate_blocks:", "FrameGO.from_csv()": "Specialized version of Frame.from_delimited for CSV files. Returns: Frame", "FrameGO.from_delimited()": "Create a Frame from a file path or a file-like object defining a delimited (CSV, TSV) data file. Args: fp: A file path or a file-like object. delimiter: The character used to seperate row elements. index_depth: Specify the number of columns used to create the index labels; a value greater than 1 will attempt to create a hierarchical index. index_column_first: Optionally specify a column, by position in the realized columns, to become the start of the index if index_depth is greater than 0 and columns_depth is 0. index_name_depth_level: If columns_depth is greater than 0, interpret values over index as the index name. index_constructors: index_continuation_token: columns_depth: Specify the number of rows after the skip_header used to create the column labels. A value of 0 will be no header; a value greater than 1 will attempt to create a hierarchical index. columns_name_depth_level: If index_depth is greater than 0, interpret values over index as the columns name. columns_constructors: columns_continuation_token: columns_select: an iterable of columns to select by label or position; can only be used if index_depth is 0. skip_header: Number of leading lines to skip. skip_footer: Number of trailing lines to skip. store_filter: A StoreFilter instance, defining translation between unrepresentable strings and types. By default it is disabled, and only empty fields or \"NAN\" are intepreted as NaN. To force usage, set the type of the column to string. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameGO.from_dict()": "Create a Frame from a dictionary (or any object that has an items() method) where keys are column labels and values are columns values (either sequence types or Series). Args: mapping: a dictionary or similar mapping interface. index: fill_value: dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. index_constructor: columns_constructor: consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays.", "FrameGO.from_dict_fields()": "Frame constructor from an iterable of dictionaries, where each dictionary represents a column; index labels will be derived from the union of all column dictionary keys. Args: fields: Iterable of column values, where column values are dictionaries. index: Optionally provide an iterable of index labels, equal in length to the number of fields. If a generator, this value will not be evaluated until after fields are loaded. columns: dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameGO.from_dict_records()": "Frame constructor from an iterable of dictionaries, where each dictionary represents a row; column names will be derived from the union of all row dictionary keys. Args: records: Iterable of row values, where row values are dictionaries. index: Optionally provide an iterable of index labels, equal in length to the number of records. If a generator, this value will not be evaluated until after records are loaded. index: dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameGO.from_dict_records_items()": "Frame constructor from iterable of pairs of index label, row, where row is a dictionary. Column names will be derived from the union of all row dictionary keys. Args: items: Iterable of pairs of index label, row values, where row values are arrays, tuples, lists, dictionaries, or namedtuples. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameGO.from_element()": "Create a Frame from an element, i.e., a single value stored in a single cell. Both index and columns are required, and cannot be specified with IndexAutoFactory.", "FrameGO.from_element_items()": "Create a Frame from an iterable of key, value, where key is a pair of row, column labels. This function is partialed (setting the index and columns) and used by IterNodeDelegate as the apply constructor for doing application on element iteration. Args: items: an iterable of pairs of 2-tuples of row, column loc labels and values. axis: when None, items can be in an order; when 0, items must be well-formed and ordered row major; when 1, items must be well-formed and ordered columns major. Returns: Frame", "FrameGO.from_elements()": "Create a Frame from an iterable of elements, to be formed into a Frame with a single column.", "FrameGO.from_fields()": "Frame constructor from an iterator of columns, where columns are iterables. Series can be provided as values if an index argument is supplied. This constructor is similar to from_items(), though here columns are provided through an independent columns argument. Args: fields: Iterable of column values. index: Iterable of values to create an Index. fill_value: If pairs include Series, they will be reindexed with the provided index; reindexing will use this fill value. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameGO.from_items()": "Frame constructor from an iterator of pairs, where the first value is the column label and the second value is an iterable of column values. Series can be provided as values if an index argument is supplied. Args: pairs: Iterable of pairs of column name, column values. index: Iterable of values to create an Index. fill_value: If pairs include Series, they will be reindexed with the provided index; reindexing will use this fill value. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. index_constructor: columns_constructor: consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameGO.from_json_columns()": "Frame constructor from an in-memory JSON document in the following format: A JSON object keyed by column labels, where values are columns represented by an object mapping of index labels to values. Args: json_data: a string or StringIO of JSON data dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameGO.from_json_index()": "Frame constructor from an in-memory JSON document in the following format: A JSON object keyed by index labels, where values are rows represented by an object mapping of column labels to values. Args: json_data: a string or StringIO of JSON data dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameGO.from_json_records()": "Frame constructor from an in-memory JSON document in the following format: A JSON array of row objects, where column labels are repeated for each row, and no index labels are included. Args: json_data: a string or StringIO of JSON data dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameGO.from_json_split()": "Frame constructor from an in-memory JSON document in the following format: A JSON object with a key for \"columns\", \"index\", and \"data\", where data is given as an array of arrays of row values. Args: json_data: a string or StringIO of JSON data dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameGO.from_json_typed()": "Frame constructor from an in-memory JSON document in the following format: A JSON object with a key for \"columns\", \"index\", and \"data\", where data is given as an array of arrays of column values; additionally, a key for \"__meta__\" defines an object with complete metadata and typing information. Args: json_data: a string or StringIO of JSON data Returns: Frame", "FrameGO.from_json_values()": "Frame constructor from an in-memory JSON document in the following format: A JSON array of arrays of row values; no index or columns labels are included. Args: json_data: a string or StringIO of JSON data dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameGO.from_npy()": "Create a Frame from an directory of npy files. Args: fp: The path to the NPY directory.", "FrameGO.from_npy_mmap()": "Create a Frame from an directory of npy files using memory maps. Args: fp: The path to the NPY directory. Returns: A tuple of Frame and the callable needed to close the open memory map objects. On some platforms this must be called before the process exits.", "FrameGO.from_npz()": "Create a Frame from an npz file.", "FrameGO.from_overlay()": "Return a new Frame made by overlaying containers, filling in values with aligned values from subsequent containers. Values are filled based on a passed function that must return a Boolean array. By default, that function is isna_array, returning True for missing values (NaN and None). Args: containers: Iterable of Frame. index: An optional Index, IndexHierarchy, or index initializer, to be used as the index upon which all containers are aligned. IndexAutoFactory is not supported. columns: An optional Index, IndexHierarchy, or columns initializer, to be used as the columns upon which all containers are aligned. IndexAutoFactory is not supported. union: If True, and no index or columns argument is supplied, a union index or columns from containers will be used; if False, the intersection index or columns will be used. name: func: A function that takes an array and returns a same-sized Boolean array, where True indicates availability for insertion.", "FrameGO.from_pandas()": "Given a Pandas DataFrame, return a Frame. Args: value: Pandas DataFrame. index_constructor: Optional class or constructor function to create the Index applied to the rows. columns_constructor: Optional class or constructor function to create the Index applied to the columns. dtypes: consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. own_data: If True, the underlying NumPy data array will be made immutable and used without a copy. Returns: Frame", "FrameGO.from_parquet()": "Realize a Frame from a Parquet file. Args: fp: A string file path or Path instance. index_depth: integer specification of how many columns to use in forming the index. A value of 0 will select none; a value greater than 1 will create an IndexHierarchy. index_name_depth_level: index_constructors: columns_depth: integer specification of how many rows to use in forming the columns. A value of 0 will select none; a value greater than 1 will create an IndexHierarchy. columns_name_depth_level: columns_constructors: columns_select: An optional iterable of column names to load. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays.", "FrameGO.from_pickle()": "Create a Frame from a pickle file. The pickle module is not secure. Only unpickle data you trust. Args: fp: The path to the pickle file.", "FrameGO.from_records()": "Construct a Frame from an iterable of rows, where rows are defined as iterables, including tuples, lists, and arrays. If each row is a NamedTuple, and columns is not provided, column names will be derived from the NamedTuple fields. Supplying dtypes will significantly improve performance, as otherwise columnar array types must be derived by element-wise examination. For records defined as Series, use Frame.from_concat; for records defined as dictionary, use Frame.from_dict_records; for creating a Frame from a single dictionary, where keys are column labels and values are columns, use Frame.from_dict. Args: records: Iterable of row values, where row values are arrays, tuples, lists, or namedtuples. For dictionary records, use Frame.from_dict_records. index: Optionally provide an iterable of index labels, equal in length to the number of records. If a generator, this value will not be evaluated until after records are loaded. columns: Optionally provide an iterable of column labels, equal in length to the number of elements in a row. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameGO.from_records_items()": "Frame constructor from iterable of pairs of index value, row (where row is an iterable). Args: items: Iterable of pairs of index label, row values, where row values are arrays, tuples, lists, dictionaries, or namedtuples. columns: Optionally provide an iterable of column labels, equal in length to the length of each row. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameGO.from_series()": "Frame constructor from a Series: Args: series: A Series instance, to be realized as single column, with the column label taken from the name attribute.", "FrameGO.from_sql()": "Frame constructor from an SQL query and a database connection object. Args: query: A query string. connection: A DBAPI2 (PEP 249) Connection object, such as those returned from SQLite (via the sqlite3 module) or PyODBC. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. index_depth: index_constructors: columns_depth: columns_select: An optional iterable of field names to extract from the results of the query. columns_constructors: name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. parameters: Provide a list of values for an SQL query expecting parameter substitution.", "FrameGO.from_sqlite()": "Load Frame from the contents of a table in an SQLite database file.", "FrameGO.from_structured_array()": "Convert a NumPy structed array into a Frame. Args: array: Structured NumPy array. index_depth: Depth if index levels, where (for example) 0 is no index, 1 is a single column index, and 2 is a two-columns IndexHierarchy. index_column_first: Optionally provide the name or position offset of the column to use as the index. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameGO.from_tsv()": "Specialized version of Frame.from_delimited for TSV files. Returns: Frame", "FrameGO.from_xlsx()": "Load Frame from the contents of a sheet in an XLSX workbook. Args: label: Optionally provide the sheet name from which to read. If not provided, the first sheet will be used.", "FrameGO.to_arrow()": "Return a pyarrow.Table from this Frame.", "FrameGO.to_clipboard()": "Given a file path or file-like object, write the Frame as delimited text. The delimiter defaults to a tab. Args: A file path, PathLib instance, or file-like object. * delimiter: Character to be used for delimiterarating elements. include_index: If True, the index will be written. include_index_name: If including columns, populate the row above the index with the index name. Cannot be True if include_columns_name is True. include_columns: If True, the columns will be written. include_columns_name: If including index, populate the column to the left of the columns with the columns name. Cannot be True if include_index_name is True. encoding: Encoding type to be used when opening the file. line_terminator: The string used to terminate lines. quote_char: A one-character string used to quote fields containing special characters, such as the delimiter or quote_char, or which contain new-line characters. quote_double: Controls how instances of quote_char appearing inside a field should themselves be quoted. When True, the character is doubled. When False, the escape_char is used as a prefix to the quote_char. It defaults to True. escape_char: A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE_NONE and the quotechar if quote_double is False. quoting: Controls when quotes should be generated. It can take on any of the QUOTE_* constants from the standard library csv module. store_filter: A StoreFilter instance.", "FrameGO.to_csv()": "Given a file path or file-like object, write the Frame as delimited text. The delimiter is set to a comma. Args: A file path, PathLib instance, or file-like object. * include_index: If True, the index will be written. include_index_name: If including columns, populate the row above the index with the index name. Cannot be True if include_columns_name is True. include_columns: If True, the columns will be written. include_columns_name: If including index, populate the column to the left of the columns with the columns name. Cannot be True if include_index_name is True. encoding: Encoding type to be used when opening the file. line_terminator: The string used to terminate lines. quote_char: A one-character string used to quote fields containing special characters, such as the delimiter or quote_char, or which contain new-line characters. quote_double: Controls how instances of quote_char appearing inside a field should themselves be quoted. When True, the character is doubled. When False, the escape_char is used as a prefix to the quote_char. It defaults to True. escape_char: A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE_NONE and the quotechar if quote_double is False. quoting: Controls when quotes should be generated. It can take on any of the QUOTE_* constants from the standard library csv module. store_filter: A StoreFilter instance.", "FrameGO.to_delimited()": "Given a file path or file-like object, write the Frame as delimited text. A delimiter character must be specified. Args: A file path, PathLib instance, or file-like object. * delimiter: Character to be used for delimiterarating elements. include_index: If True, the index will be written. include_index_name: If including columns, populate the row above the index with the index name. Cannot be True if include_columns_name is True. include_columns: If True, the columns will be written. include_columns_name: If including index, populate the column to the left of the columns with the columns name. Cannot be True if include_index_name is True. encoding: Encoding type to be used when opening the file. line_terminator: The string used to terminate lines. quote_char: A one-character string used to quote fields containing special characters, such as the delimiter or quote_char, or which contain new-line characters. quote_double: Controls how instances of quote_char appearing inside a field should themselves be quoted. When True, the character is doubled. When False, the escape_char is used as a prefix to the quote_char. It defaults to True. escape_char: A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE_NONE and the quotechar if quote_double is False. quoting: Controls when quotes should be generated. It can take on any of the QUOTE_* constants from the standard library csv module. store_filter: A StoreFilter instance.", "FrameGO.to_frame()": "Return Frame instance from this Frame. If this Frame is immutable the same instance will be returned.", "FrameGO.to_frame_go()": "Return a FrameGO instance from this Frame.", "FrameGO.to_frame_he()": "Return a FrameHE instance from this Frame. If this Frame is immutable the same instance will be returned.", "FrameGO.to_html()": "Return an HTML table representation of this Frame using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "FrameGO.to_html_datatables()": "Return a complete HTML representation of this Frame using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "FrameGO.to_json_columns()": "Export a Frame as a JSON string constructed as follows: A JSON object keyed by column labels, where values are columns represented by an object mapping of index labels to values. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "FrameGO.to_json_index()": "Export a Frame as a JSON string constructed as follows: A JSON object keyed by index labels, where values are rows represented by an object mapping of column labels to values. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "FrameGO.to_json_records()": "Export a Frame as a JSON string constructed as follows: A JSON array of row objects, where column labels are repeated for each row, and no index labels are included. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "FrameGO.to_json_split()": "Export a Frame as a JSON string constructed as follows: A JSON object with a key for \"columns\", \"index\", and \"data\", where data is given as an array of arrays of row values. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "FrameGO.to_json_typed()": "Export a Frame as a JSON string constructed as follows: A JSON object with a key for \"columns\", \"index\", and \"data\", where data is given as an array of arrays of column values; additionally, a key for \"__meta__\" defines an object with complete metadata and typing information. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "FrameGO.to_json_values()": "Export a Frame as a JSON string constructed as follows: A JSON array of arrays of row values; no index or columns labels are included. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "FrameGO.to_latex()": "Display the Frame as a LaTeX formatted table.", "FrameGO.to_markdown()": "Display the Frame as a Markdown formatted table.", "FrameGO.to_npy()": "Write a Frame as a directory of npy file.", "FrameGO.to_npz()": "Write a Frame as an npz file.", "FrameGO.to_pairs()": "Return a tuple of major axis key, minor axis key vlaue pairs, where major axis is determined by the axis argument. Note that the returned object is eagerly constructed; use an iterator interface for lazy iteration.", "FrameGO.to_pandas()": "Return a Pandas DataFrame.", "FrameGO.to_parquet()": "Write an Arrow Parquet binary file.", "FrameGO.to_pickle()": "Write a Frame as a Python pickle. The pickle module is not secure. Only unpickle data you trust. Args: fp: file path to write. protocol: Pickle protocol to use.", "FrameGO.to_rst()": "Display the Frame as an RST formatted table.", "FrameGO.to_series()": "Return a Series representation of this Frame, where the index is extended with columns to from tuple labels for each element in the Frame. Args: index_constructor: Index constructor of the tuples produced by combining index and columns into one label. Providing IndexHierarchy.from_labels will produce a hierarchical index.", "FrameGO.to_sql()": "Write Frame to the database provided by connection. Connections to SQLite, PostgreSQL, MySQL, and MariaDB are fully supported. The table name can be provided by label, otherwise Frame.name will be used. If the target table does not exist, it will be created using optimal mappings to NumPy dtypes. If the target table exists, records will be appended. Parameterized insert queries are always used. Records will never be deleted, nor tables dropped. If using SQLAlchemy, pass the underlying DBAPI connection object (via the sqlalchemy.engine.Connection.connection attribute) as the conection. Args: label: Provide a name for the table; if not provided, Frame.name will be used if not None, else an exception will be raised. include_index: If True, the index will be included. schema: If provided, this string will be used as a database schema label to prefix the table name in all SQL queries. placeholder: String used as a placeholder in parameterized insert queries. Correct defaults are provided for SQLite, PostgreSQL, MySQL, and MariaDB. dtype_to_type_decl: Mapping from NumPy dtype to a string to be used in type declaration when creating tables. Sensible defaults are provided for SQLite, PostgreSQL, MySQL, and MariaDB.", "FrameGO.to_sqlite()": "Write the Frame as single-table SQLite file.", "FrameGO.to_tsv()": "Given a file path or file-like object, write the Frame as delimited text. The delimiter is set to a tab. Args: A file path, PathLib instance, or file-like object. * include_index: If True, the index will be written. include_index_name: If including columns, populate the row above the index with the index name. Cannot be True if include_columns_name is True. include_columns: If True, the columns will be written. include_columns_name: If including index, populate the column to the left of the columns with the columns name. Cannot be True if include_index_name is True. encoding: Encoding type to be used when opening the file. line_terminator: The string used to terminate lines. quote_char: A one-character string used to quote fields containing special characters, such as the delimiter or quote_char, or which contain new-line characters. quote_double: Controls how instances of quote_char appearing inside a field should themselves be quoted. When True, the character is doubled. When False, the escape_char is used as a prefix to the quote_char. It defaults to True. escape_char: A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE_NONE and the quotechar if quote_double is False. quoting: Controls when quotes should be generated. It can take on any of the QUOTE_* constants from the standard library csv module. store_filter: A StoreFilter instance.", "FrameGO.to_visidata()": "Open an interactive VisiData session.", "FrameGO.to_xarray()": "Return an xarray Dataset. In order to preserve columnar types, and following the precedent of Pandas, the Frame, with a 1D index, is translated as a Dataset of 1D arrays, where each DataArray is a 1D array. If the index is an IndexHierarchy, each column is mapped into an ND array of shape equal to the unique values found at each depth of the index.", "FrameGO.to_xlsx()": "Write the Frame as single-sheet XLSX file.", "FrameGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "FrameGO.T": "Transpose. Return a Frame with index as columns and vice versa.", "FrameGO.columns": "The IndexBase instance assigned for column labels.", "FrameGO.dtypes": "Return a Series of dytpes for each realizable column. Returns: Series", "FrameGO.index": "The IndexBase instance assigned for row labels.", "FrameGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "FrameGO.mloc": "The memory locations, represented as an array of integers, of the underlying NumPy arrays.", "FrameGO.name": "A hashable label attached to this container. Returns: Hashable", "FrameGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "FrameGO.ndim": "Return the number of dimensions, which for a Frame is always 2. Returns: int", "FrameGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int, int]", "FrameGO.size": "Return the size of the underlying NumPy array. Returns: int", "FrameGO.__array__()": "Support the __array__ interface, returning an array of values.", "FrameGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "FrameGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "FrameGO.__dataframe__()": "Return a data-frame interchange protocol compliant object. See https://data-apis.org/dataframe-protocol/latest for more information.", "FrameGO.__deepcopy__()": "", "FrameGO.__len__()": "Length of rows in values.", "FrameGO.__round__()": "Return a Frame rounded to the given decimals. Negative decimals round to the left of the decimal point. Args: decimals: number of decimals to round to. Returns: Frame", "FrameGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameGO.astype[]()": "Selector of columns by label. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.", "FrameGO.astype()": "Apply a single dtype to all columns.", "FrameGO.clip()": "Apply a clip operation to this Frame. Note that clip operations can be applied to object types, but cannot be applied to non-numerical objects (e.g., strings, None) Args: lower: value, Series, Frame upper: value, Series, Frame axis: required if lower or upper are given as a Series.", "FrameGO.consolidate[]": "Return the full Frame, selecting with key a subset of columns for consolidation. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.", "FrameGO.consolidate()": "Apply consolidation to all columns.", "FrameGO.consolidate.status": "Display consolidation status of this Frame.", "FrameGO.corr()": "Compute a correlation matrix. Args: axis: if 0, each row represents a variable, with observations as columns; if 1, each column represents a variable, with observations as rows. Defaults to 1.", "FrameGO.count()": "Return the count of non-NA values along the provided axis, where 0 provides counts per column, 1 provides counts per row. Args: axis", "FrameGO.cov()": "Compute a covariance matrix. Args: axis: if 0, each row represents a variable, with observations as columns; if 1, each column represents a variable, with observations as rows. Defaults to 1. ddof: Delta degrees of freedom, defaults to 1.", "FrameGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameGO.drop_duplicated()": "Return a Frame with duplicated rows (axis 0) or columns (axis 1) removed. All values in the row or column are compared to determine duplication. Args: axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. exclude_first: Boolean to select if the first duplicated value is excluded. exclude_last: Boolean to select if the last duplicated value is excluded.", "FrameGO.dropfalsy()": "Return a new Frame after removing rows (axis 0) or columns (axis 1) where any or all values are falsy. The condition is determined by a NumPy ufunc that process the Boolean array returned by isfalsy(); the default is np.all. Args: axis: condition:", "FrameGO.dropna()": "Return a new Frame after removing rows (axis 0) or columns (axis 1) where any or all values are NA (NaN or None). The condition is determined by a NumPy ufunc that process the Boolean array returned by isna(); the default is np.all. Args: axis: condition:", "FrameGO.duplicated()": "Return an axis-sized Boolean Series that shows True for all rows (axis 0) or columns (axis 1) duplicated. Args: axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. exclude_first: Boolean to select if the first duplicated value is excluded. exclude_last: Boolean to select if the last duplicated value is excluded.", "FrameGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "FrameGO.extend()": "Extend this FrameGO (in-place) with another Frame's blocks or Series array; as blocks are immutable, this is a no-copy operation when indices align. If indices do not align, the passed-in Frame or Series will be reindexed (as happens when adding a column to a FrameGO). If a Series is passed in, the column name will be taken from the Series name attribute. This method differs from FrameGO.extend_items() by permitting contiguous underlying blocks to be extended from another Frame into this Frame.", "FrameGO.extend_items()": "Given an iterable of pairs of column name, column value, extend this FrameGO. Columns values can be any iterable suitable for usage in __setitem__.", "FrameGO.fillfalsy()": "Return a new Frame after replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "FrameGO.fillfalsy_backward()": "Return a new Frame after filling backward falsy values with the first observed value. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameGO.fillfalsy_forward()": "Return a new Frame after filling forward falsy values with the last observed value. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameGO.fillfalsy_leading()": "Return a new Frame after filling leading (and only leading) falsy values with the provided value. Args: value: Value to be used to replace missing values (NaN or None). axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameGO.fillfalsy_trailing()": "Return a new Frame after filling trailing (and only trailing) falsy values with the provided value. Args: value: Value to be used to replace missing values (NaN or None). axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameGO.fillna()": "Return a new Frame after replacing null (NaN or None) values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "FrameGO.fillna_backward()": "Return a new Frame after filling backward null (NaN or None) with the first observed value. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameGO.fillna_forward()": "Return a new Frame after filling forward null (NaN or None) with the last observed value. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameGO.fillna_leading()": "Return a new Frame after filling leading (and only leading) null (NaN or None) with the provided value. Args: value: Value to be used to replace missing values (NaN or None). axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameGO.fillna_trailing()": "Return a new Frame after filling trailing (and only trailing) null (NaN or None) with the provided value. Args: value: Value to be used to replace missing values (NaN or None). axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameGO.head()": "Return a Frame consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Frame", "FrameGO.iloc_max()": "Return the integer indices corresponding to the maximum values found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameGO.iloc_min()": "Return the integer indices corresponding to the minimum values found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameGO.iloc_notfalsy_first()": "Return the position corresponding to the first non-falsy (including nan) values along the selected axis. Args: {skipna} {axis}", "FrameGO.iloc_notfalsy_last()": "Return the position corresponding to the last non-falsy (including nan) values along the selected axis. Args: {skipna} {axis}", "FrameGO.iloc_notna_first()": "Return the position corresponding to the first non-missing values along the selected axis. Args: {skipna} {axis}", "FrameGO.iloc_notna_last()": "Return the position corresponding to the last non-missing values along the selected axis. Args: {skipna} {axis}", "FrameGO.insert_after()": "Create a new Frame by inserting a named Series or Frame at the position after the label specified by key. Args: key: Label after which the new container will be inserted. container: Container to be inserted. fill_value: A value to be used to fill space after reindexing the new container. Returns: Frame", "FrameGO.insert_before()": "Create a new Frame by inserting a named Series or Frame at the position before the label specified by key. Args: key: Label before which the new container will be inserted. container: Container to be inserted. fill_value: A value to be used to fill space after reindexing the new container. Returns: Frame", "FrameGO.isfalsy()": "Return a same-indexed, Boolean Frame indicating True which values are falsy.", "FrameGO.isin()": "Return a same-sized Boolean Frame that shows if the same-positioned element is in the passed iterable.", "FrameGO.isna()": "Return a same-indexed, Boolean Frame indicating True which values are NaN or None.", "FrameGO.join_inner()": "Perform an inner join. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "FrameGO.join_left()": "Perform a left outer join. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "FrameGO.join_outer()": "Perform an outer join. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "FrameGO.join_right()": "Perform a right outer join. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "FrameGO.loc_max()": "Return the labels corresponding to the maximum values found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameGO.loc_min()": "Return the labels corresponding to the minimum value found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameGO.loc_notfalsy_first()": "Return the labels corresponding to the first non-falsy (including nan) values along the selected axis. Args: {skipna} {axis}", "FrameGO.loc_notfalsy_last()": "Return the labels corresponding to the last non-falsy (including nan) values along the selected axis. Args: {skipna} {axis}", "FrameGO.loc_notna_first()": "Return the labels corresponding to the first non-missing values along the selected axis. Args: {skipna} {axis}", "FrameGO.loc_notna_last()": "Return the labels corresponding to the last non-missing values along the selected axis. Args: {skipna} {axis}", "FrameGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameGO.merge_inner()": "Perform an inner merge, an inner join where matched columns are coalesced. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. Provide a sequence of labels to be used for the merge fields. Must have a length equal to left and right selections. If not provided, merge fields will be named from the left. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "FrameGO.merge_left()": "Perform a left merge, a left join where matched columns are coalesced. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. Provide a sequence of labels to be used for the merge fields. Must have a length equal to left and right selections. If not provided, merge fields will be named from the left. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "FrameGO.merge_outer()": "Perform an outer merge, an outer join where matched columns are coalesced. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. Provide a sequence of labels to be used for the merge fields. Must have a length equal to left and right selections. If not provided, merge fields will be named from the left. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "FrameGO.merge_right()": "Perform a right merge, a right join where matched columns are coalesced. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. Provide a sequence of labels to be used for the merge fields. Must have a length equal to left and right selections. If not provided, merge fields will be named from the left. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "FrameGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameGO.notfalsy()": "Return a same-indexed, Boolean Frame indicating True which values are not falsy.", "FrameGO.notna()": "Return a same-indexed, Boolean Frame indicating True which values are not NaN or None.", "FrameGO.pivot()": "Produce a pivot table, where one or more columns is selected for each of index_fields, columns_fields, and data_fields. Unique values from the provided index_fields will be used to create a new index; unique values from the provided columns_fields will be used to create a new columns; if one data_fields value is selected, that is the value that will be displayed; if more than one values is given, those values will be presented with a hierarchical index on the columns; if data_fields is not provided, all unused fields will be displayed. Args: index_fields columns_fields data_fields * fill_value: If the index expansion produces coordinates that have no existing data value, fill that position with this value. func: function to apply to data_fields, or a dictionary of labelled functions to apply to data fields, producing an additional hierarchical level. index_constructor:", "FrameGO.pivot_stack()": "Move labels from the columns to the index, creating or extending an IndexHierarchy on the index. Args: depth_level: selection of columns depth or depth to move onto the index.", "FrameGO.pivot_unstack()": "Move labels from the index to the columns, creating or extending an IndexHierarchy on the columns. Args: depth_level: selection of index depth or depth to move onto the columns.", "FrameGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameGO.rank_dense()": "Rank values as compactly as possible, where ties get the same value, and ranks are contiguous (potentially non-unique) integers. Args: axis: Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row) skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Frame", "FrameGO.rank_max()": "Rank values where tied values are assigned the maximum ordinal rank; ranks are potentially non-contiguous and non-unique integers. Args: axis: Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row) skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Frame", "FrameGO.rank_mean()": "Rank values where tied values are assigned the mean of the ordinal ranks; ranks are potentially non-contiguous and non-unique floats. Args: axis: Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row) skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Frame", "FrameGO.rank_min()": "Rank values where tied values are assigned the minimum ordinal rank; ranks are potentially non-contiguous and non-unique integers. Args: axis: Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row) skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Frame", "FrameGO.rank_ordinal()": "Rank values distinctly, where ties get distinct values that maintain their ordering, and ranks are contiguous unique integers. Args: axis: Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row) skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Series", "FrameGO.rehierarch()": "Produce a new Frame with index and/or columns constructed with a transformed hierarchy. Args: index: Depth level specifier columns: Depth level specifier", "FrameGO.reindex()": "Return a new Frame with labels defined by the provided index. The size and ordering of the data is determined by the newly provided index, where data will continue to be aligned under labels found in both the new and the old index. Labels found only in the new index will be filled with fill_value. Args: index: An iterable of unique, hashable values, or another Index or IndexHierarchy, to be used as the labels of the index. columns: An iterable of unique, hashable values, or another Index or IndexHierarchy, to be used as the labels of the index. fill_value: A value to be used to fill space created by a new index that has values not found in the previous index. own_index: Flag the passed index as ownable by this Frame. Primarily used by internal clients. own_columns: Flag the passed columns as ownable by this Frame. Primarily used by internal clients. check_equals:", "FrameGO.relabel()": "Return a new Frame with transformed labels on the index. The size and ordering of the data is never changed in a relabeling operation. The resulting index must be unique. Args: index: One of the following types, used to create new index labels with the same size as the previous index. (a) A mapping (as a dictionary or Series), used to lookup and transform the labels in the previous index. Labels not found in the mapping will be reused. (b) A function, returning a hashable, that is applied to each label in the previous index. (c) The IndexAutoFactory type, to apply auto-incremented integer labels. (d) An Index initializer, i.e., either an iterable of hashables or an Index instance. columns: One of the following types, used to create new columns labels with the same size as the previous columns. (a) A mapping (as a dictionary or Series), used to lookup and transform the labels in the previous columns. Labels not found in the mapping will be reused. (b) A function, returning a hashable, that is applied to each label in the previous columns. (c) The IndexAutoFactory type, to apply auto-incremented integer labels. (d) An Index initializer, i.e., either an iterable of hashables or an Index instance.", "FrameGO.relabel_flat()": "Return a new Frame, where an IndexHierarchy (if defined) is replaced with a flat, one-dimension index of tuples. Args: index: Boolean to flag flatening on the index. columns: Boolean to flag flatening on the columns.", "FrameGO.relabel_level_add()": "Return a new Frame, adding a new root level to an existing IndexHierarchy, or creating an IndexHierarchy if one is not yet defined. Args: index: A hashable value to be used as a new root level, extending or creating an IndexHierarchy columns: A hashable value to be used as a new root level, extending or creating an IndexHierarchy * index_constructor: columns_constructor:", "FrameGO.relabel_level_drop()": "Return a new Frame, dropping one or more levels from a either the root or the leaves of an IndexHierarchy. The resulting index must be unique. Args: index: A positive integer drops that many outer-most (root) levels; a negative integer drops that many inner-most (leaf)levels. Default is zero. columns: A positive integer drops that many outer-most (root) levels; a negative integer drops that many inner-most (leaf)levels. Default is zero.", "FrameGO.relabel_shift_in()": "Create, or augment, an IndexHierarchy by providing one or more selections from the Frame (via axis-appropriate loc selections) to move into the Index. Args: key: a loc-style selection on the opposite axis. axis: 0 modifies the index by selecting columns with key; 1 modifies the columns by selecting rows with key.", "FrameGO.relabel_shift_out()": "Shift values from an index on an axis to the Frame by providing one or more depth level selections. Args: dpeth_level: an iloc-style selection on the Index of the specified axis. axis: 0 modifies the index by selecting columns with depth_level; 1 modifies the columns by selecting rows with depth_level.", "FrameGO.rename()": "Return a new Frame with an updated name attribute. Optionally update the name attribute of index and columns.", "FrameGO.roll()": "Roll columns and/or rows by positive or negative integer counts, where columns and/or rows roll around the axis. Args: include_index: Determine if index is included in index-wise rotation. include_columns: Determine if column index is included in index-wise rotation.", "FrameGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of labels to select from the index. Number of labels to select from the columns. Initial state of random selection.", "FrameGO.set_columns()": "Return a new Frame produced by setting the given row as the columns, optionally removing that row from the new Frame. Args: index: * drop: columns_constructor:", "FrameGO.set_columns_hierarchy()": "Given an iterable of index labels, return a new Frame with those rows as an IndexHierarchy on the columns. Args: index: Iterable of index labels. drop: Boolean to determine if selected rows should be removed from the data. columns_constructors: Optionally provide a sequence of Index constructors, of length equal to depth, to be used in converting row Index components in the IndexHierarchy. reorder_for_hierarchy: reorder the columns to produce a hierarchible Index from the selected columns. Returns: Frame", "FrameGO.set_index()": "Return a new Frame produced by setting the given column as the index, optionally removing that column from the new Frame. Args: column: * drop: index_constructor:", "FrameGO.set_index_hierarchy()": "Given an iterable of column labels, return a new Frame with those columns as an IndexHierarchy on the index. Args: columns: Iterable of column labels. drop: Boolean to determine if selected columns should be removed from the data. index_constructors: Optionally provide a sequence of Index constructors, of length equal to depth, to be used in converting columns Index components in the IndexHierarchy. reorder_for_hierarchy: reorder the rows to produce a hierarchible Index from the selected columns, assuming hierarchability is possible. Returns: Frame", "FrameGO.shift()": "Shift columns and/or rows by positive or negative integer counts, where columns and/or rows fall of the axis and introduce missing values, filled by fill_value.", "FrameGO.sort_columns()": "Return a new Frame ordered by the sorted columns. Args: ascendings: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "FrameGO.sort_index()": "Return a new Frame ordered by the sorted Index. Args: ascendings: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "FrameGO.sort_values()": "Return a new Frame ordered by the sorted values, where values are given by single column or iterable of columns. Args: label: A label or iterable of labels to select the columns (for axis 1) or rows (for axis 0) to sort. * ascendings: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. axis: Axis upon which to sort; 0 orders columns based on one or more rows; 1 orders rows based on one or more columns. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "FrameGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameGO.tail()": "Return a Frame consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Frame", "FrameGO.transpose()": "Transpose. Return a Frame with index as columns and vice versa.", "FrameGO.unique()": "Return a NumPy array of unqiue values. If the axis argument is provided, uniqueness is determined by columns or row.", "FrameGO.unique_enumerated()": "{doc} {args}", "FrameGO.unset_columns()": "Return a new Frame where columns are added to the top of the data, and an IndexAutoFactory is used to populate new columns. This operation potentially forces a complete copy of all data. Args: names: An sequence of hashables to be used to name the unset columns. If an Index, a single hashable should be provided; if an IndexHierarchy, as many hashables as the depth must be provided. index_constructors:", "FrameGO.unset_index()": "Return a new Frame where the index is added to the front of the data, and an IndexAutoFactory is used to populate a new index. If the Index has a name, that name will be used for the column name, otherwise a suitable default will be used. As underlying NumPy arrays are immutable, data is not copied. Args: names: An iterable of hashables to be used to name the unset index. If an Index, a single hashable should be provided; if an IndexHierarchy, as many hashables as the depth must be provided. consolidate_blocks: columns_constructors:", "FrameGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameGO.__contains__()": "Inclusion of value in column labels.", "FrameGO.__iter__()": "Iterator of column labels, same as Frame.keys.", "FrameGO.__reversed__()": "Returns a reverse iterator on the frame's columns.", "FrameGO.get()": "Return the value found at the columns key, else the default if the key is not found. This method is implemented to complete the dictionary-like interface.", "FrameGO.items()": "Iterator of pairs of column label and corresponding column Series.", "FrameGO.keys()": "Iterator of column labels.", "FrameGO.values": "A 2D NumPy array of all values in the Frame. As this is a single array, heterogenous columnar types might be coerced to a compatible type.", "FrameGO.interface": "A Frame documenting the interface of this class.", "FrameGO.__repr__()": "", "FrameGO.__str__()": "Return str(self).", "FrameGO.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "FrameGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "FrameGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "FrameGO.assign[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, Frame, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "FrameGO.assign[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameGO.assign[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameGO.assign[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameGO.assign.iloc[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, Frame, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "FrameGO.assign.iloc[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameGO.assign.iloc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameGO.assign.iloc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameGO.assign.loc[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, Frame, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "FrameGO.assign.loc[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameGO.assign.loc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameGO.assign.loc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameGO.assign.bloc[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, Frame, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "FrameGO.assign.bloc[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameGO.assign.bloc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameGO.assign.bloc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameGO.bloc[]": "", "FrameGO.drop[]": "Label-based selection.", "FrameGO.drop.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "FrameGO.drop.loc[]": "", "FrameGO.mask[]": "Label-based selection.", "FrameGO.mask.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "FrameGO.mask.loc[]": "", "FrameGO.masked_array[]": "Label-based selection.", "FrameGO.masked_array.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "FrameGO.masked_array.loc[]": "", "FrameGO.[]": "Selector of columns by label. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.", "FrameGO.iloc[]": "", "FrameGO.loc[]": "", "FrameGO.iter_array()": "Iterator of np.array, where arrays are drawn from columns (axis=0) or rows (axis=1)", "FrameGO.iter_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_array_items()": "Iterator of pairs of label, np.array, where arrays are drawn from columns (axis=0) or rows (axis=1)", "FrameGO.iter_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_element()": "Iterator of elements, ordered by row then column.", "FrameGO.iter_element().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_element().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_element().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_element().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_element().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_element().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameGO.iter_element().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameGO.iter_element().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_element().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameGO.iter_element().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameGO.iter_element().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_element().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "FrameGO.iter_element().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "FrameGO.iter_element_items()": "Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.", "FrameGO.iter_element_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_element_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_element_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_element_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_element_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_element_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameGO.iter_element_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameGO.iter_element_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_element_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameGO.iter_element_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameGO.iter_element_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_element_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "FrameGO.iter_element_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "FrameGO.iter_group()": "Iterator of Frame grouped by unique values found in one or more columns (axis=0) or rows (axis=1).", "FrameGO.iter_group().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_group().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_group().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_group().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_group().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group().reduce.from_map_func().keys()": "", "FrameGO.iter_group().reduce.from_map_func().__iter__()": "", "FrameGO.iter_group().reduce.from_map_func().items()": "", "FrameGO.iter_group().reduce.from_map_func().values()": "", "FrameGO.iter_group().reduce.from_map_func().to_frame()": "", "FrameGO.iter_group().reduce.from_label_map().keys()": "", "FrameGO.iter_group().reduce.from_label_map().__iter__()": "", "FrameGO.iter_group().reduce.from_label_map().items()": "", "FrameGO.iter_group().reduce.from_label_map().values()": "", "FrameGO.iter_group().reduce.from_label_map().to_frame()": "", "FrameGO.iter_group().reduce.from_label_pair_map().keys()": "", "FrameGO.iter_group().reduce.from_label_pair_map().__iter__()": "", "FrameGO.iter_group().reduce.from_label_pair_map().items()": "", "FrameGO.iter_group().reduce.from_label_pair_map().values()": "", "FrameGO.iter_group().reduce.from_label_pair_map().to_frame()": "", "FrameGO.iter_group_array()": "Iterator of np.ndarray grouped by unique values found in one or more columns (axis=0) or rows (axis=1).", "FrameGO.iter_group_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_group_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_group_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_group_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_group_array().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_array().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_array().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_array().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_array().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_array().reduce.from_map_func().keys()": "", "FrameGO.iter_group_array().reduce.from_map_func().__iter__()": "", "FrameGO.iter_group_array().reduce.from_map_func().items()": "", "FrameGO.iter_group_array().reduce.from_map_func().values()": "", "FrameGO.iter_group_array().reduce.from_map_func().to_frame()": "", "FrameGO.iter_group_array().reduce.from_label_map().keys()": "", "FrameGO.iter_group_array().reduce.from_label_map().__iter__()": "", "FrameGO.iter_group_array().reduce.from_label_map().items()": "", "FrameGO.iter_group_array().reduce.from_label_map().values()": "", "FrameGO.iter_group_array().reduce.from_label_map().to_frame()": "", "FrameGO.iter_group_array().reduce.from_label_pair_map().keys()": "", "FrameGO.iter_group_array().reduce.from_label_pair_map().__iter__()": "", "FrameGO.iter_group_array().reduce.from_label_pair_map().items()": "", "FrameGO.iter_group_array().reduce.from_label_pair_map().values()": "", "FrameGO.iter_group_array().reduce.from_label_pair_map().to_frame()": "", "FrameGO.iter_group_array_items()": "Iterator of pairs of label, np.ndarray grouped by unique values found in one or more columns (axis=0) or rows (axis=1).", "FrameGO.iter_group_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_group_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_group_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_group_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_group_array_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_array_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_array_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_array_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_array_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_array_items().reduce.from_map_func().keys()": "", "FrameGO.iter_group_array_items().reduce.from_map_func().__iter__()": "", "FrameGO.iter_group_array_items().reduce.from_map_func().items()": "", "FrameGO.iter_group_array_items().reduce.from_map_func().values()": "", "FrameGO.iter_group_array_items().reduce.from_map_func().to_frame()": "", "FrameGO.iter_group_array_items().reduce.from_label_map().keys()": "", "FrameGO.iter_group_array_items().reduce.from_label_map().__iter__()": "", "FrameGO.iter_group_array_items().reduce.from_label_map().items()": "", "FrameGO.iter_group_array_items().reduce.from_label_map().values()": "", "FrameGO.iter_group_array_items().reduce.from_label_map().to_frame()": "", "FrameGO.iter_group_array_items().reduce.from_label_pair_map().keys()": "", "FrameGO.iter_group_array_items().reduce.from_label_pair_map().__iter__()": "", "FrameGO.iter_group_array_items().reduce.from_label_pair_map().items()": "", "FrameGO.iter_group_array_items().reduce.from_label_pair_map().values()": "", "FrameGO.iter_group_array_items().reduce.from_label_pair_map().to_frame()": "", "FrameGO.iter_group_items()": "Iterator of pairs of label, Frame grouped by unique values found in one or more columns (axis=0) or rows (axis=1).", "FrameGO.iter_group_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_group_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_group_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_group_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_group_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_items().reduce.from_map_func().keys()": "", "FrameGO.iter_group_items().reduce.from_map_func().__iter__()": "", "FrameGO.iter_group_items().reduce.from_map_func().items()": "", "FrameGO.iter_group_items().reduce.from_map_func().values()": "", "FrameGO.iter_group_items().reduce.from_map_func().to_frame()": "", "FrameGO.iter_group_items().reduce.from_label_map().keys()": "", "FrameGO.iter_group_items().reduce.from_label_map().__iter__()": "", "FrameGO.iter_group_items().reduce.from_label_map().items()": "", "FrameGO.iter_group_items().reduce.from_label_map().values()": "", "FrameGO.iter_group_items().reduce.from_label_map().to_frame()": "", "FrameGO.iter_group_items().reduce.from_label_pair_map().keys()": "", "FrameGO.iter_group_items().reduce.from_label_pair_map().__iter__()": "", "FrameGO.iter_group_items().reduce.from_label_pair_map().items()": "", "FrameGO.iter_group_items().reduce.from_label_pair_map().values()": "", "FrameGO.iter_group_items().reduce.from_label_pair_map().to_frame()": "", "FrameGO.iter_group_labels()": "Iterator of Frame grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).", "FrameGO.iter_group_labels().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_group_labels().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_group_labels().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_group_labels().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_group_labels_array()": "Iterator of np.ndarray grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).", "FrameGO.iter_group_labels_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_group_labels_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_group_labels_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_group_labels_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_group_labels_array_items()": "Iterator of pairs of label, np.ndarray grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).", "FrameGO.iter_group_labels_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_group_labels_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_group_labels_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_group_labels_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_group_labels_items()": "Iterator of pairs of label, Frame grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).", "FrameGO.iter_group_labels_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_group_labels_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_group_labels_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_group_labels_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_group_other()": "Iterator of Frame grouped by unique values found in a supplied container.", "FrameGO.iter_group_other().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_group_other().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_group_other().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_group_other().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_group_other().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other().reduce.from_map_func().keys()": "", "FrameGO.iter_group_other().reduce.from_map_func().__iter__()": "", "FrameGO.iter_group_other().reduce.from_map_func().items()": "", "FrameGO.iter_group_other().reduce.from_map_func().values()": "", "FrameGO.iter_group_other().reduce.from_map_func().to_frame()": "", "FrameGO.iter_group_other().reduce.from_label_map().keys()": "", "FrameGO.iter_group_other().reduce.from_label_map().__iter__()": "", "FrameGO.iter_group_other().reduce.from_label_map().items()": "", "FrameGO.iter_group_other().reduce.from_label_map().values()": "", "FrameGO.iter_group_other().reduce.from_label_map().to_frame()": "", "FrameGO.iter_group_other().reduce.from_label_pair_map().keys()": "", "FrameGO.iter_group_other().reduce.from_label_pair_map().__iter__()": "", "FrameGO.iter_group_other().reduce.from_label_pair_map().items()": "", "FrameGO.iter_group_other().reduce.from_label_pair_map().values()": "", "FrameGO.iter_group_other().reduce.from_label_pair_map().to_frame()": "", "FrameGO.iter_group_other_array()": "Iterator of Frame grouped by unique values found in a supplied container.", "FrameGO.iter_group_other_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_group_other_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_group_other_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_group_other_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_group_other_array().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other_array().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other_array().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other_array().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other_array().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other_array().reduce.from_map_func().keys()": "", "FrameGO.iter_group_other_array().reduce.from_map_func().__iter__()": "", "FrameGO.iter_group_other_array().reduce.from_map_func().items()": "", "FrameGO.iter_group_other_array().reduce.from_map_func().values()": "", "FrameGO.iter_group_other_array().reduce.from_map_func().to_frame()": "", "FrameGO.iter_group_other_array().reduce.from_label_map().keys()": "", "FrameGO.iter_group_other_array().reduce.from_label_map().__iter__()": "", "FrameGO.iter_group_other_array().reduce.from_label_map().items()": "", "FrameGO.iter_group_other_array().reduce.from_label_map().values()": "", "FrameGO.iter_group_other_array().reduce.from_label_map().to_frame()": "", "FrameGO.iter_group_other_array().reduce.from_label_pair_map().keys()": "", "FrameGO.iter_group_other_array().reduce.from_label_pair_map().__iter__()": "", "FrameGO.iter_group_other_array().reduce.from_label_pair_map().items()": "", "FrameGO.iter_group_other_array().reduce.from_label_pair_map().values()": "", "FrameGO.iter_group_other_array().reduce.from_label_pair_map().to_frame()": "", "FrameGO.iter_group_other_array_items()": "Iterator of Frame grouped by unique values found in a supplied container.", "FrameGO.iter_group_other_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_group_other_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_group_other_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_group_other_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_group_other_array_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other_array_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other_array_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other_array_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other_array_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other_array_items().reduce.from_map_func().keys()": "", "FrameGO.iter_group_other_array_items().reduce.from_map_func().__iter__()": "", "FrameGO.iter_group_other_array_items().reduce.from_map_func().items()": "", "FrameGO.iter_group_other_array_items().reduce.from_map_func().values()": "", "FrameGO.iter_group_other_array_items().reduce.from_map_func().to_frame()": "", "FrameGO.iter_group_other_array_items().reduce.from_label_map().keys()": "", "FrameGO.iter_group_other_array_items().reduce.from_label_map().__iter__()": "", "FrameGO.iter_group_other_array_items().reduce.from_label_map().items()": "", "FrameGO.iter_group_other_array_items().reduce.from_label_map().values()": "", "FrameGO.iter_group_other_array_items().reduce.from_label_map().to_frame()": "", "FrameGO.iter_group_other_array_items().reduce.from_label_pair_map().keys()": "", "FrameGO.iter_group_other_array_items().reduce.from_label_pair_map().__iter__()": "", "FrameGO.iter_group_other_array_items().reduce.from_label_pair_map().items()": "", "FrameGO.iter_group_other_array_items().reduce.from_label_pair_map().values()": "", "FrameGO.iter_group_other_array_items().reduce.from_label_pair_map().to_frame()": "", "FrameGO.iter_group_other_items()": "Iterator of Frame grouped by unique values found in a supplied container.", "FrameGO.iter_group_other_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_group_other_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_group_other_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_group_other_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_group_other_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_group_other_items().reduce.from_map_func().keys()": "", "FrameGO.iter_group_other_items().reduce.from_map_func().__iter__()": "", "FrameGO.iter_group_other_items().reduce.from_map_func().items()": "", "FrameGO.iter_group_other_items().reduce.from_map_func().values()": "", "FrameGO.iter_group_other_items().reduce.from_map_func().to_frame()": "", "FrameGO.iter_group_other_items().reduce.from_label_map().keys()": "", "FrameGO.iter_group_other_items().reduce.from_label_map().__iter__()": "", "FrameGO.iter_group_other_items().reduce.from_label_map().items()": "", "FrameGO.iter_group_other_items().reduce.from_label_map().values()": "", "FrameGO.iter_group_other_items().reduce.from_label_map().to_frame()": "", "FrameGO.iter_group_other_items().reduce.from_label_pair_map().keys()": "", "FrameGO.iter_group_other_items().reduce.from_label_pair_map().__iter__()": "", "FrameGO.iter_group_other_items().reduce.from_label_pair_map().items()": "", "FrameGO.iter_group_other_items().reduce.from_label_pair_map().values()": "", "FrameGO.iter_group_other_items().reduce.from_label_pair_map().to_frame()": "", "FrameGO.iter_series()": "Iterator of Series, where Series are drawn from columns (axis=0) or rows (axis=1)", "FrameGO.iter_series().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_series().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_series().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_series().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_series_items()": "Iterator of pairs of label, Series, where Series are drawn from columns (axis=0) or rows (axis=1)", "FrameGO.iter_series_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_series_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_series_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_series_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_tuple()": "Iterator of NamedTuple, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional constructor callable can be used to provide a NamedTuple class (or any other constructor called with a single iterable) to be used to create each yielded axis value.", "FrameGO.iter_tuple().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_tuple().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_tuple().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_tuple().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_tuple().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_tuple().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameGO.iter_tuple().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameGO.iter_tuple().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_tuple().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameGO.iter_tuple().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameGO.iter_tuple().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_tuple().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "FrameGO.iter_tuple().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "FrameGO.iter_tuple_items()": "Iterator of pairs of label, NamedTuple, where tuples are drawn from columns (axis=0) or rows (axis=1)", "FrameGO.iter_tuple_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_tuple_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_tuple_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_tuple_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_tuple_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_tuple_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameGO.iter_tuple_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameGO.iter_tuple_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_tuple_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameGO.iter_tuple_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameGO.iter_tuple_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_tuple_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "FrameGO.iter_tuple_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "FrameGO.iter_window()": "Iterator of windowed values, where values are given as a Frame. Args: size: Elements per window, given as an integer greater than 0. axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. step: Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the size will result in non-overlapping windows. window_sized: if True, windows with fewer elements than size are skipped. window_func: Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window. window_valid: Function that, given an array window, returns True if the window is valid; invalid windows are skipped. label_shift: A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, label_shift can be set to one less than size. label_missing_skips: If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label. label_missing_raises: If True, a window that cannot derive a label will raise an exception. start_shift: A shift to determine the first element where window collection begins. size_increment: A value to be added to size with each window after the first, so as to, in combination with setting step to 0, permit iterating over expanding windows.", "FrameGO.iter_window().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_window().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_window().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_window().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_window().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window().reduce.from_map_func().keys()": "", "FrameGO.iter_window().reduce.from_map_func().__iter__()": "", "FrameGO.iter_window().reduce.from_map_func().items()": "", "FrameGO.iter_window().reduce.from_map_func().values()": "", "FrameGO.iter_window().reduce.from_map_func().to_frame()": "", "FrameGO.iter_window().reduce.from_label_map().keys()": "", "FrameGO.iter_window().reduce.from_label_map().__iter__()": "", "FrameGO.iter_window().reduce.from_label_map().items()": "", "FrameGO.iter_window().reduce.from_label_map().values()": "", "FrameGO.iter_window().reduce.from_label_map().to_frame()": "", "FrameGO.iter_window().reduce.from_label_pair_map().keys()": "", "FrameGO.iter_window().reduce.from_label_pair_map().__iter__()": "", "FrameGO.iter_window().reduce.from_label_pair_map().items()": "", "FrameGO.iter_window().reduce.from_label_pair_map().values()": "", "FrameGO.iter_window().reduce.from_label_pair_map().to_frame()": "", "FrameGO.iter_window_array()": "Iterator of windowed values, where values are given as a np.array. Args: size: Elements per window, given as an integer greater than 0. axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. step: Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the size will result in non-overlapping windows. window_sized: if True, windows with fewer elements than size are skipped. window_func: Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window. window_valid: Function that, given an array window, returns True if the window is valid; invalid windows are skipped. label_shift: A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, label_shift can be set to one less than size. label_missing_skips: If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label. label_missing_raises: If True, a window that cannot derive a label will raise an exception. start_shift: A shift to determine the first element where window collection begins. size_increment: A value to be added to size with each window after the first, so as to, in combination with setting step to 0, permit iterating over expanding windows.", "FrameGO.iter_window_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_window_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_window_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_window_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_window_array().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window_array().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window_array().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window_array().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window_array().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window_array().reduce.from_map_func().keys()": "", "FrameGO.iter_window_array().reduce.from_map_func().__iter__()": "", "FrameGO.iter_window_array().reduce.from_map_func().items()": "", "FrameGO.iter_window_array().reduce.from_map_func().values()": "", "FrameGO.iter_window_array().reduce.from_map_func().to_frame()": "", "FrameGO.iter_window_array().reduce.from_label_map().keys()": "", "FrameGO.iter_window_array().reduce.from_label_map().__iter__()": "", "FrameGO.iter_window_array().reduce.from_label_map().items()": "", "FrameGO.iter_window_array().reduce.from_label_map().values()": "", "FrameGO.iter_window_array().reduce.from_label_map().to_frame()": "", "FrameGO.iter_window_array().reduce.from_label_pair_map().keys()": "", "FrameGO.iter_window_array().reduce.from_label_pair_map().__iter__()": "", "FrameGO.iter_window_array().reduce.from_label_pair_map().items()": "", "FrameGO.iter_window_array().reduce.from_label_pair_map().values()": "", "FrameGO.iter_window_array().reduce.from_label_pair_map().to_frame()": "", "FrameGO.iter_window_array_items()": "Iterator of pairs of label, windowed values, where values are given as a np.array. Args: size: Elements per window, given as an integer greater than 0. axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. step: Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the size will result in non-overlapping windows. window_sized: if True, windows with fewer elements than size are skipped. window_func: Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window. window_valid: Function that, given an array window, returns True if the window is valid; invalid windows are skipped. label_shift: A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, label_shift can be set to one less than size. label_missing_skips: If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label. label_missing_raises: If True, a window that cannot derive a label will raise an exception. start_shift: A shift to determine the first element where window collection begins. size_increment: A value to be added to size with each window after the first, so as to, in combination with setting step to 0, permit iterating over expanding windows.", "FrameGO.iter_window_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_window_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_window_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_window_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_window_array_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window_array_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window_array_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window_array_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window_array_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window_array_items().reduce.from_map_func().keys()": "", "FrameGO.iter_window_array_items().reduce.from_map_func().__iter__()": "", "FrameGO.iter_window_array_items().reduce.from_map_func().items()": "", "FrameGO.iter_window_array_items().reduce.from_map_func().values()": "", "FrameGO.iter_window_array_items().reduce.from_map_func().to_frame()": "", "FrameGO.iter_window_array_items().reduce.from_label_map().keys()": "", "FrameGO.iter_window_array_items().reduce.from_label_map().__iter__()": "", "FrameGO.iter_window_array_items().reduce.from_label_map().items()": "", "FrameGO.iter_window_array_items().reduce.from_label_map().values()": "", "FrameGO.iter_window_array_items().reduce.from_label_map().to_frame()": "", "FrameGO.iter_window_array_items().reduce.from_label_pair_map().keys()": "", "FrameGO.iter_window_array_items().reduce.from_label_pair_map().__iter__()": "", "FrameGO.iter_window_array_items().reduce.from_label_pair_map().items()": "", "FrameGO.iter_window_array_items().reduce.from_label_pair_map().values()": "", "FrameGO.iter_window_array_items().reduce.from_label_pair_map().to_frame()": "", "FrameGO.iter_window_items()": "Iterator of pairs of label, windowed values, where values are given as a Frame. Args: size: Elements per window, given as an integer greater than 0. axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. step: Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the size will result in non-overlapping windows. window_sized: if True, windows with fewer elements than size are skipped. window_func: Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window. window_valid: Function that, given an array window, returns True if the window is valid; invalid windows are skipped. label_shift: A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, label_shift can be set to one less than size. label_missing_skips: If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label. label_missing_raises: If True, a window that cannot derive a label will raise an exception. start_shift: A shift to determine the first element where window collection begins. size_increment: A value to be added to size with each window after the first, so as to, in combination with setting step to 0, permit iterating over expanding windows.", "FrameGO.iter_window_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameGO.iter_window_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameGO.iter_window_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameGO.iter_window_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameGO.iter_window_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.iter_window_items().reduce.from_map_func().keys()": "", "FrameGO.iter_window_items().reduce.from_map_func().__iter__()": "", "FrameGO.iter_window_items().reduce.from_map_func().items()": "", "FrameGO.iter_window_items().reduce.from_map_func().values()": "", "FrameGO.iter_window_items().reduce.from_map_func().to_frame()": "", "FrameGO.iter_window_items().reduce.from_label_map().keys()": "", "FrameGO.iter_window_items().reduce.from_label_map().__iter__()": "", "FrameGO.iter_window_items().reduce.from_label_map().items()": "", "FrameGO.iter_window_items().reduce.from_label_map().values()": "", "FrameGO.iter_window_items().reduce.from_label_map().to_frame()": "", "FrameGO.iter_window_items().reduce.from_label_pair_map().keys()": "", "FrameGO.iter_window_items().reduce.from_label_pair_map().__iter__()": "", "FrameGO.iter_window_items().reduce.from_label_pair_map().items()": "", "FrameGO.iter_window_items().reduce.from_label_pair_map().values()": "", "FrameGO.iter_window_items().reduce.from_label_pair_map().to_frame()": "", "FrameGO.__add__()": "", "FrameGO.__and__()": "", "FrameGO.__eq__()": "", "FrameGO.__floordiv__()": "", "FrameGO.__ge__()": "", "FrameGO.__gt__()": "", "FrameGO.__le__()": "", "FrameGO.__lt__()": "", "FrameGO.__matmul__()": "", "FrameGO.__mod__()": "", "FrameGO.__mul__()": "", "FrameGO.__ne__()": "", "FrameGO.__or__()": "", "FrameGO.__pow__()": "", "FrameGO.__radd__()": "", "FrameGO.__rfloordiv__()": "", "FrameGO.__rmatmul__()": "", "FrameGO.__rmul__()": "", "FrameGO.__rshift__()": "", "FrameGO.__rsub__()": "", "FrameGO.__rtruediv__()": "", "FrameGO.__sub__()": "", "FrameGO.__truediv__()": "", "FrameGO.__xor__()": "", "FrameGO.__abs__()": "", "FrameGO.__invert__()": "", "FrameGO.__neg__()": "", "FrameGO.__pos__()": "", "FrameGO.abs()": "", "FrameGO.via_values.apply()": "", "FrameGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "FrameGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "FrameGO.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "FrameGO.via_dt.year": "Return the year of each element.", "FrameGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "FrameGO.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "FrameGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "FrameGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "FrameGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "FrameGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "FrameGO.via_dt.second": "Return the second of each element, between 0 and 60.", "FrameGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "FrameGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "FrameGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "FrameGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "FrameGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "FrameGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "FrameGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "FrameGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "FrameGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "FrameGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "FrameGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "FrameGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "FrameGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "FrameGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "FrameGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "FrameGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "FrameGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "FrameGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "FrameGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "FrameGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "FrameGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "FrameGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "FrameGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "FrameGO.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "FrameGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "FrameGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "FrameGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "FrameGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "FrameGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "FrameGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "FrameGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "FrameGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "FrameGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "FrameGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "FrameGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "FrameGO.via_str.len()": "Return the length of the string.", "FrameGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "FrameGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "FrameGO.via_str.partition()": "Partition each element around sep.", "FrameGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "FrameGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "FrameGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "FrameGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "FrameGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "FrameGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "FrameGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "FrameGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "FrameGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "FrameGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "FrameGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "FrameGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "FrameGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "FrameGO.via_str.zfill()": "Return the string left-filled with zeros.", "FrameGO.via_T.via_fill_value()": "Interface for using binary operators and methods with a pre-defined fill value.", "FrameGO.via_T.__add__()": "", "FrameGO.via_T.__sub__()": "", "FrameGO.via_T.__mul__()": "", "FrameGO.via_T.__truediv__()": "", "FrameGO.via_T.__floordiv__()": "", "FrameGO.via_T.__mod__()": "", "FrameGO.via_T.__pow__()": "", "FrameGO.via_T.__lshift__()": "", "FrameGO.via_T.__rshift__()": "", "FrameGO.via_T.__and__()": "", "FrameGO.via_T.__xor__()": "", "FrameGO.via_T.__or__()": "", "FrameGO.via_T.__lt__()": "", "FrameGO.via_T.__le__()": "", "FrameGO.via_T.__eq__()": "", "FrameGO.via_T.__ne__()": "", "FrameGO.via_T.__gt__()": "", "FrameGO.via_T.__ge__()": "", "FrameGO.via_T.__radd__()": "", "FrameGO.via_T.__rsub__()": "", "FrameGO.via_T.__rmul__()": "", "FrameGO.via_T.__rtruediv__()": "", "FrameGO.via_T.__rfloordiv__()": "", "FrameGO.via_fill_value().loc": "Label-based selection where labels not specified will define a new container containing those labels filled with the fill value.", "FrameGO.via_fill_value().__getitem__()": "Label-based selection where labels not specified will define a new container containing those labels filled with the fill value.", "FrameGO.via_fill_value().via_T": "Interface for using binary operators with one-dimensional sequences, where the opperand is applied column-wise.", "FrameGO.via_fill_value().__add__()": "", "FrameGO.via_fill_value().__sub__()": "", "FrameGO.via_fill_value().__mul__()": "", "FrameGO.via_fill_value().__truediv__()": "", "FrameGO.via_fill_value().__floordiv__()": "", "FrameGO.via_fill_value().__mod__()": "", "FrameGO.via_fill_value().__pow__()": "", "FrameGO.via_fill_value().__lshift__()": "", "FrameGO.via_fill_value().__rshift__()": "", "FrameGO.via_fill_value().__and__()": "", "FrameGO.via_fill_value().__xor__()": "", "FrameGO.via_fill_value().__or__()": "", "FrameGO.via_fill_value().__lt__()": "", "FrameGO.via_fill_value().__le__()": "", "FrameGO.via_fill_value().__eq__()": "", "FrameGO.via_fill_value().__ne__()": "", "FrameGO.via_fill_value().__gt__()": "", "FrameGO.via_fill_value().__ge__()": "", "FrameGO.via_fill_value().__radd__()": "", "FrameGO.via_fill_value().__rsub__()": "", "FrameGO.via_fill_value().__rmul__()": "", "FrameGO.via_fill_value().__rtruediv__()": "", "FrameGO.via_fill_value().__rfloordiv__()": "", "FrameGO.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "FrameGO.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "FrameGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "FrameGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "FrameGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "FrameGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "FrameGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "FrameGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "FrameGO.via_hashlib().md5()": "", "FrameGO.via_hashlib().sha256()": "", "FrameGO.via_hashlib().sha512()": "", "FrameGO.via_hashlib().sha3_256()": "", "FrameGO.via_hashlib().sha3_512()": "", "FrameGO.via_hashlib().shake_128()": "", "FrameGO.via_hashlib().shake_256()": "", "FrameGO.via_hashlib().blake2b()": "", "FrameGO.via_hashlib().blake2s()": "", "FrameGO.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "FrameGO.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "FrameGO.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "FrameGO.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "FrameGO.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "FrameGO.reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameGO.reduce.from_map_func().keys()": "For each Frame, reduce by applying, for each column, a function that reduces to (0-dimensional) elements, where the column label and function are given as a mapping. Column labels are retained.", "FrameGO.reduce.from_map_func().__iter__()": "For each Frame, reduce by applying, for each column, a function that reduces to (0-dimensional) elements, where the column label and function are given as a mapping. Column labels are retained.", "FrameGO.reduce.from_map_func().items()": "For each Frame, reduce by applying, for each column, a function that reduces to (0-dimensional) elements, where the column label and function are given as a mapping. Column labels are retained.", "FrameGO.reduce.from_map_func().values()": "For each Frame, reduce by applying, for each column, a function that reduces to (0-dimensional) elements, where the column label and function are given as a mapping. Column labels are retained.", "FrameGO.reduce.from_map_func().to_frame()": "For each Frame, reduce by applying, for each column, a function that reduces to (0-dimensional) elements, where the column label and function are given as a mapping. Column labels are retained.", "FrameGO.reduce.from_label_map().keys()": "For Frame, reduce by applying a function to each column, where the column label and function are given as a mapping. Column labels are retained. Args: func_map: a mapping of column labels to functions.", "FrameGO.reduce.from_label_map().__iter__()": "For Frame, reduce by applying a function to each column, where the column label and function are given as a mapping. Column labels are retained. Args: func_map: a mapping of column labels to functions.", "FrameGO.reduce.from_label_map().items()": "For Frame, reduce by applying a function to each column, where the column label and function are given as a mapping. Column labels are retained. Args: func_map: a mapping of column labels to functions.", "FrameGO.reduce.from_label_map().values()": "For Frame, reduce by applying a function to each column, where the column label and function are given as a mapping. Column labels are retained. Args: func_map: a mapping of column labels to functions.", "FrameGO.reduce.from_label_map().to_frame()": "For Frame, reduce by applying a function to each column, where the column label and function are given as a mapping. Column labels are retained. Args: func_map: a mapping of column labels to functions.", "FrameGO.reduce.from_label_pair_map().keys()": "For Frame, reduce by applying a function to a column and assigning the result a new label. Functions are provided as values in a mapping, where the key is tuple of source label, destination label. Args: func_map: a mapping of pairs of source label, destination label, to a function.", "FrameGO.reduce.from_label_pair_map().__iter__()": "For Frame, reduce by applying a function to a column and assigning the result a new label. Functions are provided as values in a mapping, where the key is tuple of source label, destination label. Args: func_map: a mapping of pairs of source label, destination label, to a function.", "FrameGO.reduce.from_label_pair_map().items()": "For Frame, reduce by applying a function to a column and assigning the result a new label. Functions are provided as values in a mapping, where the key is tuple of source label, destination label. Args: func_map: a mapping of pairs of source label, destination label, to a function.", "FrameGO.reduce.from_label_pair_map().values()": "For Frame, reduce by applying a function to a column and assigning the result a new label. Functions are provided as values in a mapping, where the key is tuple of source label, destination label. Args: func_map: a mapping of pairs of source label, destination label, to a function.", "FrameGO.reduce.from_label_pair_map().to_frame()": "For Frame, reduce by applying a function to a column and assigning the result a new label. Functions are provided as values in a mapping, where the key is tuple of source label, destination label. Args: func_map: a mapping of pairs of source label, destination label, to a function.", "FrameHE.__init__()": "Initializer. Args: data: Default Frame initialization requires typed data such as a NumPy array. All other initialization should use specialized constructors. index: Optional index initializer. If provided in addition to data values, lengths must be compatible. columns: Optional column initializer. If provided in addition to data values, lengths must be compatible. index_constructor: columns_constructor: own_data: Flag the data values as ownable by this Frame. Primarily used by internal clients. own_index: Flag the passed index as ownable by this Frame. Primarily used by internal clients. own_columns: Flag the passed columns as ownable by this Frame. Primarily used by internal clients.", "FrameHE.from_arrow()": "Realize a Frame from an Arrow Table. Args: value: A pyarrow.Table instance. index_depth: integer specification of how many columns to use in forming the index. A value of 0 will select none; a value greater than 1 will create an IndexHierarchy. columns_depth: integer specification of how many rows to use in forming the columns. A value of 0 will select none; a value greater than 1 will create an IndexHierarchy. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameHE.from_clipboard()": "Create a Frame from the contents of the clipboard (assuming a table is stored as delimited file). Returns: Frame", "FrameHE.from_concat()": "Concatenate multiple Frame or Series into a new Frame. If index or columns are provided and appropriately sized, the resulting Frame will use those indices. If the axis along concatenation (index for axis 0, columns for axis 1) is unique after concatenation, it will be preserved; otherwise, a new index or an IndexAutoFactory must be supplied. Args: frames: Iterable of Frames. axis: Integer specifying 0 to concatenate supplied Frames vertically (aligning on columns), 1 to concatenate horizontally (aligning on rows). union: If True, the union of the aligned indices is used; if False, the intersection is used. index: Optionally specify a new index. columns: Optionally specify new columns. index_constructor: Optionally apply a constructor to the derived or passed labels. columns_constructor: Optionally apply a constructor to the derived or passed labels. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameHE.from_concat_items()": "Produce a Frame with a hierarchical index from an iterable of pairs of labels, Frame. The IndexHierarchy is formed from the provided labels and the Index if each Frame. Args: items: Iterable of pairs of label, Frame axis: union: name: fill_value: index_constructor: columns_constructor: consolidate_blocks:", "FrameHE.from_csv()": "Specialized version of Frame.from_delimited for CSV files. Returns: Frame", "FrameHE.from_delimited()": "Create a Frame from a file path or a file-like object defining a delimited (CSV, TSV) data file. Args: fp: A file path or a file-like object. delimiter: The character used to seperate row elements. index_depth: Specify the number of columns used to create the index labels; a value greater than 1 will attempt to create a hierarchical index. index_column_first: Optionally specify a column, by position in the realized columns, to become the start of the index if index_depth is greater than 0 and columns_depth is 0. index_name_depth_level: If columns_depth is greater than 0, interpret values over index as the index name. index_constructors: index_continuation_token: columns_depth: Specify the number of rows after the skip_header used to create the column labels. A value of 0 will be no header; a value greater than 1 will attempt to create a hierarchical index. columns_name_depth_level: If index_depth is greater than 0, interpret values over index as the columns name. columns_constructors: columns_continuation_token: columns_select: an iterable of columns to select by label or position; can only be used if index_depth is 0. skip_header: Number of leading lines to skip. skip_footer: Number of trailing lines to skip. store_filter: A StoreFilter instance, defining translation between unrepresentable strings and types. By default it is disabled, and only empty fields or \"NAN\" are intepreted as NaN. To force usage, set the type of the column to string. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameHE.from_dict()": "Create a Frame from a dictionary (or any object that has an items() method) where keys are column labels and values are columns values (either sequence types or Series). Args: mapping: a dictionary or similar mapping interface. index: fill_value: dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. index_constructor: columns_constructor: consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays.", "FrameHE.from_dict_fields()": "Frame constructor from an iterable of dictionaries, where each dictionary represents a column; index labels will be derived from the union of all column dictionary keys. Args: fields: Iterable of column values, where column values are dictionaries. index: Optionally provide an iterable of index labels, equal in length to the number of fields. If a generator, this value will not be evaluated until after fields are loaded. columns: dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameHE.from_dict_records()": "Frame constructor from an iterable of dictionaries, where each dictionary represents a row; column names will be derived from the union of all row dictionary keys. Args: records: Iterable of row values, where row values are dictionaries. index: Optionally provide an iterable of index labels, equal in length to the number of records. If a generator, this value will not be evaluated until after records are loaded. index: dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameHE.from_dict_records_items()": "Frame constructor from iterable of pairs of index label, row, where row is a dictionary. Column names will be derived from the union of all row dictionary keys. Args: items: Iterable of pairs of index label, row values, where row values are arrays, tuples, lists, dictionaries, or namedtuples. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameHE.from_element()": "Create a Frame from an element, i.e., a single value stored in a single cell. Both index and columns are required, and cannot be specified with IndexAutoFactory.", "FrameHE.from_element_items()": "Create a Frame from an iterable of key, value, where key is a pair of row, column labels. This function is partialed (setting the index and columns) and used by IterNodeDelegate as the apply constructor for doing application on element iteration. Args: items: an iterable of pairs of 2-tuples of row, column loc labels and values. axis: when None, items can be in an order; when 0, items must be well-formed and ordered row major; when 1, items must be well-formed and ordered columns major. Returns: Frame", "FrameHE.from_elements()": "Create a Frame from an iterable of elements, to be formed into a Frame with a single column.", "FrameHE.from_fields()": "Frame constructor from an iterator of columns, where columns are iterables. Series can be provided as values if an index argument is supplied. This constructor is similar to from_items(), though here columns are provided through an independent columns argument. Args: fields: Iterable of column values. index: Iterable of values to create an Index. fill_value: If pairs include Series, they will be reindexed with the provided index; reindexing will use this fill value. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameHE.from_items()": "Frame constructor from an iterator of pairs, where the first value is the column label and the second value is an iterable of column values. Series can be provided as values if an index argument is supplied. Args: pairs: Iterable of pairs of column name, column values. index: Iterable of values to create an Index. fill_value: If pairs include Series, they will be reindexed with the provided index; reindexing will use this fill value. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. index_constructor: columns_constructor: consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameHE.from_json_columns()": "Frame constructor from an in-memory JSON document in the following format: A JSON object keyed by column labels, where values are columns represented by an object mapping of index labels to values. Args: json_data: a string or StringIO of JSON data dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameHE.from_json_index()": "Frame constructor from an in-memory JSON document in the following format: A JSON object keyed by index labels, where values are rows represented by an object mapping of column labels to values. Args: json_data: a string or StringIO of JSON data dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameHE.from_json_records()": "Frame constructor from an in-memory JSON document in the following format: A JSON array of row objects, where column labels are repeated for each row, and no index labels are included. Args: json_data: a string or StringIO of JSON data dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameHE.from_json_split()": "Frame constructor from an in-memory JSON document in the following format: A JSON object with a key for \"columns\", \"index\", and \"data\", where data is given as an array of arrays of row values. Args: json_data: a string or StringIO of JSON data dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameHE.from_json_typed()": "Frame constructor from an in-memory JSON document in the following format: A JSON object with a key for \"columns\", \"index\", and \"data\", where data is given as an array of arrays of column values; additionally, a key for \"__meta__\" defines an object with complete metadata and typing information. Args: json_data: a string or StringIO of JSON data Returns: Frame", "FrameHE.from_json_values()": "Frame constructor from an in-memory JSON document in the following format: A JSON array of arrays of row values; no index or columns labels are included. Args: json_data: a string or StringIO of JSON data dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameHE.from_npy()": "Create a Frame from an directory of npy files. Args: fp: The path to the NPY directory.", "FrameHE.from_npy_mmap()": "Create a Frame from an directory of npy files using memory maps. Args: fp: The path to the NPY directory. Returns: A tuple of Frame and the callable needed to close the open memory map objects. On some platforms this must be called before the process exits.", "FrameHE.from_npz()": "Create a Frame from an npz file.", "FrameHE.from_overlay()": "Return a new Frame made by overlaying containers, filling in values with aligned values from subsequent containers. Values are filled based on a passed function that must return a Boolean array. By default, that function is isna_array, returning True for missing values (NaN and None). Args: containers: Iterable of Frame. index: An optional Index, IndexHierarchy, or index initializer, to be used as the index upon which all containers are aligned. IndexAutoFactory is not supported. columns: An optional Index, IndexHierarchy, or columns initializer, to be used as the columns upon which all containers are aligned. IndexAutoFactory is not supported. union: If True, and no index or columns argument is supplied, a union index or columns from containers will be used; if False, the intersection index or columns will be used. name: func: A function that takes an array and returns a same-sized Boolean array, where True indicates availability for insertion.", "FrameHE.from_pandas()": "Given a Pandas DataFrame, return a Frame. Args: value: Pandas DataFrame. index_constructor: Optional class or constructor function to create the Index applied to the rows. columns_constructor: Optional class or constructor function to create the Index applied to the columns. dtypes: consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. own_data: If True, the underlying NumPy data array will be made immutable and used without a copy. Returns: Frame", "FrameHE.from_parquet()": "Realize a Frame from a Parquet file. Args: fp: A string file path or Path instance. index_depth: integer specification of how many columns to use in forming the index. A value of 0 will select none; a value greater than 1 will create an IndexHierarchy. index_name_depth_level: index_constructors: columns_depth: integer specification of how many rows to use in forming the columns. A value of 0 will select none; a value greater than 1 will create an IndexHierarchy. columns_name_depth_level: columns_constructors: columns_select: An optional iterable of column names to load. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays.", "FrameHE.from_pickle()": "Create a Frame from a pickle file. The pickle module is not secure. Only unpickle data you trust. Args: fp: The path to the pickle file.", "FrameHE.from_records()": "Construct a Frame from an iterable of rows, where rows are defined as iterables, including tuples, lists, and arrays. If each row is a NamedTuple, and columns is not provided, column names will be derived from the NamedTuple fields. Supplying dtypes will significantly improve performance, as otherwise columnar array types must be derived by element-wise examination. For records defined as Series, use Frame.from_concat; for records defined as dictionary, use Frame.from_dict_records; for creating a Frame from a single dictionary, where keys are column labels and values are columns, use Frame.from_dict. Args: records: Iterable of row values, where row values are arrays, tuples, lists, or namedtuples. For dictionary records, use Frame.from_dict_records. index: Optionally provide an iterable of index labels, equal in length to the number of records. If a generator, this value will not be evaluated until after records are loaded. columns: Optionally provide an iterable of column labels, equal in length to the number of elements in a row. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameHE.from_records_items()": "Frame constructor from iterable of pairs of index value, row (where row is an iterable). Args: items: Iterable of pairs of index label, row values, where row values are arrays, tuples, lists, dictionaries, or namedtuples. columns: Optionally provide an iterable of column labels, equal in length to the length of each row. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameHE.from_series()": "Frame constructor from a Series: Args: series: A Series instance, to be realized as single column, with the column label taken from the name attribute.", "FrameHE.from_sql()": "Frame constructor from an SQL query and a database connection object. Args: query: A query string. connection: A DBAPI2 (PEP 249) Connection object, such as those returned from SQLite (via the sqlite3 module) or PyODBC. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. index_depth: index_constructors: columns_depth: columns_select: An optional iterable of field names to extract from the results of the query. columns_constructors: name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. parameters: Provide a list of values for an SQL query expecting parameter substitution.", "FrameHE.from_sqlite()": "Load Frame from the contents of a table in an SQLite database file.", "FrameHE.from_structured_array()": "Convert a NumPy structed array into a Frame. Args: array: Structured NumPy array. index_depth: Depth if index levels, where (for example) 0 is no index, 1 is a single column index, and 2 is a two-columns IndexHierarchy. index_column_first: Optionally provide the name or position offset of the column to use as the index. dtypes: Optionally provide an iterable of dtypes, equal in length to the length of each row, or a mapping by column name (where overspecied labels is not an error). If a dtype is given as None, element-wise type determination will be used. name: A hashable object to label the container. consolidate_blocks: Optionally consolidate adjacent same-typed columns into contiguous arrays. Returns: Frame", "FrameHE.from_tsv()": "Specialized version of Frame.from_delimited for TSV files. Returns: Frame", "FrameHE.from_xlsx()": "Load Frame from the contents of a sheet in an XLSX workbook. Args: label: Optionally provide the sheet name from which to read. If not provided, the first sheet will be used.", "FrameHE.to_arrow()": "Return a pyarrow.Table from this Frame.", "FrameHE.to_clipboard()": "Given a file path or file-like object, write the Frame as delimited text. The delimiter defaults to a tab. Args: A file path, PathLib instance, or file-like object. * delimiter: Character to be used for delimiterarating elements. include_index: If True, the index will be written. include_index_name: If including columns, populate the row above the index with the index name. Cannot be True if include_columns_name is True. include_columns: If True, the columns will be written. include_columns_name: If including index, populate the column to the left of the columns with the columns name. Cannot be True if include_index_name is True. encoding: Encoding type to be used when opening the file. line_terminator: The string used to terminate lines. quote_char: A one-character string used to quote fields containing special characters, such as the delimiter or quote_char, or which contain new-line characters. quote_double: Controls how instances of quote_char appearing inside a field should themselves be quoted. When True, the character is doubled. When False, the escape_char is used as a prefix to the quote_char. It defaults to True. escape_char: A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE_NONE and the quotechar if quote_double is False. quoting: Controls when quotes should be generated. It can take on any of the QUOTE_* constants from the standard library csv module. store_filter: A StoreFilter instance.", "FrameHE.to_csv()": "Given a file path or file-like object, write the Frame as delimited text. The delimiter is set to a comma. Args: A file path, PathLib instance, or file-like object. * include_index: If True, the index will be written. include_index_name: If including columns, populate the row above the index with the index name. Cannot be True if include_columns_name is True. include_columns: If True, the columns will be written. include_columns_name: If including index, populate the column to the left of the columns with the columns name. Cannot be True if include_index_name is True. encoding: Encoding type to be used when opening the file. line_terminator: The string used to terminate lines. quote_char: A one-character string used to quote fields containing special characters, such as the delimiter or quote_char, or which contain new-line characters. quote_double: Controls how instances of quote_char appearing inside a field should themselves be quoted. When True, the character is doubled. When False, the escape_char is used as a prefix to the quote_char. It defaults to True. escape_char: A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE_NONE and the quotechar if quote_double is False. quoting: Controls when quotes should be generated. It can take on any of the QUOTE_* constants from the standard library csv module. store_filter: A StoreFilter instance.", "FrameHE.to_delimited()": "Given a file path or file-like object, write the Frame as delimited text. A delimiter character must be specified. Args: A file path, PathLib instance, or file-like object. * delimiter: Character to be used for delimiterarating elements. include_index: If True, the index will be written. include_index_name: If including columns, populate the row above the index with the index name. Cannot be True if include_columns_name is True. include_columns: If True, the columns will be written. include_columns_name: If including index, populate the column to the left of the columns with the columns name. Cannot be True if include_index_name is True. encoding: Encoding type to be used when opening the file. line_terminator: The string used to terminate lines. quote_char: A one-character string used to quote fields containing special characters, such as the delimiter or quote_char, or which contain new-line characters. quote_double: Controls how instances of quote_char appearing inside a field should themselves be quoted. When True, the character is doubled. When False, the escape_char is used as a prefix to the quote_char. It defaults to True. escape_char: A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE_NONE and the quotechar if quote_double is False. quoting: Controls when quotes should be generated. It can take on any of the QUOTE_* constants from the standard library csv module. store_filter: A StoreFilter instance.", "FrameHE.to_frame()": "Return Frame instance from this Frame. If this Frame is immutable the same instance will be returned.", "FrameHE.to_frame_go()": "Return a FrameGO instance from this Frame.", "FrameHE.to_frame_he()": "Return a FrameHE instance from this Frame. If this Frame is immutable the same instance will be returned.", "FrameHE.to_html()": "Return an HTML table representation of this Frame using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "FrameHE.to_html_datatables()": "Return a complete HTML representation of this Frame using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "FrameHE.to_json_columns()": "Export a Frame as a JSON string constructed as follows: A JSON object keyed by column labels, where values are columns represented by an object mapping of index labels to values. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "FrameHE.to_json_index()": "Export a Frame as a JSON string constructed as follows: A JSON object keyed by index labels, where values are rows represented by an object mapping of column labels to values. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "FrameHE.to_json_records()": "Export a Frame as a JSON string constructed as follows: A JSON array of row objects, where column labels are repeated for each row, and no index labels are included. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "FrameHE.to_json_split()": "Export a Frame as a JSON string constructed as follows: A JSON object with a key for \"columns\", \"index\", and \"data\", where data is given as an array of arrays of row values. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "FrameHE.to_json_typed()": "Export a Frame as a JSON string constructed as follows: A JSON object with a key for \"columns\", \"index\", and \"data\", where data is given as an array of arrays of column values; additionally, a key for \"__meta__\" defines an object with complete metadata and typing information. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "FrameHE.to_json_values()": "Export a Frame as a JSON string constructed as follows: A JSON array of arrays of row values; no index or columns labels are included. Args: indent: If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level.", "FrameHE.to_latex()": "Display the Frame as a LaTeX formatted table.", "FrameHE.to_markdown()": "Display the Frame as a Markdown formatted table.", "FrameHE.to_npy()": "Write a Frame as a directory of npy file.", "FrameHE.to_npz()": "Write a Frame as an npz file.", "FrameHE.to_pairs()": "Return a tuple of major axis key, minor axis key vlaue pairs, where major axis is determined by the axis argument. Note that the returned object is eagerly constructed; use an iterator interface for lazy iteration.", "FrameHE.to_pandas()": "Return a Pandas DataFrame.", "FrameHE.to_parquet()": "Write an Arrow Parquet binary file.", "FrameHE.to_pickle()": "Write a Frame as a Python pickle. The pickle module is not secure. Only unpickle data you trust. Args: fp: file path to write. protocol: Pickle protocol to use.", "FrameHE.to_rst()": "Display the Frame as an RST formatted table.", "FrameHE.to_series()": "Return a Series representation of this Frame, where the index is extended with columns to from tuple labels for each element in the Frame. Args: index_constructor: Index constructor of the tuples produced by combining index and columns into one label. Providing IndexHierarchy.from_labels will produce a hierarchical index.", "FrameHE.to_sql()": "Write Frame to the database provided by connection. Connections to SQLite, PostgreSQL, MySQL, and MariaDB are fully supported. The table name can be provided by label, otherwise Frame.name will be used. If the target table does not exist, it will be created using optimal mappings to NumPy dtypes. If the target table exists, records will be appended. Parameterized insert queries are always used. Records will never be deleted, nor tables dropped. If using SQLAlchemy, pass the underlying DBAPI connection object (via the sqlalchemy.engine.Connection.connection attribute) as the conection. Args: label: Provide a name for the table; if not provided, Frame.name will be used if not None, else an exception will be raised. include_index: If True, the index will be included. schema: If provided, this string will be used as a database schema label to prefix the table name in all SQL queries. placeholder: String used as a placeholder in parameterized insert queries. Correct defaults are provided for SQLite, PostgreSQL, MySQL, and MariaDB. dtype_to_type_decl: Mapping from NumPy dtype to a string to be used in type declaration when creating tables. Sensible defaults are provided for SQLite, PostgreSQL, MySQL, and MariaDB.", "FrameHE.to_sqlite()": "Write the Frame as single-table SQLite file.", "FrameHE.to_tsv()": "Given a file path or file-like object, write the Frame as delimited text. The delimiter is set to a tab. Args: A file path, PathLib instance, or file-like object. * include_index: If True, the index will be written. include_index_name: If including columns, populate the row above the index with the index name. Cannot be True if include_columns_name is True. include_columns: If True, the columns will be written. include_columns_name: If including index, populate the column to the left of the columns with the columns name. Cannot be True if include_index_name is True. encoding: Encoding type to be used when opening the file. line_terminator: The string used to terminate lines. quote_char: A one-character string used to quote fields containing special characters, such as the delimiter or quote_char, or which contain new-line characters. quote_double: Controls how instances of quote_char appearing inside a field should themselves be quoted. When True, the character is doubled. When False, the escape_char is used as a prefix to the quote_char. It defaults to True. escape_char: A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE_NONE and the quotechar if quote_double is False. quoting: Controls when quotes should be generated. It can take on any of the QUOTE_* constants from the standard library csv module. store_filter: A StoreFilter instance.", "FrameHE.to_visidata()": "Open an interactive VisiData session.", "FrameHE.to_xarray()": "Return an xarray Dataset. In order to preserve columnar types, and following the precedent of Pandas, the Frame, with a 1D index, is translated as a Dataset of 1D arrays, where each DataArray is a 1D array. If the index is an IndexHierarchy, each column is mapped into an ND array of shape equal to the unique values found at each depth of the index.", "FrameHE.to_xlsx()": "Write the Frame as single-sheet XLSX file.", "FrameHE.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "FrameHE.T": "Transpose. Return a Frame with index as columns and vice versa.", "FrameHE.columns": "The IndexBase instance assigned for column labels.", "FrameHE.dtypes": "Return a Series of dytpes for each realizable column. Returns: Series", "FrameHE.index": "The IndexBase instance assigned for row labels.", "FrameHE.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "FrameHE.mloc": "The memory locations, represented as an array of integers, of the underlying NumPy arrays.", "FrameHE.name": "A hashable label attached to this container. Returns: Hashable", "FrameHE.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "FrameHE.ndim": "Return the number of dimensions, which for a Frame is always 2. Returns: int", "FrameHE.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int, int]", "FrameHE.size": "Return the size of the underlying NumPy array. Returns: int", "FrameHE.__array__()": "Support the __array__ interface, returning an array of values.", "FrameHE.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "FrameHE.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "FrameHE.__dataframe__()": "Return a data-frame interchange protocol compliant object. See https://data-apis.org/dataframe-protocol/latest for more information.", "FrameHE.__deepcopy__()": "", "FrameHE.__len__()": "Length of rows in values.", "FrameHE.__round__()": "Return a Frame rounded to the given decimals. Negative decimals round to the left of the decimal point. Args: decimals: number of decimals to round to. Returns: Frame", "FrameHE.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameHE.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameHE.astype[]()": "Selector of columns by label. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.", "FrameHE.astype()": "Apply a single dtype to all columns.", "FrameHE.clip()": "Apply a clip operation to this Frame. Note that clip operations can be applied to object types, but cannot be applied to non-numerical objects (e.g., strings, None) Args: lower: value, Series, Frame upper: value, Series, Frame axis: required if lower or upper are given as a Series.", "FrameHE.consolidate[]": "Return the full Frame, selecting with key a subset of columns for consolidation. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.", "FrameHE.consolidate()": "Apply consolidation to all columns.", "FrameHE.consolidate.status": "Display consolidation status of this Frame.", "FrameHE.corr()": "Compute a correlation matrix. Args: axis: if 0, each row represents a variable, with observations as columns; if 1, each column represents a variable, with observations as rows. Defaults to 1.", "FrameHE.count()": "Return the count of non-NA values along the provided axis, where 0 provides counts per column, 1 provides counts per row. Args: axis", "FrameHE.cov()": "Compute a covariance matrix. Args: axis: if 0, each row represents a variable, with observations as columns; if 1, each column represents a variable, with observations as rows. Defaults to 1. ddof: Delta degrees of freedom, defaults to 1.", "FrameHE.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameHE.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameHE.drop_duplicated()": "Return a Frame with duplicated rows (axis 0) or columns (axis 1) removed. All values in the row or column are compared to determine duplication. Args: axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. exclude_first: Boolean to select if the first duplicated value is excluded. exclude_last: Boolean to select if the last duplicated value is excluded.", "FrameHE.dropfalsy()": "Return a new Frame after removing rows (axis 0) or columns (axis 1) where any or all values are falsy. The condition is determined by a NumPy ufunc that process the Boolean array returned by isfalsy(); the default is np.all. Args: axis: condition:", "FrameHE.dropna()": "Return a new Frame after removing rows (axis 0) or columns (axis 1) where any or all values are NA (NaN or None). The condition is determined by a NumPy ufunc that process the Boolean array returned by isna(); the default is np.all. Args: axis: condition:", "FrameHE.duplicated()": "Return an axis-sized Boolean Series that shows True for all rows (axis 0) or columns (axis 1) duplicated. Args: axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. exclude_first: Boolean to select if the first duplicated value is excluded. exclude_last: Boolean to select if the last duplicated value is excluded.", "FrameHE.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "FrameHE.fillfalsy()": "Return a new Frame after replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "FrameHE.fillfalsy_backward()": "Return a new Frame after filling backward falsy values with the first observed value. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameHE.fillfalsy_forward()": "Return a new Frame after filling forward falsy values with the last observed value. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameHE.fillfalsy_leading()": "Return a new Frame after filling leading (and only leading) falsy values with the provided value. Args: value: Value to be used to replace missing values (NaN or None). axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameHE.fillfalsy_trailing()": "Return a new Frame after filling trailing (and only trailing) falsy values with the provided value. Args: value: Value to be used to replace missing values (NaN or None). axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameHE.fillna()": "Return a new Frame after replacing null (NaN or None) values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "FrameHE.fillna_backward()": "Return a new Frame after filling backward null (NaN or None) with the first observed value. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameHE.fillna_forward()": "Return a new Frame after filling forward null (NaN or None) with the last observed value. Args: limit: Set the maximum count of missing values (NaN or None) to be filled per contiguous region of missing vlaues. A value of 0 is equivalent to no limit. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameHE.fillna_leading()": "Return a new Frame after filling leading (and only leading) null (NaN or None) with the provided value. Args: value: Value to be used to replace missing values (NaN or None). axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameHE.fillna_trailing()": "Return a new Frame after filling trailing (and only trailing) null (NaN or None) with the provided value. Args: value: Value to be used to replace missing values (NaN or None). axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameHE.head()": "Return a Frame consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Frame", "FrameHE.iloc_max()": "Return the integer indices corresponding to the maximum values found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameHE.iloc_min()": "Return the integer indices corresponding to the minimum values found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameHE.iloc_notfalsy_first()": "Return the position corresponding to the first non-falsy (including nan) values along the selected axis. Args: {skipna} {axis}", "FrameHE.iloc_notfalsy_last()": "Return the position corresponding to the last non-falsy (including nan) values along the selected axis. Args: {skipna} {axis}", "FrameHE.iloc_notna_first()": "Return the position corresponding to the first non-missing values along the selected axis. Args: {skipna} {axis}", "FrameHE.iloc_notna_last()": "Return the position corresponding to the last non-missing values along the selected axis. Args: {skipna} {axis}", "FrameHE.insert_after()": "Create a new Frame by inserting a named Series or Frame at the position after the label specified by key. Args: key: Label after which the new container will be inserted. container: Container to be inserted. fill_value: A value to be used to fill space after reindexing the new container. Returns: Frame", "FrameHE.insert_before()": "Create a new Frame by inserting a named Series or Frame at the position before the label specified by key. Args: key: Label before which the new container will be inserted. container: Container to be inserted. fill_value: A value to be used to fill space after reindexing the new container. Returns: Frame", "FrameHE.isfalsy()": "Return a same-indexed, Boolean Frame indicating True which values are falsy.", "FrameHE.isin()": "Return a same-sized Boolean Frame that shows if the same-positioned element is in the passed iterable.", "FrameHE.isna()": "Return a same-indexed, Boolean Frame indicating True which values are NaN or None.", "FrameHE.join_inner()": "Perform an inner join. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "FrameHE.join_left()": "Perform a left outer join. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "FrameHE.join_outer()": "Perform an outer join. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "FrameHE.join_right()": "Perform a right outer join. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "FrameHE.loc_max()": "Return the labels corresponding to the maximum values found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameHE.loc_min()": "Return the labels corresponding to the minimum value found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "FrameHE.loc_notfalsy_first()": "Return the labels corresponding to the first non-falsy (including nan) values along the selected axis. Args: {skipna} {axis}", "FrameHE.loc_notfalsy_last()": "Return the labels corresponding to the last non-falsy (including nan) values along the selected axis. Args: {skipna} {axis}", "FrameHE.loc_notna_first()": "Return the labels corresponding to the first non-missing values along the selected axis. Args: {skipna} {axis}", "FrameHE.loc_notna_last()": "Return the labels corresponding to the last non-missing values along the selected axis. Args: {skipna} {axis}", "FrameHE.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameHE.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameHE.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameHE.merge_inner()": "Perform an inner merge, an inner join where matched columns are coalesced. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. Provide a sequence of labels to be used for the merge fields. Must have a length equal to left and right selections. If not provided, merge fields will be named from the left. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "FrameHE.merge_left()": "Perform a left merge, a left join where matched columns are coalesced. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. Provide a sequence of labels to be used for the merge fields. Must have a length equal to left and right selections. If not provided, merge fields will be named from the left. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "FrameHE.merge_outer()": "Perform an outer merge, an outer join where matched columns are coalesced. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. Provide a sequence of labels to be used for the merge fields. Must have a length equal to left and right selections. If not provided, merge fields will be named from the left. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "FrameHE.merge_right()": "Perform a right merge, a right join where matched columns are coalesced. Args: left_depth_level: Specify one or more left index depths to include in the join predicate. left_columns: Specify one or more left columns to include in the join predicate. right_depth_level: Specify one or more right index depths to include in the join predicate. right_columns: Specify one or more right columns to include in the join predicate. Provide a sequence of labels to be used for the merge fields. Must have a length equal to left and right selections. If not provided, merge fields will be named from the left. left_template: Provide a format string for naming left columns in the joined result. right_template: Provide a format string for naming right columns in the joined result. fill_value: A value to be used to fill space created in the join. If True, and appropriate index will be returned in the resultant Frame. Returns: Frame", "FrameHE.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameHE.notfalsy()": "Return a same-indexed, Boolean Frame indicating True which values are not falsy.", "FrameHE.notna()": "Return a same-indexed, Boolean Frame indicating True which values are not NaN or None.", "FrameHE.pivot()": "Produce a pivot table, where one or more columns is selected for each of index_fields, columns_fields, and data_fields. Unique values from the provided index_fields will be used to create a new index; unique values from the provided columns_fields will be used to create a new columns; if one data_fields value is selected, that is the value that will be displayed; if more than one values is given, those values will be presented with a hierarchical index on the columns; if data_fields is not provided, all unused fields will be displayed. Args: index_fields columns_fields data_fields * fill_value: If the index expansion produces coordinates that have no existing data value, fill that position with this value. func: function to apply to data_fields, or a dictionary of labelled functions to apply to data fields, producing an additional hierarchical level. index_constructor:", "FrameHE.pivot_stack()": "Move labels from the columns to the index, creating or extending an IndexHierarchy on the index. Args: depth_level: selection of columns depth or depth to move onto the index.", "FrameHE.pivot_unstack()": "Move labels from the index to the columns, creating or extending an IndexHierarchy on the columns. Args: depth_level: selection of index depth or depth to move onto the columns.", "FrameHE.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameHE.rank_dense()": "Rank values as compactly as possible, where ties get the same value, and ranks are contiguous (potentially non-unique) integers. Args: axis: Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row) skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Frame", "FrameHE.rank_max()": "Rank values where tied values are assigned the maximum ordinal rank; ranks are potentially non-contiguous and non-unique integers. Args: axis: Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row) skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Frame", "FrameHE.rank_mean()": "Rank values where tied values are assigned the mean of the ordinal ranks; ranks are potentially non-contiguous and non-unique floats. Args: axis: Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row) skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Frame", "FrameHE.rank_min()": "Rank values where tied values are assigned the minimum ordinal rank; ranks are potentially non-contiguous and non-unique integers. Args: axis: Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row) skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Frame", "FrameHE.rank_ordinal()": "Rank values distinctly, where ties get distinct values that maintain their ordering, and ranks are contiguous unique integers. Args: axis: Integer specifying axis of ranking, where 0 ranks vertically (within each column) and 1 ranks horizontally (within each row) skipna: If True, exclude NA values (NaN or None) from ranking, replacing those values with fill_value. ascending: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. start: The reference value for the lowest rank. Some ranking methodologies (mean, max) may not return this value given some inputs. The default is 0; for ranks that start from 1, provide a value of 1. fill_value: A value to be used to fill NA values ignored in ranking when skipna is True. The default is np.nan but can be set to any value to force NA values to the \"bottom\" or \"top\" of a rank as needed. Returns: Series", "FrameHE.rehierarch()": "Produce a new Frame with index and/or columns constructed with a transformed hierarchy. Args: index: Depth level specifier columns: Depth level specifier", "FrameHE.reindex()": "Return a new Frame with labels defined by the provided index. The size and ordering of the data is determined by the newly provided index, where data will continue to be aligned under labels found in both the new and the old index. Labels found only in the new index will be filled with fill_value. Args: index: An iterable of unique, hashable values, or another Index or IndexHierarchy, to be used as the labels of the index. columns: An iterable of unique, hashable values, or another Index or IndexHierarchy, to be used as the labels of the index. fill_value: A value to be used to fill space created by a new index that has values not found in the previous index. own_index: Flag the passed index as ownable by this Frame. Primarily used by internal clients. own_columns: Flag the passed columns as ownable by this Frame. Primarily used by internal clients. check_equals:", "FrameHE.relabel()": "Return a new Frame with transformed labels on the index. The size and ordering of the data is never changed in a relabeling operation. The resulting index must be unique. Args: index: One of the following types, used to create new index labels with the same size as the previous index. (a) A mapping (as a dictionary or Series), used to lookup and transform the labels in the previous index. Labels not found in the mapping will be reused. (b) A function, returning a hashable, that is applied to each label in the previous index. (c) The IndexAutoFactory type, to apply auto-incremented integer labels. (d) An Index initializer, i.e., either an iterable of hashables or an Index instance. columns: One of the following types, used to create new columns labels with the same size as the previous columns. (a) A mapping (as a dictionary or Series), used to lookup and transform the labels in the previous columns. Labels not found in the mapping will be reused. (b) A function, returning a hashable, that is applied to each label in the previous columns. (c) The IndexAutoFactory type, to apply auto-incremented integer labels. (d) An Index initializer, i.e., either an iterable of hashables or an Index instance.", "FrameHE.relabel_flat()": "Return a new Frame, where an IndexHierarchy (if defined) is replaced with a flat, one-dimension index of tuples. Args: index: Boolean to flag flatening on the index. columns: Boolean to flag flatening on the columns.", "FrameHE.relabel_level_add()": "Return a new Frame, adding a new root level to an existing IndexHierarchy, or creating an IndexHierarchy if one is not yet defined. Args: index: A hashable value to be used as a new root level, extending or creating an IndexHierarchy columns: A hashable value to be used as a new root level, extending or creating an IndexHierarchy * index_constructor: columns_constructor:", "FrameHE.relabel_level_drop()": "Return a new Frame, dropping one or more levels from a either the root or the leaves of an IndexHierarchy. The resulting index must be unique. Args: index: A positive integer drops that many outer-most (root) levels; a negative integer drops that many inner-most (leaf)levels. Default is zero. columns: A positive integer drops that many outer-most (root) levels; a negative integer drops that many inner-most (leaf)levels. Default is zero.", "FrameHE.relabel_shift_in()": "Create, or augment, an IndexHierarchy by providing one or more selections from the Frame (via axis-appropriate loc selections) to move into the Index. Args: key: a loc-style selection on the opposite axis. axis: 0 modifies the index by selecting columns with key; 1 modifies the columns by selecting rows with key.", "FrameHE.relabel_shift_out()": "Shift values from an index on an axis to the Frame by providing one or more depth level selections. Args: dpeth_level: an iloc-style selection on the Index of the specified axis. axis: 0 modifies the index by selecting columns with depth_level; 1 modifies the columns by selecting rows with depth_level.", "FrameHE.rename()": "Return a new Frame with an updated name attribute. Optionally update the name attribute of index and columns.", "FrameHE.roll()": "Roll columns and/or rows by positive or negative integer counts, where columns and/or rows roll around the axis. Args: include_index: Determine if index is included in index-wise rotation. include_columns: Determine if column index is included in index-wise rotation.", "FrameHE.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of labels to select from the index. Number of labels to select from the columns. Initial state of random selection.", "FrameHE.set_columns()": "Return a new Frame produced by setting the given row as the columns, optionally removing that row from the new Frame. Args: index: * drop: columns_constructor:", "FrameHE.set_columns_hierarchy()": "Given an iterable of index labels, return a new Frame with those rows as an IndexHierarchy on the columns. Args: index: Iterable of index labels. drop: Boolean to determine if selected rows should be removed from the data. columns_constructors: Optionally provide a sequence of Index constructors, of length equal to depth, to be used in converting row Index components in the IndexHierarchy. reorder_for_hierarchy: reorder the columns to produce a hierarchible Index from the selected columns. Returns: Frame", "FrameHE.set_index()": "Return a new Frame produced by setting the given column as the index, optionally removing that column from the new Frame. Args: column: * drop: index_constructor:", "FrameHE.set_index_hierarchy()": "Given an iterable of column labels, return a new Frame with those columns as an IndexHierarchy on the index. Args: columns: Iterable of column labels. drop: Boolean to determine if selected columns should be removed from the data. index_constructors: Optionally provide a sequence of Index constructors, of length equal to depth, to be used in converting columns Index components in the IndexHierarchy. reorder_for_hierarchy: reorder the rows to produce a hierarchible Index from the selected columns, assuming hierarchability is possible. Returns: Frame", "FrameHE.shift()": "Shift columns and/or rows by positive or negative integer counts, where columns and/or rows fall of the axis and introduce missing values, filled by fill_value.", "FrameHE.sort_columns()": "Return a new Frame ordered by the sorted columns. Args: ascendings: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "FrameHE.sort_index()": "Return a new Frame ordered by the sorted Index. Args: ascendings: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "FrameHE.sort_values()": "Return a new Frame ordered by the sorted values, where values are given by single column or iterable of columns. Args: label: A label or iterable of labels to select the columns (for axis 1) or rows (for axis 0) to sort. * ascendings: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. axis: Axis upon which to sort; 0 orders columns based on one or more rows; 1 orders rows based on one or more columns. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "FrameHE.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameHE.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameHE.tail()": "Return a Frame consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Frame", "FrameHE.transpose()": "Transpose. Return a Frame with index as columns and vice versa.", "FrameHE.unique()": "Return a NumPy array of unqiue values. If the axis argument is provided, uniqueness is determined by columns or row.", "FrameHE.unique_enumerated()": "{doc} {args}", "FrameHE.unset_columns()": "Return a new Frame where columns are added to the top of the data, and an IndexAutoFactory is used to populate new columns. This operation potentially forces a complete copy of all data. Args: names: An sequence of hashables to be used to name the unset columns. If an Index, a single hashable should be provided; if an IndexHierarchy, as many hashables as the depth must be provided. index_constructors:", "FrameHE.unset_index()": "Return a new Frame where the index is added to the front of the data, and an IndexAutoFactory is used to populate a new index. If the Index has a name, that name will be used for the column name, otherwise a suitable default will be used. As underlying NumPy arrays are immutable, data is not copied. Args: names: An iterable of hashables to be used to name the unset index. If an Index, a single hashable should be provided; if an IndexHierarchy, as many hashables as the depth must be provided. consolidate_blocks: columns_constructors:", "FrameHE.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "FrameHE.__contains__()": "Inclusion of value in column labels.", "FrameHE.__iter__()": "Iterator of column labels, same as Frame.keys.", "FrameHE.__reversed__()": "Returns a reverse iterator on the frame's columns.", "FrameHE.get()": "Return the value found at the columns key, else the default if the key is not found. This method is implemented to complete the dictionary-like interface.", "FrameHE.items()": "Iterator of pairs of column label and corresponding column Series.", "FrameHE.keys()": "Iterator of column labels.", "FrameHE.values": "A 2D NumPy array of all values in the Frame. As this is a single array, heterogenous columnar types might be coerced to a compatible type.", "FrameHE.interface": "A Frame documenting the interface of this class.", "FrameHE.__repr__()": "", "FrameHE.__str__()": "Return str(self).", "FrameHE.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "FrameHE.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "FrameHE.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "FrameHE.assign[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, Frame, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "FrameHE.assign[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameHE.assign[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameHE.assign[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameHE.assign.iloc[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, Frame, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "FrameHE.assign.iloc[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameHE.assign.iloc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameHE.assign.iloc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameHE.assign.loc[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, Frame, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "FrameHE.assign.loc[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameHE.assign.loc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameHE.assign.loc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameHE.assign.bloc[]()": "Assign the value in the position specified by the selector. The name attribute is propagated to the returned container. Args: value: Value to assign, which can be a Series, Frame, np.ndarray, or element. *. fill_value: If the value parameter has to be reindexed, this element will be used to fill newly created elements.", "FrameHE.assign.bloc[].apply()": "Provide a function to apply to the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameHE.assign.bloc[].apply_element()": "Provide a function to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameHE.assign.bloc[].apply_element_items()": "Provide a function, taking pairs of label, element, to apply to each element in the assignment target, and use that as the assignment value. Args: func: A function, taking pairs of label, element, to apply to the assignment target. * fill_value: If the function does not produce a container with a matching index, the element will be used to fill newly created elements.", "FrameHE.bloc[]": "", "FrameHE.drop[]": "Label-based selection.", "FrameHE.drop.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "FrameHE.drop.loc[]": "", "FrameHE.mask[]": "Label-based selection.", "FrameHE.mask.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "FrameHE.mask.loc[]": "", "FrameHE.masked_array[]": "Label-based selection.", "FrameHE.masked_array.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "FrameHE.masked_array.loc[]": "", "FrameHE.[]": "Selector of columns by label. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.", "FrameHE.iloc[]": "", "FrameHE.loc[]": "", "FrameHE.iter_array()": "Iterator of np.array, where arrays are drawn from columns (axis=0) or rows (axis=1)", "FrameHE.iter_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_array_items()": "Iterator of pairs of label, np.array, where arrays are drawn from columns (axis=0) or rows (axis=1)", "FrameHE.iter_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_element()": "Iterator of elements, ordered by row then column.", "FrameHE.iter_element().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_element().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_element().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_element().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_element().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_element().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameHE.iter_element().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameHE.iter_element().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_element().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameHE.iter_element().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameHE.iter_element().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_element().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "FrameHE.iter_element().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "FrameHE.iter_element_items()": "Iterator of pairs of label, element, where labels are pairs of index, columns labels, ordered by row then column.", "FrameHE.iter_element_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_element_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_element_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_element_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_element_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_element_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameHE.iter_element_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameHE.iter_element_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_element_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameHE.iter_element_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameHE.iter_element_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_element_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "FrameHE.iter_element_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "FrameHE.iter_group()": "Iterator of Frame grouped by unique values found in one or more columns (axis=0) or rows (axis=1).", "FrameHE.iter_group().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_group().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_group().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_group().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_group().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group().reduce.from_map_func().keys()": "", "FrameHE.iter_group().reduce.from_map_func().__iter__()": "", "FrameHE.iter_group().reduce.from_map_func().items()": "", "FrameHE.iter_group().reduce.from_map_func().values()": "", "FrameHE.iter_group().reduce.from_map_func().to_frame()": "", "FrameHE.iter_group().reduce.from_label_map().keys()": "", "FrameHE.iter_group().reduce.from_label_map().__iter__()": "", "FrameHE.iter_group().reduce.from_label_map().items()": "", "FrameHE.iter_group().reduce.from_label_map().values()": "", "FrameHE.iter_group().reduce.from_label_map().to_frame()": "", "FrameHE.iter_group().reduce.from_label_pair_map().keys()": "", "FrameHE.iter_group().reduce.from_label_pair_map().__iter__()": "", "FrameHE.iter_group().reduce.from_label_pair_map().items()": "", "FrameHE.iter_group().reduce.from_label_pair_map().values()": "", "FrameHE.iter_group().reduce.from_label_pair_map().to_frame()": "", "FrameHE.iter_group_array()": "Iterator of np.ndarray grouped by unique values found in one or more columns (axis=0) or rows (axis=1).", "FrameHE.iter_group_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_group_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_group_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_group_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_group_array().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_array().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_array().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_array().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_array().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_array().reduce.from_map_func().keys()": "", "FrameHE.iter_group_array().reduce.from_map_func().__iter__()": "", "FrameHE.iter_group_array().reduce.from_map_func().items()": "", "FrameHE.iter_group_array().reduce.from_map_func().values()": "", "FrameHE.iter_group_array().reduce.from_map_func().to_frame()": "", "FrameHE.iter_group_array().reduce.from_label_map().keys()": "", "FrameHE.iter_group_array().reduce.from_label_map().__iter__()": "", "FrameHE.iter_group_array().reduce.from_label_map().items()": "", "FrameHE.iter_group_array().reduce.from_label_map().values()": "", "FrameHE.iter_group_array().reduce.from_label_map().to_frame()": "", "FrameHE.iter_group_array().reduce.from_label_pair_map().keys()": "", "FrameHE.iter_group_array().reduce.from_label_pair_map().__iter__()": "", "FrameHE.iter_group_array().reduce.from_label_pair_map().items()": "", "FrameHE.iter_group_array().reduce.from_label_pair_map().values()": "", "FrameHE.iter_group_array().reduce.from_label_pair_map().to_frame()": "", "FrameHE.iter_group_array_items()": "Iterator of pairs of label, np.ndarray grouped by unique values found in one or more columns (axis=0) or rows (axis=1).", "FrameHE.iter_group_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_group_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_group_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_group_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_group_array_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_array_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_array_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_array_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_array_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_array_items().reduce.from_map_func().keys()": "", "FrameHE.iter_group_array_items().reduce.from_map_func().__iter__()": "", "FrameHE.iter_group_array_items().reduce.from_map_func().items()": "", "FrameHE.iter_group_array_items().reduce.from_map_func().values()": "", "FrameHE.iter_group_array_items().reduce.from_map_func().to_frame()": "", "FrameHE.iter_group_array_items().reduce.from_label_map().keys()": "", "FrameHE.iter_group_array_items().reduce.from_label_map().__iter__()": "", "FrameHE.iter_group_array_items().reduce.from_label_map().items()": "", "FrameHE.iter_group_array_items().reduce.from_label_map().values()": "", "FrameHE.iter_group_array_items().reduce.from_label_map().to_frame()": "", "FrameHE.iter_group_array_items().reduce.from_label_pair_map().keys()": "", "FrameHE.iter_group_array_items().reduce.from_label_pair_map().__iter__()": "", "FrameHE.iter_group_array_items().reduce.from_label_pair_map().items()": "", "FrameHE.iter_group_array_items().reduce.from_label_pair_map().values()": "", "FrameHE.iter_group_array_items().reduce.from_label_pair_map().to_frame()": "", "FrameHE.iter_group_items()": "Iterator of pairs of label, Frame grouped by unique values found in one or more columns (axis=0) or rows (axis=1).", "FrameHE.iter_group_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_group_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_group_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_group_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_group_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_items().reduce.from_map_func().keys()": "", "FrameHE.iter_group_items().reduce.from_map_func().__iter__()": "", "FrameHE.iter_group_items().reduce.from_map_func().items()": "", "FrameHE.iter_group_items().reduce.from_map_func().values()": "", "FrameHE.iter_group_items().reduce.from_map_func().to_frame()": "", "FrameHE.iter_group_items().reduce.from_label_map().keys()": "", "FrameHE.iter_group_items().reduce.from_label_map().__iter__()": "", "FrameHE.iter_group_items().reduce.from_label_map().items()": "", "FrameHE.iter_group_items().reduce.from_label_map().values()": "", "FrameHE.iter_group_items().reduce.from_label_map().to_frame()": "", "FrameHE.iter_group_items().reduce.from_label_pair_map().keys()": "", "FrameHE.iter_group_items().reduce.from_label_pair_map().__iter__()": "", "FrameHE.iter_group_items().reduce.from_label_pair_map().items()": "", "FrameHE.iter_group_items().reduce.from_label_pair_map().values()": "", "FrameHE.iter_group_items().reduce.from_label_pair_map().to_frame()": "", "FrameHE.iter_group_labels()": "Iterator of Frame grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).", "FrameHE.iter_group_labels().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_group_labels().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_group_labels().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_group_labels().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_group_labels_array()": "Iterator of np.ndarray grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).", "FrameHE.iter_group_labels_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_group_labels_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_group_labels_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_group_labels_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_group_labels_array_items()": "Iterator of pairs of label, np.ndarray grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).", "FrameHE.iter_group_labels_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_group_labels_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_group_labels_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_group_labels_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_group_labels_items()": "Iterator of pairs of label, Frame grouped by unique labels found in one or more index depths (axis=0) or columns depths (axis=1).", "FrameHE.iter_group_labels_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_group_labels_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_group_labels_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_group_labels_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_group_other()": "Iterator of Frame grouped by unique values found in a supplied container.", "FrameHE.iter_group_other().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_group_other().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_group_other().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_group_other().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_group_other().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other().reduce.from_map_func().keys()": "", "FrameHE.iter_group_other().reduce.from_map_func().__iter__()": "", "FrameHE.iter_group_other().reduce.from_map_func().items()": "", "FrameHE.iter_group_other().reduce.from_map_func().values()": "", "FrameHE.iter_group_other().reduce.from_map_func().to_frame()": "", "FrameHE.iter_group_other().reduce.from_label_map().keys()": "", "FrameHE.iter_group_other().reduce.from_label_map().__iter__()": "", "FrameHE.iter_group_other().reduce.from_label_map().items()": "", "FrameHE.iter_group_other().reduce.from_label_map().values()": "", "FrameHE.iter_group_other().reduce.from_label_map().to_frame()": "", "FrameHE.iter_group_other().reduce.from_label_pair_map().keys()": "", "FrameHE.iter_group_other().reduce.from_label_pair_map().__iter__()": "", "FrameHE.iter_group_other().reduce.from_label_pair_map().items()": "", "FrameHE.iter_group_other().reduce.from_label_pair_map().values()": "", "FrameHE.iter_group_other().reduce.from_label_pair_map().to_frame()": "", "FrameHE.iter_group_other_array()": "Iterator of Frame grouped by unique values found in a supplied container.", "FrameHE.iter_group_other_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_group_other_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_group_other_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_group_other_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_group_other_array().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other_array().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other_array().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other_array().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other_array().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other_array().reduce.from_map_func().keys()": "", "FrameHE.iter_group_other_array().reduce.from_map_func().__iter__()": "", "FrameHE.iter_group_other_array().reduce.from_map_func().items()": "", "FrameHE.iter_group_other_array().reduce.from_map_func().values()": "", "FrameHE.iter_group_other_array().reduce.from_map_func().to_frame()": "", "FrameHE.iter_group_other_array().reduce.from_label_map().keys()": "", "FrameHE.iter_group_other_array().reduce.from_label_map().__iter__()": "", "FrameHE.iter_group_other_array().reduce.from_label_map().items()": "", "FrameHE.iter_group_other_array().reduce.from_label_map().values()": "", "FrameHE.iter_group_other_array().reduce.from_label_map().to_frame()": "", "FrameHE.iter_group_other_array().reduce.from_label_pair_map().keys()": "", "FrameHE.iter_group_other_array().reduce.from_label_pair_map().__iter__()": "", "FrameHE.iter_group_other_array().reduce.from_label_pair_map().items()": "", "FrameHE.iter_group_other_array().reduce.from_label_pair_map().values()": "", "FrameHE.iter_group_other_array().reduce.from_label_pair_map().to_frame()": "", "FrameHE.iter_group_other_array_items()": "Iterator of Frame grouped by unique values found in a supplied container.", "FrameHE.iter_group_other_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_group_other_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_group_other_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_group_other_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_group_other_array_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other_array_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other_array_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other_array_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other_array_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other_array_items().reduce.from_map_func().keys()": "", "FrameHE.iter_group_other_array_items().reduce.from_map_func().__iter__()": "", "FrameHE.iter_group_other_array_items().reduce.from_map_func().items()": "", "FrameHE.iter_group_other_array_items().reduce.from_map_func().values()": "", "FrameHE.iter_group_other_array_items().reduce.from_map_func().to_frame()": "", "FrameHE.iter_group_other_array_items().reduce.from_label_map().keys()": "", "FrameHE.iter_group_other_array_items().reduce.from_label_map().__iter__()": "", "FrameHE.iter_group_other_array_items().reduce.from_label_map().items()": "", "FrameHE.iter_group_other_array_items().reduce.from_label_map().values()": "", "FrameHE.iter_group_other_array_items().reduce.from_label_map().to_frame()": "", "FrameHE.iter_group_other_array_items().reduce.from_label_pair_map().keys()": "", "FrameHE.iter_group_other_array_items().reduce.from_label_pair_map().__iter__()": "", "FrameHE.iter_group_other_array_items().reduce.from_label_pair_map().items()": "", "FrameHE.iter_group_other_array_items().reduce.from_label_pair_map().values()": "", "FrameHE.iter_group_other_array_items().reduce.from_label_pair_map().to_frame()": "", "FrameHE.iter_group_other_items()": "Iterator of Frame grouped by unique values found in a supplied container.", "FrameHE.iter_group_other_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_group_other_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_group_other_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_group_other_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_group_other_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_group_other_items().reduce.from_map_func().keys()": "", "FrameHE.iter_group_other_items().reduce.from_map_func().__iter__()": "", "FrameHE.iter_group_other_items().reduce.from_map_func().items()": "", "FrameHE.iter_group_other_items().reduce.from_map_func().values()": "", "FrameHE.iter_group_other_items().reduce.from_map_func().to_frame()": "", "FrameHE.iter_group_other_items().reduce.from_label_map().keys()": "", "FrameHE.iter_group_other_items().reduce.from_label_map().__iter__()": "", "FrameHE.iter_group_other_items().reduce.from_label_map().items()": "", "FrameHE.iter_group_other_items().reduce.from_label_map().values()": "", "FrameHE.iter_group_other_items().reduce.from_label_map().to_frame()": "", "FrameHE.iter_group_other_items().reduce.from_label_pair_map().keys()": "", "FrameHE.iter_group_other_items().reduce.from_label_pair_map().__iter__()": "", "FrameHE.iter_group_other_items().reduce.from_label_pair_map().items()": "", "FrameHE.iter_group_other_items().reduce.from_label_pair_map().values()": "", "FrameHE.iter_group_other_items().reduce.from_label_pair_map().to_frame()": "", "FrameHE.iter_series()": "Iterator of Series, where Series are drawn from columns (axis=0) or rows (axis=1)", "FrameHE.iter_series().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_series().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_series().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_series().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_series_items()": "Iterator of pairs of label, Series, where Series are drawn from columns (axis=0) or rows (axis=1)", "FrameHE.iter_series_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_series_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_series_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_series_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_tuple()": "Iterator of NamedTuple, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional constructor callable can be used to provide a NamedTuple class (or any other constructor called with a single iterable) to be used to create each yielded axis value.", "FrameHE.iter_tuple().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_tuple().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_tuple().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_tuple().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_tuple().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_tuple().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameHE.iter_tuple().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameHE.iter_tuple().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_tuple().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameHE.iter_tuple().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameHE.iter_tuple().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_tuple().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "FrameHE.iter_tuple().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "FrameHE.iter_tuple_items()": "Iterator of pairs of label, NamedTuple, where tuples are drawn from columns (axis=0) or rows (axis=1)", "FrameHE.iter_tuple_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_tuple_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_tuple_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_tuple_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_tuple_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_tuple_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameHE.iter_tuple_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameHE.iter_tuple_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_tuple_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameHE.iter_tuple_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "FrameHE.iter_tuple_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_tuple_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "FrameHE.iter_tuple_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "FrameHE.iter_window()": "Iterator of windowed values, where values are given as a Frame. Args: size: Elements per window, given as an integer greater than 0. axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. step: Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the size will result in non-overlapping windows. window_sized: if True, windows with fewer elements than size are skipped. window_func: Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window. window_valid: Function that, given an array window, returns True if the window is valid; invalid windows are skipped. label_shift: A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, label_shift can be set to one less than size. label_missing_skips: If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label. label_missing_raises: If True, a window that cannot derive a label will raise an exception. start_shift: A shift to determine the first element where window collection begins. size_increment: A value to be added to size with each window after the first, so as to, in combination with setting step to 0, permit iterating over expanding windows.", "FrameHE.iter_window().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_window().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_window().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_window().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_window().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window().reduce.from_map_func().keys()": "", "FrameHE.iter_window().reduce.from_map_func().__iter__()": "", "FrameHE.iter_window().reduce.from_map_func().items()": "", "FrameHE.iter_window().reduce.from_map_func().values()": "", "FrameHE.iter_window().reduce.from_map_func().to_frame()": "", "FrameHE.iter_window().reduce.from_label_map().keys()": "", "FrameHE.iter_window().reduce.from_label_map().__iter__()": "", "FrameHE.iter_window().reduce.from_label_map().items()": "", "FrameHE.iter_window().reduce.from_label_map().values()": "", "FrameHE.iter_window().reduce.from_label_map().to_frame()": "", "FrameHE.iter_window().reduce.from_label_pair_map().keys()": "", "FrameHE.iter_window().reduce.from_label_pair_map().__iter__()": "", "FrameHE.iter_window().reduce.from_label_pair_map().items()": "", "FrameHE.iter_window().reduce.from_label_pair_map().values()": "", "FrameHE.iter_window().reduce.from_label_pair_map().to_frame()": "", "FrameHE.iter_window_array()": "Iterator of windowed values, where values are given as a np.array. Args: size: Elements per window, given as an integer greater than 0. axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. step: Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the size will result in non-overlapping windows. window_sized: if True, windows with fewer elements than size are skipped. window_func: Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window. window_valid: Function that, given an array window, returns True if the window is valid; invalid windows are skipped. label_shift: A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, label_shift can be set to one less than size. label_missing_skips: If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label. label_missing_raises: If True, a window that cannot derive a label will raise an exception. start_shift: A shift to determine the first element where window collection begins. size_increment: A value to be added to size with each window after the first, so as to, in combination with setting step to 0, permit iterating over expanding windows.", "FrameHE.iter_window_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_window_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_window_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_window_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_window_array().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window_array().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window_array().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window_array().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window_array().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window_array().reduce.from_map_func().keys()": "", "FrameHE.iter_window_array().reduce.from_map_func().__iter__()": "", "FrameHE.iter_window_array().reduce.from_map_func().items()": "", "FrameHE.iter_window_array().reduce.from_map_func().values()": "", "FrameHE.iter_window_array().reduce.from_map_func().to_frame()": "", "FrameHE.iter_window_array().reduce.from_label_map().keys()": "", "FrameHE.iter_window_array().reduce.from_label_map().__iter__()": "", "FrameHE.iter_window_array().reduce.from_label_map().items()": "", "FrameHE.iter_window_array().reduce.from_label_map().values()": "", "FrameHE.iter_window_array().reduce.from_label_map().to_frame()": "", "FrameHE.iter_window_array().reduce.from_label_pair_map().keys()": "", "FrameHE.iter_window_array().reduce.from_label_pair_map().__iter__()": "", "FrameHE.iter_window_array().reduce.from_label_pair_map().items()": "", "FrameHE.iter_window_array().reduce.from_label_pair_map().values()": "", "FrameHE.iter_window_array().reduce.from_label_pair_map().to_frame()": "", "FrameHE.iter_window_array_items()": "Iterator of pairs of label, windowed values, where values are given as a np.array. Args: size: Elements per window, given as an integer greater than 0. axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. step: Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the size will result in non-overlapping windows. window_sized: if True, windows with fewer elements than size are skipped. window_func: Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window. window_valid: Function that, given an array window, returns True if the window is valid; invalid windows are skipped. label_shift: A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, label_shift can be set to one less than size. label_missing_skips: If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label. label_missing_raises: If True, a window that cannot derive a label will raise an exception. start_shift: A shift to determine the first element where window collection begins. size_increment: A value to be added to size with each window after the first, so as to, in combination with setting step to 0, permit iterating over expanding windows.", "FrameHE.iter_window_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_window_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_window_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_window_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_window_array_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window_array_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window_array_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window_array_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window_array_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window_array_items().reduce.from_map_func().keys()": "", "FrameHE.iter_window_array_items().reduce.from_map_func().__iter__()": "", "FrameHE.iter_window_array_items().reduce.from_map_func().items()": "", "FrameHE.iter_window_array_items().reduce.from_map_func().values()": "", "FrameHE.iter_window_array_items().reduce.from_map_func().to_frame()": "", "FrameHE.iter_window_array_items().reduce.from_label_map().keys()": "", "FrameHE.iter_window_array_items().reduce.from_label_map().__iter__()": "", "FrameHE.iter_window_array_items().reduce.from_label_map().items()": "", "FrameHE.iter_window_array_items().reduce.from_label_map().values()": "", "FrameHE.iter_window_array_items().reduce.from_label_map().to_frame()": "", "FrameHE.iter_window_array_items().reduce.from_label_pair_map().keys()": "", "FrameHE.iter_window_array_items().reduce.from_label_pair_map().__iter__()": "", "FrameHE.iter_window_array_items().reduce.from_label_pair_map().items()": "", "FrameHE.iter_window_array_items().reduce.from_label_pair_map().values()": "", "FrameHE.iter_window_array_items().reduce.from_label_pair_map().to_frame()": "", "FrameHE.iter_window_items()": "Iterator of pairs of label, windowed values, where values are given as a Frame. Args: size: Elements per window, given as an integer greater than 0. axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. step: Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the size will result in non-overlapping windows. window_sized: if True, windows with fewer elements than size are skipped. window_func: Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window. window_valid: Function that, given an array window, returns True if the window is valid; invalid windows are skipped. label_shift: A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, label_shift can be set to one less than size. label_missing_skips: If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label. label_missing_raises: If True, a window that cannot derive a label will raise an exception. start_shift: A shift to determine the first element where window collection begins. size_increment: A value to be added to size with each window after the first, so as to, in combination with setting step to 0, permit iterating over expanding windows.", "FrameHE.iter_window_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "FrameHE.iter_window_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "FrameHE.iter_window_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "FrameHE.iter_window_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "FrameHE.iter_window_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.iter_window_items().reduce.from_map_func().keys()": "", "FrameHE.iter_window_items().reduce.from_map_func().__iter__()": "", "FrameHE.iter_window_items().reduce.from_map_func().items()": "", "FrameHE.iter_window_items().reduce.from_map_func().values()": "", "FrameHE.iter_window_items().reduce.from_map_func().to_frame()": "", "FrameHE.iter_window_items().reduce.from_label_map().keys()": "", "FrameHE.iter_window_items().reduce.from_label_map().__iter__()": "", "FrameHE.iter_window_items().reduce.from_label_map().items()": "", "FrameHE.iter_window_items().reduce.from_label_map().values()": "", "FrameHE.iter_window_items().reduce.from_label_map().to_frame()": "", "FrameHE.iter_window_items().reduce.from_label_pair_map().keys()": "", "FrameHE.iter_window_items().reduce.from_label_pair_map().__iter__()": "", "FrameHE.iter_window_items().reduce.from_label_pair_map().items()": "", "FrameHE.iter_window_items().reduce.from_label_pair_map().values()": "", "FrameHE.iter_window_items().reduce.from_label_pair_map().to_frame()": "", "FrameHE.__add__()": "", "FrameHE.__and__()": "", "FrameHE.__eq__()": "Return True if other is a Frame with the same labels, values, and name. Container class and underlying dtypes are not independently compared.", "FrameHE.__floordiv__()": "", "FrameHE.__ge__()": "", "FrameHE.__gt__()": "", "FrameHE.__le__()": "", "FrameHE.__lt__()": "", "FrameHE.__matmul__()": "", "FrameHE.__mod__()": "", "FrameHE.__mul__()": "", "FrameHE.__ne__()": "Return False if other is a Frame with the different labels, values, or name. Container class and underlying dtypes are not independently compared.", "FrameHE.__or__()": "", "FrameHE.__pow__()": "", "FrameHE.__radd__()": "", "FrameHE.__rfloordiv__()": "", "FrameHE.__rmatmul__()": "", "FrameHE.__rmul__()": "", "FrameHE.__rshift__()": "", "FrameHE.__rsub__()": "", "FrameHE.__rtruediv__()": "", "FrameHE.__sub__()": "", "FrameHE.__truediv__()": "", "FrameHE.__xor__()": "", "FrameHE.__abs__()": "", "FrameHE.__invert__()": "", "FrameHE.__neg__()": "", "FrameHE.__pos__()": "", "FrameHE.abs()": "", "FrameHE.via_values.apply()": "", "FrameHE.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "FrameHE.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "FrameHE.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "FrameHE.via_dt.year": "Return the year of each element.", "FrameHE.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "FrameHE.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "FrameHE.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "FrameHE.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "FrameHE.via_dt.hour": "Return the hour of each element, between 0 and 24.", "FrameHE.via_dt.minute": "Return the minute of each element, between 0 and 60.", "FrameHE.via_dt.second": "Return the second of each element, between 0 and 60.", "FrameHE.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "FrameHE.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "FrameHE.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "FrameHE.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "FrameHE.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "FrameHE.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "FrameHE.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "FrameHE.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "FrameHE.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "FrameHE.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "FrameHE.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "FrameHE.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "FrameHE.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "FrameHE.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "FrameHE.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "FrameHE.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "FrameHE.via_str.center()": "Return a container with its elements centered in a string of length width.", "FrameHE.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "FrameHE.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "FrameHE.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "FrameHE.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "FrameHE.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "FrameHE.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "FrameHE.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "FrameHE.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "FrameHE.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "FrameHE.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "FrameHE.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "FrameHE.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "FrameHE.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "FrameHE.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "FrameHE.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "FrameHE.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "FrameHE.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "FrameHE.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "FrameHE.via_str.len()": "Return the length of the string.", "FrameHE.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "FrameHE.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "FrameHE.via_str.partition()": "Partition each element around sep.", "FrameHE.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "FrameHE.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "FrameHE.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "FrameHE.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "FrameHE.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "FrameHE.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "FrameHE.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "FrameHE.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "FrameHE.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "FrameHE.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "FrameHE.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "FrameHE.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "FrameHE.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "FrameHE.via_str.zfill()": "Return the string left-filled with zeros.", "FrameHE.via_T.via_fill_value()": "Interface for using binary operators and methods with a pre-defined fill value.", "FrameHE.via_T.__add__()": "", "FrameHE.via_T.__sub__()": "", "FrameHE.via_T.__mul__()": "", "FrameHE.via_T.__truediv__()": "", "FrameHE.via_T.__floordiv__()": "", "FrameHE.via_T.__mod__()": "", "FrameHE.via_T.__pow__()": "", "FrameHE.via_T.__lshift__()": "", "FrameHE.via_T.__rshift__()": "", "FrameHE.via_T.__and__()": "", "FrameHE.via_T.__xor__()": "", "FrameHE.via_T.__or__()": "", "FrameHE.via_T.__lt__()": "", "FrameHE.via_T.__le__()": "", "FrameHE.via_T.__eq__()": "", "FrameHE.via_T.__ne__()": "", "FrameHE.via_T.__gt__()": "", "FrameHE.via_T.__ge__()": "", "FrameHE.via_T.__radd__()": "", "FrameHE.via_T.__rsub__()": "", "FrameHE.via_T.__rmul__()": "", "FrameHE.via_T.__rtruediv__()": "", "FrameHE.via_T.__rfloordiv__()": "", "FrameHE.via_fill_value().loc": "Label-based selection where labels not specified will define a new container containing those labels filled with the fill value.", "FrameHE.via_fill_value().__getitem__()": "Label-based selection where labels not specified will define a new container containing those labels filled with the fill value.", "FrameHE.via_fill_value().via_T": "Interface for using binary operators with one-dimensional sequences, where the opperand is applied column-wise.", "FrameHE.via_fill_value().__add__()": "", "FrameHE.via_fill_value().__sub__()": "", "FrameHE.via_fill_value().__mul__()": "", "FrameHE.via_fill_value().__truediv__()": "", "FrameHE.via_fill_value().__floordiv__()": "", "FrameHE.via_fill_value().__mod__()": "", "FrameHE.via_fill_value().__pow__()": "", "FrameHE.via_fill_value().__lshift__()": "", "FrameHE.via_fill_value().__rshift__()": "", "FrameHE.via_fill_value().__and__()": "", "FrameHE.via_fill_value().__xor__()": "", "FrameHE.via_fill_value().__or__()": "", "FrameHE.via_fill_value().__lt__()": "", "FrameHE.via_fill_value().__le__()": "", "FrameHE.via_fill_value().__eq__()": "", "FrameHE.via_fill_value().__ne__()": "", "FrameHE.via_fill_value().__gt__()": "", "FrameHE.via_fill_value().__ge__()": "", "FrameHE.via_fill_value().__radd__()": "", "FrameHE.via_fill_value().__rsub__()": "", "FrameHE.via_fill_value().__rmul__()": "", "FrameHE.via_fill_value().__rtruediv__()": "", "FrameHE.via_fill_value().__rfloordiv__()": "", "FrameHE.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "FrameHE.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "FrameHE.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "FrameHE.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "FrameHE.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "FrameHE.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "FrameHE.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "FrameHE.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "FrameHE.via_hashlib().md5()": "", "FrameHE.via_hashlib().sha256()": "", "FrameHE.via_hashlib().sha512()": "", "FrameHE.via_hashlib().sha3_256()": "", "FrameHE.via_hashlib().sha3_512()": "", "FrameHE.via_hashlib().shake_128()": "", "FrameHE.via_hashlib().shake_256()": "", "FrameHE.via_hashlib().blake2b()": "", "FrameHE.via_hashlib().blake2s()": "", "FrameHE.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "FrameHE.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "FrameHE.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "FrameHE.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "FrameHE.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "FrameHE.reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "FrameHE.reduce.from_map_func().keys()": "For each Frame, reduce by applying, for each column, a function that reduces to (0-dimensional) elements, where the column label and function are given as a mapping. Column labels are retained.", "FrameHE.reduce.from_map_func().__iter__()": "For each Frame, reduce by applying, for each column, a function that reduces to (0-dimensional) elements, where the column label and function are given as a mapping. Column labels are retained.", "FrameHE.reduce.from_map_func().items()": "For each Frame, reduce by applying, for each column, a function that reduces to (0-dimensional) elements, where the column label and function are given as a mapping. Column labels are retained.", "FrameHE.reduce.from_map_func().values()": "For each Frame, reduce by applying, for each column, a function that reduces to (0-dimensional) elements, where the column label and function are given as a mapping. Column labels are retained.", "FrameHE.reduce.from_map_func().to_frame()": "For each Frame, reduce by applying, for each column, a function that reduces to (0-dimensional) elements, where the column label and function are given as a mapping. Column labels are retained.", "FrameHE.reduce.from_label_map().keys()": "For Frame, reduce by applying a function to each column, where the column label and function are given as a mapping. Column labels are retained. Args: func_map: a mapping of column labels to functions.", "FrameHE.reduce.from_label_map().__iter__()": "For Frame, reduce by applying a function to each column, where the column label and function are given as a mapping. Column labels are retained. Args: func_map: a mapping of column labels to functions.", "FrameHE.reduce.from_label_map().items()": "For Frame, reduce by applying a function to each column, where the column label and function are given as a mapping. Column labels are retained. Args: func_map: a mapping of column labels to functions.", "FrameHE.reduce.from_label_map().values()": "For Frame, reduce by applying a function to each column, where the column label and function are given as a mapping. Column labels are retained. Args: func_map: a mapping of column labels to functions.", "FrameHE.reduce.from_label_map().to_frame()": "For Frame, reduce by applying a function to each column, where the column label and function are given as a mapping. Column labels are retained. Args: func_map: a mapping of column labels to functions.", "FrameHE.reduce.from_label_pair_map().keys()": "For Frame, reduce by applying a function to a column and assigning the result a new label. Functions are provided as values in a mapping, where the key is tuple of source label, destination label. Args: func_map: a mapping of pairs of source label, destination label, to a function.", "FrameHE.reduce.from_label_pair_map().__iter__()": "For Frame, reduce by applying a function to a column and assigning the result a new label. Functions are provided as values in a mapping, where the key is tuple of source label, destination label. Args: func_map: a mapping of pairs of source label, destination label, to a function.", "FrameHE.reduce.from_label_pair_map().items()": "For Frame, reduce by applying a function to a column and assigning the result a new label. Functions are provided as values in a mapping, where the key is tuple of source label, destination label. Args: func_map: a mapping of pairs of source label, destination label, to a function.", "FrameHE.reduce.from_label_pair_map().values()": "For Frame, reduce by applying a function to a column and assigning the result a new label. Functions are provided as values in a mapping, where the key is tuple of source label, destination label. Args: func_map: a mapping of pairs of source label, destination label, to a function.", "FrameHE.reduce.from_label_pair_map().to_frame()": "For Frame, reduce by applying a function to a column and assigning the result a new label. Functions are provided as values in a mapping, where the key is tuple of source label, destination label. Args: func_map: a mapping of pairs of source label, destination label, to a function.", "Bus.__init__()": "Default Bus constructor. {args}", "Bus.from_concat()": "Concatenate multiple Bus into a new Bus. All Bus will load all Frame into memory if any are deferred.", "Bus.from_dict()": "Bus construction from a mapping of labels and Frame. Args: mapping: a dictionary or similar mapping interface. Returns: Bus", "Bus.from_frames()": "Return a Bus from an iterable of Frame; labels will be drawn from Frame.name.", "Bus.from_items()": "Return a Bus from an iterable of pairs of label, Frame. Returns: Bus", "Bus.from_series()": "Create a Bus from a Series of Frame.", "Bus.from_sqlite()": "Given a file path to an SQLite Bus store, return a Bus instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig max_persist: When loading Frame from a Store, optionally define the maximum number of Frame to remain in the Bus, regardless of the size of the Bus. If more than max_persist number of Frame are loaded, least-recently loaded Frame will be replaced by FrameDeferred. A max_persist of 1, for example, permits reading one Frame at a time without ever holding in memory more than 1 Frame.", "Bus.from_xlsx()": "Given a file path to an XLSX Bus store, return a Bus instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig max_persist: When loading Frame from a Store, optionally define the maximum number of Frame to remain in the Bus, regardless of the size of the Bus. If more than max_persist number of Frame are loaded, least-recently loaded Frame will be replaced by FrameDeferred. A max_persist of 1, for example, permits reading one Frame at a time without ever holding in memory more than 1 Frame.", "Bus.from_zip_csv()": "Given a file path to zipped CSV Bus store, return a Bus instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig max_persist: When loading Frame from a Store, optionally define the maximum number of Frame to remain in the Bus, regardless of the size of the Bus. If more than max_persist number of Frame are loaded, least-recently loaded Frame will be replaced by FrameDeferred. A max_persist of 1, for example, permits reading one Frame at a time without ever holding in memory more than 1 Frame.", "Bus.from_zip_npy()": "Given a file path to zipped NPY Bus store, return a Bus instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig max_persist: When loading Frame from a Store, optionally define the maximum number of Frame to remain in the Bus, regardless of the size of the Bus. If more than max_persist number of Frame are loaded, least-recently loaded Frame will be replaced by FrameDeferred. A max_persist of 1, for example, permits reading one Frame at a time without ever holding in memory more than 1 Frame.", "Bus.from_zip_npz()": "Given a file path to zipped NPZ Bus store, return a Bus instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig max_persist: When loading Frame from a Store, optionally define the maximum number of Frame to remain in the Bus, regardless of the size of the Bus. If more than max_persist number of Frame are loaded, least-recently loaded Frame will be replaced by FrameDeferred. A max_persist of 1, for example, permits reading one Frame at a time without ever holding in memory more than 1 Frame.", "Bus.from_zip_parquet()": "Given a file path to zipped parquet Bus store, return a Bus instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig max_persist: When loading Frame from a Store, optionally define the maximum number of Frame to remain in the Bus, regardless of the size of the Bus. If more than max_persist number of Frame are loaded, least-recently loaded Frame will be replaced by FrameDeferred. A max_persist of 1, for example, permits reading one Frame at a time without ever holding in memory more than 1 Frame.", "Bus.from_zip_pickle()": "Given a file path to zipped pickle Bus store, return a Bus instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig max_persist: When loading Frame from a Store, optionally define the maximum number of Frame to remain in the Bus, regardless of the size of the Bus. If more than max_persist number of Frame are loaded, least-recently loaded Frame will be replaced by FrameDeferred. A max_persist of 1, for example, permits reading one Frame at a time without ever holding in memory more than 1 Frame.", "Bus.from_zip_tsv()": "Given a file path to zipped TSV Bus store, return a Bus instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig max_persist: When loading Frame from a Store, optionally define the maximum number of Frame to remain in the Bus, regardless of the size of the Bus. If more than max_persist number of Frame are loaded, least-recently loaded Frame will be replaced by FrameDeferred. A max_persist of 1, for example, permits reading one Frame at a time without ever holding in memory more than 1 Frame.", "Bus.to_series()": "Return a Series with the Frame contained in this Bus. If the Bus is associated with a Store, all Frame will be loaded into memory and the returned Bus will no longer be associated with the Store.", "Bus.to_sqlite()": "Write the complete Bus as an SQLite database file. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Bus.to_visidata()": "Open an interactive VisiData session.", "Bus.to_xlsx()": "Write the complete Bus as a XLSX workbook. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Bus.to_zip_csv()": "Write the complete Bus as a zipped archive of CSV files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Bus.to_zip_npy()": "Write the complete Bus as a zipped archive of NPY files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Bus.to_zip_npz()": "Write the complete Bus as a zipped archive of NPZ files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Bus.to_zip_parquet()": "Write the complete Bus as a zipped archive of parquet files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Bus.to_zip_pickle()": "Write the complete Bus as a zipped archive of pickles. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Bus.to_zip_tsv()": "Write the complete Bus as a zipped archive of TSV files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Bus.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "Bus.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "Bus.dtypes": "Returns a Frame of dtype per column for all loaded Frames.", "Bus.index": "The index instance assigned to this container. Returns: Index", "Bus.inventory": "Return a Frame indicating file_path, last-modified time, and size of underlying disk-based data stores if used for this Bus.", "Bus.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "Bus.mloc": "Returns a Series showing a tuple of memory locations within each loaded Frame.", "Bus.name": "A hashable label attached to this container. Returns: Hashable", "Bus.nbytes": "Total bytes of data currently loaded in the Bus.", "Bus.ndim": "Return the number of dimensions, which for a Bus is always 1. Returns: int", "Bus.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: Tuple[int]", "Bus.shapes": "A Series describing the shape of each loaded Frame. Unloaded Frame will have a shape of None. Returns: Series", "Bus.size": "Return the size of the underlying NumPy array. Returns: int", "Bus.status": "Return a Frame indicating loaded status, size, bytes, and shape of all loaded Frame.", "Bus.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "Bus.__len__()": "Length of values.", "Bus.equals()": "Return a bool from comparison to any other object. Note: this will attempt to load and compare all Frame managed by the Bus. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "Bus.head()": "Return a Bus consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Bus Returns: Bus", "Bus.persist[]": "Label-based selection.", "Bus.persist.iloc[]": "Integer-position based selection.", "Bus.persist.loc[]": "Label-based selection.", "Bus.persist()": "Persist all Frame.", "Bus.rehierarch()": "Return a new Bus with new a hierarchy based on the supplied depth_map.", "Bus.reindex()": "Return a new Bus with labels defined by the provided index. The size and ordering of the data is determined by the newly provided index, where data will continue to be aligned under labels found in both the new and the old index. Labels found only in the new index will be filled with fill_value. Args: index: An iterable of unique, hashable values, or another Index or IndexHierarchy, to be used as the labels of the index. columns: An iterable of unique, hashable values, or another Index or IndexHierarchy, to be used as the labels of the index. fill_value: A value to be used to fill space created by a new index that has values not found in the previous index. own_index: Flag the passed index as ownable by this Bus. Primarily used by internal clients.", "Bus.relabel()": "Return a new Bus with transformed labels on the index. The size and ordering of the data is never changed in a relabeling operation. The resulting index must be unique. Args: index: One of the following types, used to create new index labels with the same size as the previous index. (a) A mapping (as a dictionary or Series), used to lookup and transform the labels in the previous index. Labels not found in the mapping will be reused. (b) A function, returning a hashable, that is applied to each label in the previous index. (c) The IndexAutoFactory type, to apply auto-incremented integer labels. (d) An Index initializer, i.e., either an iterable of hashables or an Index instance.", "Bus.relabel_flat()": "Return a new Bus, where an IndexHierarchy (if defined) is replaced with a flat, one-dimension index of tuples.", "Bus.relabel_level_add()": "Return a new Bus, adding a new root level to an existing IndexHierarchy, or creating an IndexHierarchy if one is not yet defined. Args: level: A hashable value to be used as a new root level, extending or creating an IndexHierarchy", "Bus.relabel_level_drop()": "Return a new Bus, dropping one or more levels from a either the root or the leaves of an IndexHierarchy. The resulting index must be unique. Args: count: A positive integer drops that many outer-most (root) levels; a negative integer drops that many inner-most (leaf)levels.", "Bus.rename()": "Return a new Bus with an updated name attribute.", "Bus.roll()": "Return a Bus with values rotated forward and wrapped around the index (with a positive shift) or backward and wrapped around the index (with a negative shift). Args: shift: Positive or negative integer shift. include_index: Determine if the Index is shifted with the underlying data. Returns: Bus", "Bus.shift()": "Return a Bus with values shifted forward on the index (with a positive shift) or backward on the index (with a negative shift). Args: shift: Positive or negative integer shift. fill_value: Value to be used to fill data missing after the shift. Returns: Bus", "Bus.sort_index()": "Return a new Bus ordered by the sorted Index. Args: * ascendings: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by. Returns: Bus", "Bus.sort_values()": "Return a new Bus ordered by the sorted values. Note that as a Bus contains Frames, a key argument must be provided to extract a sortable value, and this key function will process a Series of Frame. Args: * ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by. Returns: Bus", "Bus.tail()": "Return a Bus consisting only of the bottom elements as specified by count. s Args: count: Number of elements to be returned from the bottom of the Bus Returns: Bus", "Bus.unpersist()": "Replace all loaded Frame with FrameDeferred.", "Bus.__contains__()": "Inclusion of value in index labels. Returns: bool", "Bus.__iter__()": "Iterator of index labels, same as Series.keys. Returns: Iterator[Hashasble]", "Bus.__reversed__()": "Returns a reverse iterator on the Bus index. Returns: Index", "Bus.get()": "Return the value found at the index key, else the default if the key is not found. Returns: Any", "Bus.items()": "Iterator of pairs of Bus label and contained Frame.", "Bus.keys()": "Iterator of index labels. Returns: Iterator[Hashable]", "Bus.values": "A 1D object array of all Frame contained in the Bus. The returned np.ndarray will have Frame; this will never return an array with FrameDeferred, but max_persist will be observed in reading from the Store.", "Bus.interface": "A Frame documenting the interface of this class.", "Bus.__repr__()": "", "Bus.__str__()": "Return str(self).", "Bus.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Bus.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Bus.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Bus.drop[]": "Label-based selection.", "Bus.drop.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "Bus.drop.loc[]": "", "Bus.[]": "Selector of values by label. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.", "Bus.iloc[]": "", "Bus.loc[]": "", "Bus.iter_element()": "Iterator of elements.", "Bus.iter_element().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Bus.iter_element().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Bus.iter_element().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Bus.iter_element().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Bus.iter_element().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Bus.iter_element().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Bus.iter_element().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Bus.iter_element().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Bus.iter_element().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Bus.iter_element().reduce.from_map_func().keys()": "", "Bus.iter_element().reduce.from_map_func().__iter__()": "", "Bus.iter_element().reduce.from_map_func().items()": "", "Bus.iter_element().reduce.from_map_func().values()": "", "Bus.iter_element().reduce.from_map_func().to_frame()": "", "Bus.iter_element().reduce.from_label_map().keys()": "", "Bus.iter_element().reduce.from_label_map().__iter__()": "", "Bus.iter_element().reduce.from_label_map().items()": "", "Bus.iter_element().reduce.from_label_map().values()": "", "Bus.iter_element().reduce.from_label_map().to_frame()": "", "Bus.iter_element().reduce.from_label_pair_map().keys()": "", "Bus.iter_element().reduce.from_label_pair_map().__iter__()": "", "Bus.iter_element().reduce.from_label_pair_map().items()": "", "Bus.iter_element().reduce.from_label_pair_map().values()": "", "Bus.iter_element().reduce.from_label_pair_map().to_frame()": "", "Bus.iter_element_items()": "Iterator of label, element pairs.", "Bus.iter_element_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Bus.iter_element_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Bus.iter_element_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Bus.iter_element_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Bus.iter_element_items().reduce.from_func().keys()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Bus.iter_element_items().reduce.from_func().__iter__()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Bus.iter_element_items().reduce.from_func().items()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Bus.iter_element_items().reduce.from_func().values()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Bus.iter_element_items().reduce.from_func().to_frame()": "For each Frame, and given a function func that returns either a Series or a Frame, call that function on each Frame.", "Bus.iter_element_items().reduce.from_map_func().keys()": "", "Bus.iter_element_items().reduce.from_map_func().__iter__()": "", "Bus.iter_element_items().reduce.from_map_func().items()": "", "Bus.iter_element_items().reduce.from_map_func().values()": "", "Bus.iter_element_items().reduce.from_map_func().to_frame()": "", "Bus.iter_element_items().reduce.from_label_map().keys()": "", "Bus.iter_element_items().reduce.from_label_map().__iter__()": "", "Bus.iter_element_items().reduce.from_label_map().items()": "", "Bus.iter_element_items().reduce.from_label_map().values()": "", "Bus.iter_element_items().reduce.from_label_map().to_frame()": "", "Bus.iter_element_items().reduce.from_label_pair_map().keys()": "", "Bus.iter_element_items().reduce.from_label_pair_map().__iter__()": "", "Bus.iter_element_items().reduce.from_label_pair_map().items()": "", "Bus.iter_element_items().reduce.from_label_pair_map().values()": "", "Bus.iter_element_items().reduce.from_label_pair_map().to_frame()": "", "Bus.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "Bus.via_hashlib().md5()": "", "Bus.via_hashlib().sha256()": "", "Bus.via_hashlib().sha512()": "", "Bus.via_hashlib().sha3_256()": "", "Bus.via_hashlib().sha3_512()": "", "Bus.via_hashlib().shake_128()": "", "Bus.via_hashlib().shake_256()": "", "Bus.via_hashlib().blake2b()": "", "Bus.via_hashlib().blake2s()": "", "Bus.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "Bus.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "Bus.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "Bus.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "Bus.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "Batch.__init__()": "Default constructor of a Batch. Args: name: A hashable object to label the container. config: A StoreConfig, or a mapping of label ot StoreConfig max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Batch.from_frames()": "Return a Batch from an iterable of Frame; labels will be drawn from Frame.name.", "Batch.from_sqlite()": "Given a file path to an SQLite Batch store, return a Batch instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Batch.from_xlsx()": "Given a file path to an XLSX Batch store, return a Batch instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Batch.from_zip_csv()": "Given a file path to zipped CSV Batch store, return a Batch instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Batch.from_zip_npy()": "Given a file path to zipped NPY Batch store, return a Batch instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Batch.from_zip_npz()": "Given a file path to zipped NPZ Batch store, return a Batch instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Batch.from_zip_parquet()": "Given a file path to zipped parquet Batch store, return a Batch instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Batch.from_zip_pickle()": "Given a file path to zipped pickle Batch store, return a Batch instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Batch.from_zip_tsv()": "Given a file path to zipped TSV Batch store, return a Batch instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Batch.to_bus()": "Realize the Batch as an Bus. Note that, as a Bus must have all labels (even if Frame are loaded lazily), this Batch will be exhausted.", "Batch.to_frame()": "Consolidate stored Frame into a new Frame using the stored labels as the index on the provided axis using Frame.from_concat. This assumes that that the contained Frame have been reduced to a single dimension along the provided axis.", "Batch.to_series()": "Consolidate stored values into a new Series using the stored labels as the index.", "Batch.to_sqlite()": "Write the complete Bus as an SQLite database file. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Batch.to_visidata()": "Open an interactive VisiData session.", "Batch.to_xlsx()": "Write the complete Bus as a XLSX workbook. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Batch.to_zip_csv()": "Write the complete Bus as a zipped archive of CSV files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Batch.to_zip_npy()": "Write the complete Bus as a zipped archive of NPY files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Batch.to_zip_npz()": "Write the complete Bus as a zipped archive of NPZ files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Batch.to_zip_parquet()": "Write the complete Bus as a zipped archive of parquet files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Batch.to_zip_pickle()": "Write the complete Bus as a zipped archive of pickles. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Batch.to_zip_tsv()": "Write the complete Bus as a zipped archive of TSV files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Batch.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "Batch.T": "Transpose. Return a Frame with index as columns and vice versa.", "Batch.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "Batch.name": "A hashable label attached to this container. Returns: Hashable", "Batch.shapes": "A Series describing the shape of each iterated Frame. Returns: tp.Tuple[int]", "Batch.via_container": "Return a new Batch with all values wrapped in either a Frame or Series.", "Batch.__array__()": "Support the __array__ interface, returning an array of values.", "Batch.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "Batch.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "Batch.__round__()": "Return a Batch with contained Frame rounded to the given decimals. Negative decimals round to the left of the decimal point. Args: decimals: number of decimals to round to.", "Batch.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Batch.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Batch.apply()": "Apply a function to each Frame contained in this Frame, where a function is given the Frame as an argument.", "Batch.apply_except()": "Apply a function to each Frame contained in this Frame, where a function is given the Frame as an argument. Exceptions raised that matching the except argument will be silenced.", "Batch.apply_items()": "Apply a function to each Frame contained in this Frame, where a function is given the pair of label, Frame as an argument.", "Batch.apply_items_except()": "Apply a function to each Frame contained in this Frame, where a function is given the pair of label, Frame as an argument. Exceptions raised that matching the except argument will be silenced.", "Batch.astype[]()": "Selector of columns by label. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.", "Batch.astype()": "Apply a single dtype to all columns.", "Batch.clip()": "Apply a clip operation to this Batch. Note that clip operations can be applied to object types, but cannot be applied to non-numerical objects (e.g., strings, None) Args: lower: value, Series, Frame upper: value, Series, Frame axis: required if lower or upper are given as a Series.", "Batch.corr()": "Compute a correlation matrix. Args: axis: if 0, each row represents a variable, with observations as columns; if 1, each column represents a variable, with observations as rows. Defaults to 1.", "Batch.count()": "Apply count on contained Frames.", "Batch.cov()": "Compute a covariance matrix. Args: axis: if 0, each row represents a variable, with observations as columns; if 1, each column represents a variable, with observations as rows. Defaults to 1. ddof: Delta degrees of freedom, defaults to 1.", "Batch.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Batch.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Batch.drop_duplicated()": "Return a Batch with contained Frame with duplicated rows (axis 0) or columns (axis 1) removed. All values in the row or column are compared to determine duplication. Args: axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. exclude_first: Boolean to select if the first duplicated value is excluded. exclude_last: Boolean to select if the last duplicated value is excluded.", "Batch.dropfalsy()": "Return a Batch with contained Frame after removing rows (axis 0) or columns (axis 1) where any or all values are NA (NaN or None). The condition is determined by a NumPy ufunc that process the Boolean array returned by isna(); the default is np.all. Args: axis: condition:", "Batch.dropna()": "Return a Batch with contained Frame after removing rows (axis 0) or columns (axis 1) where any or all values are NA (NaN or None). The condition is determined by a NumPy ufunc that process the Boolean array returned by isna(); the default is np.all. Args: axis: condition:", "Batch.duplicated()": "Return an axis-sized Boolean Series that shows True for all rows (axis 0) or columns (axis 1) duplicated. Args: axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. exclude_first: Boolean to select if the first duplicated value is excluded. exclude_last: Boolean to select if the last duplicated value is excluded.", "Batch.equals()": "", "Batch.fillfalsy()": "Return a new Batch with contained Frame after filling falsy values with the provided value.", "Batch.fillfalsy_backward()": "Return a new Batch with contained Frame after filling backward falsy values with the first observed value. Args: {limit} {axis}", "Batch.fillfalsy_forward()": "Return a new Batch with contained Frame after filling forward falsy values with the last observed value. Args: {limit} {axis}", "Batch.fillfalsy_leading()": "Return a new Batch with contained Frame after filling leading (and only leading) falsy values with the provided value. Args: {value} {axis}", "Batch.fillfalsy_trailing()": "Return a new Batch with contained Frame after filling trailing (and only trailing) falsy values with the provided value. Args: {value} {axis}", "Batch.fillna()": "Return a new Batch with contained Frame after filling null (NaN or None) with the provided value.", "Batch.fillna_backward()": "Return a new Batch with contained Frame after filling backward null (NaN or None) with the first observed value. Args: {limit} {axis}", "Batch.fillna_forward()": "Return a new Batch with contained Frame after filling forward null (NaN or None) with the last observed value. Args: {limit} {axis}", "Batch.fillna_leading()": "Return a new Batch with contained Frame after filling leading (and only leading) null (NaN or None) with the provided value. Args: {value} {axis}", "Batch.fillna_trailing()": "Return a new Batch with contained Frame after filling trailing (and only trailing) null (NaN or None) with the provided value. Args: {value} {axis}", "Batch.head()": "Return a Batch consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Batch", "Batch.iloc_max()": "Return the integer indices corresponding to the maximum values found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "Batch.iloc_min()": "Return the integer indices corresponding to the minimum values found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "Batch.isfalsy()": "Return a Batch with contained, same-indexed Frame indicating True which values are Falsy.", "Batch.isin()": "Return a new Batch with contained Frame as a same-sized Boolean Frame that shows if the same-positioned element is in the passed iterable.", "Batch.isna()": "Return a Batch with contained, same-indexed Frame indicating True which values are NaN or None.", "Batch.loc_max()": "Return the labels corresponding to the maximum values found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "Batch.loc_min()": "Return the labels corresponding to the minimum value found. Args: skipna: if True, NaN or None values will be ignored; if False, a found NaN will propagate. axis: Axis upon which to evaluate contiguous missing values, where 0 is vertically (between row values) and 1 is horizontally (between column values).", "Batch.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Batch.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Batch.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Batch.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Batch.notfalsy()": "Return a Batch with contained, same-indexed Frame indicating True which values are not Falsy.", "Batch.notna()": "Return a Batch with contained, same-indexed Frame indicating True which values are not NaN or None.", "Batch.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Batch.rank_dense()": "", "Batch.rank_max()": "", "Batch.rank_mean()": "", "Batch.rank_min()": "", "Batch.rank_ordinal()": "", "Batch.reindex()": "", "Batch.relabel()": "", "Batch.relabel_flat()": "", "Batch.relabel_level_add()": "", "Batch.relabel_level_drop()": "", "Batch.relabel_shift_in()": "", "Batch.rename()": "Return a new Batch with an updated name attribute.", "Batch.roll()": "Roll columns and/or rows by positive or negative integer counts, where columns and/or rows roll around the axis. Args: include_index: Determine if index is included in index-wise rotation. include_columns: Determine if column index is included in index-wise rotation.", "Batch.sample()": "Apply sample on contained Frames. Args: Number of labels to select from the index. Number of labels to select from the columns. Initial state of random selection.", "Batch.shift()": "Shift columns and/or rows by positive or negative integer counts, where columns and/or rows fall of the axis and introduce missing values, filled by fill_value.", "Batch.sort_columns()": "Return a new Batch with contained Frame ordered by the sorted columns.", "Batch.sort_index()": "Return a new Batch with contained :obj;Frame ordered by the sorted index.", "Batch.sort_values()": "Return a new Batch with contained Frame ordered by the sorted values, where values are given by single column or iterable of columns. Args: label: a label or iterable of keys.", "Batch.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Batch.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Batch.tail()": "Return a Batch consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Batch", "Batch.transpose()": "Transpose. Return a Frame with index as columns and vice versa.", "Batch.unique()": "Return a NumPy array of unqiue values. If the axis argument is provied, uniqueness is determined by columns or row.", "Batch.unset_index()": "", "Batch.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Batch.__iter__()": "Iterator of Frame labels, same as Batch.keys.", "Batch.items()": "Iterator of labels, Frame.", "Batch.keys()": "Iterator of Frame labels.", "Batch.values": "Return an iterator of values (Frame or Series) stored in this Batch.", "Batch.interface": "A Frame documenting the interface of this class.", "Batch.__repr__()": "Provide a display of the Batch that does not exhaust the generator.", "Batch.__str__()": "Return str(self).", "Batch.display()": "Provide a Series-style display of the Batch. Note that if the held iterator is a generator, this display will exhaust the generator.", "Batch.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Batch.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Batch.bloc[]": "", "Batch.drop[]": "Label-based selection.", "Batch.drop.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "Batch.drop.loc[]": "", "Batch.[]": "", "Batch.iloc[]": "", "Batch.loc[]": "", "Batch.__add__()": "", "Batch.__and__()": "", "Batch.__eq__()": "", "Batch.__floordiv__()": "", "Batch.__ge__()": "", "Batch.__gt__()": "", "Batch.__le__()": "", "Batch.__lt__()": "", "Batch.__matmul__()": "", "Batch.__mod__()": "", "Batch.__mul__()": "", "Batch.__ne__()": "", "Batch.__or__()": "", "Batch.__pow__()": "", "Batch.__radd__()": "", "Batch.__rfloordiv__()": "", "Batch.__rmatmul__()": "", "Batch.__rmul__()": "", "Batch.__rshift__()": "", "Batch.__rsub__()": "", "Batch.__rtruediv__()": "", "Batch.__sub__()": "", "Batch.__truediv__()": "", "Batch.__xor__()": "", "Batch.__abs__()": "", "Batch.__invert__()": "", "Batch.__neg__()": "", "Batch.__pos__()": "", "Batch.abs()": "", "Batch.via_values.apply()": "Interface for using binary operators and methods with a pre-defined fill value.", "Batch.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers, returning NumPy arrays.", "Batch.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "Batch.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "Batch.via_dt.year": "Return the year of each element.", "Batch.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "Batch.via_dt.year_quarter": "Return the year and quarter of each element as string formatted YYYY-QQ.", "Batch.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "Batch.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "Batch.via_dt.hour": "Return the hour of each element, between 0 and 24.", "Batch.via_dt.minute": "Return the minute of each element, between 0 and 60.", "Batch.via_dt.second": "Return the second of each element, between 0 and 60.", "Batch.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "Batch.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "Batch.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "Batch.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "Batch.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "Batch.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "Batch.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "Batch.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "Batch.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "Batch.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "Batch.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "Batch.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "Batch.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "Batch.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "Batch.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "Batch.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "Batch.via_str.center()": "Return a container with its elements centered in a string of length width.", "Batch.via_str.contains()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "Batch.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "Batch.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "Batch.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "Batch.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "Batch.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "Batch.via_str.format()": "For each element, return a string resulting from calling the format argument's format method with the values in this container.", "Batch.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "Batch.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "Batch.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "Batch.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "Batch.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "Batch.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "Batch.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "Batch.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "Batch.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "Batch.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "Batch.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "Batch.via_str.len()": "Return the length of the string.", "Batch.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "Batch.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "Batch.via_str.partition()": "Partition each element around sep.", "Batch.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "Batch.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "Batch.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "Batch.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "Batch.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "Batch.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "Batch.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "Batch.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "Batch.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "Batch.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "Batch.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "Batch.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "Batch.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "Batch.via_str.zfill()": "Return the string left-filled with zeros.", "Batch.via_T.via_fill_value()": "Interface for using binary operators and methods with a pre-defined fill value.", "Batch.via_T.__add__()": "", "Batch.via_T.__sub__()": "", "Batch.via_T.__mul__()": "", "Batch.via_T.__truediv__()": "", "Batch.via_T.__floordiv__()": "", "Batch.via_T.__mod__()": "", "Batch.via_T.__pow__()": "", "Batch.via_T.__lshift__()": "", "Batch.via_T.__rshift__()": "", "Batch.via_T.__and__()": "", "Batch.via_T.__xor__()": "", "Batch.via_T.__or__()": "", "Batch.via_T.__lt__()": "", "Batch.via_T.__le__()": "", "Batch.via_T.__eq__()": "", "Batch.via_T.__ne__()": "", "Batch.via_T.__gt__()": "", "Batch.via_T.__ge__()": "", "Batch.via_T.__radd__()": "", "Batch.via_T.__rsub__()": "", "Batch.via_T.__rmul__()": "", "Batch.via_T.__rtruediv__()": "", "Batch.via_T.__rfloordiv__()": "", "Batch.via_fill_value().loc": "Label-based selection where labels not specified will define a new container containing those labels filled with the fill value.", "Batch.via_fill_value().__getitem__()": "Label-based selection where labels not specified will define a new container containing those labels filled with the fill value.", "Batch.via_fill_value().via_T": "Interface for using binary operators with one-dimensional sequences, where the opperand is applied column-wise.", "Batch.via_fill_value().__add__()": "", "Batch.via_fill_value().__sub__()": "", "Batch.via_fill_value().__mul__()": "", "Batch.via_fill_value().__truediv__()": "", "Batch.via_fill_value().__floordiv__()": "", "Batch.via_fill_value().__mod__()": "", "Batch.via_fill_value().__pow__()": "", "Batch.via_fill_value().__lshift__()": "", "Batch.via_fill_value().__rshift__()": "", "Batch.via_fill_value().__and__()": "", "Batch.via_fill_value().__xor__()": "", "Batch.via_fill_value().__or__()": "", "Batch.via_fill_value().__lt__()": "", "Batch.via_fill_value().__le__()": "", "Batch.via_fill_value().__eq__()": "", "Batch.via_fill_value().__ne__()": "", "Batch.via_fill_value().__gt__()": "", "Batch.via_fill_value().__ge__()": "", "Batch.via_fill_value().__radd__()": "", "Batch.via_fill_value().__rsub__()": "", "Batch.via_fill_value().__rmul__()": "", "Batch.via_fill_value().__rtruediv__()": "", "Batch.via_fill_value().__rfloordiv__()": "", "Batch.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "Batch.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "Batch.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "Batch.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "Batch.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "Batch.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "Batch.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "Batch.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "Batch.via_hashlib().md5()": "", "Batch.via_hashlib().sha256()": "", "Batch.via_hashlib().sha512()": "", "Batch.via_hashlib().sha3_256()": "", "Batch.via_hashlib().sha3_512()": "", "Batch.via_hashlib().shake_128()": "", "Batch.via_hashlib().shake_256()": "", "Batch.via_hashlib().blake2b()": "", "Batch.via_hashlib().blake2s()": "", "Batch.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "Batch.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "Batch.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "Batch.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "Batch.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "Batch.reduce.from_func()": "", "Batch.reduce.from_map_func()": "", "Batch.reduce.from_label_map()": "", "Batch.reduce.from_label_pair_map()": "", "Yarn.__init__()": "Args: series: An iterable (or Series) of Bus. The length of this container may not be the same as index, if provided. index: Optionally provide an index for the Frame contained in all Bus. index_constructor: deepcopy_from_bus: hierarchy: Optionally provide a depth-two IndexHierarchy constructed from Bus integer positions on the outer level, and contained Frame labels on the inner level. indexer: For each Frame referenced by the index, provide the location within the internal IndexHierarchy. name: own_index:", "Yarn.from_buses()": "Return a Yarn from an iterable of Bus; labels will be drawn from Bus.name.", "Yarn.from_concat()": "Concatenate multiple Yarn into a new Yarn. Loaded status of Frame within each Bus will not be altered. Args: containers: index: Optionally provide new labels for the result of the concatenation. name: deepcopy_from_bus:", "Yarn.to_series()": "Return a Series with the Frame contained in all contained Bus.", "Yarn.to_sqlite()": "Write the complete Bus as an SQLite database file. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Yarn.to_visidata()": "Open an interactive VisiData session.", "Yarn.to_xlsx()": "Write the complete Bus as a XLSX workbook. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Yarn.to_zip_csv()": "Write the complete Bus as a zipped archive of CSV files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Yarn.to_zip_npy()": "Write the complete Bus as a zipped archive of NPY files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Yarn.to_zip_npz()": "Write the complete Bus as a zipped archive of NPZ files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Yarn.to_zip_parquet()": "Write the complete Bus as a zipped archive of parquet files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Yarn.to_zip_pickle()": "Write the complete Bus as a zipped archive of pickles. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Yarn.to_zip_tsv()": "Write the complete Bus as a zipped archive of TSV files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Yarn.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "Yarn.dtype": "Return the dtype of the realized NumPy array. Returns: numpy.dtype", "Yarn.dtypes": "Returns a Frame of dtypes for all loaded Frames.", "Yarn.index": "The index instance assigned to this container. Returns: Index", "Yarn.inventory": "Return a Frame indicating file_path, last-modified time, and size of underlying disk-based data stores if used for this Yarn.", "Yarn.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "Yarn.mloc": "Returns a Series showing a tuple of memory locations within each loaded Frame.", "Yarn.name": "A hashable label attached to this container. Returns: Hashable", "Yarn.nbytes": "Total bytes of data currently loaded in Frame contained in this Yarn.", "Yarn.ndim": "Return the number of dimensions, which for a Yarn is always 1. Returns: int", "Yarn.shape": "Return a tuple describing the shape of the realized NumPy array. Returns: Tuple[int]", "Yarn.shapes": "A Series describing the shape of each loaded Frame. Unloaded Frame will have a shape of None. Returns: tp.Series", "Yarn.size": "Return the size. Returns: int", "Yarn.status": "Return a Frame indicating loaded status, size, bytes, and shape of all loaded Frame in Bus contined in this Yarn.", "Yarn.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "Yarn.__len__()": "Length of values.", "Yarn.equals()": "Return a bool from comparison to any other object. Note: this will attempt to load and compare all Frame managed by the Bus. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "Yarn.head()": "Return a Yarn consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Yarn Returns: Yarn", "Yarn.persist[]": "Label-based selection.", "Yarn.persist.iloc[]": "Integer-position based selection.", "Yarn.persist.loc[]": "Label-based selection.", "Yarn.persist()": "Persist all Frame.", "Yarn.rehierarch()": "Return a new Series with new a hierarchy based on the supplied depth_map.", "Yarn.reindex()": "Return a new Bus with labels defined by the provided index. The size and ordering of the data is determined by the newly provided index, where data will continue to be aligned under labels found in both the new and the old index. Labels found only in the new index will be filled with fill_value. Args: index: An iterable of unique, hashable values, or another Index or IndexHierarchy, to be used as the labels of the index. columns: An iterable of unique, hashable values, or another Index or IndexHierarchy, to be used as the labels of the index. fill_value: A value to be used to fill space created by a new index that has values not found in the previous index. own_index: Flag the passed index as ownable by this Bus. Primarily used by internal clients.", "Yarn.relabel()": "Return a new Yarn with transformed labels on the index. The size and ordering of the data is never changed in a relabeling operation. The resulting index must be unique. Args: index: One of the following types, used to create new index labels with the same size as the previous index. (a) A mapping (as a dictionary or Series), used to lookup and transform the labels in the previous index. Labels not found in the mapping will be reused. (b) A function, returning a hashable, that is applied to each label in the previous index. (c) The IndexAutoFactory type, to apply auto-incremented integer labels. (d) An Index initializer, i.e., either an iterable of hashables or an Index instance.", "Yarn.relabel_flat()": "Return a new Yarn, where an IndexHierarchy (if defined) is replaced with a flat, one-dimension index of tuples.", "Yarn.relabel_level_add()": "Return a new Yarn, adding a new root level to an existing IndexHierarchy, or creating an IndexHierarchy if one is not yet defined. Args: level: A hashable value to be used as a new root level, extending or creating an IndexHierarchy", "Yarn.relabel_level_drop()": "Return a new Yarn, dropping one or more levels from a either the root or the leaves of an IndexHierarchy. The resulting index must be unique. Args: count: A positive integer drops that many outer-most (root) levels; a negative integer drops that many inner-most (leaf)levels.", "Yarn.rename()": "Return a new Yarn with an updated name attribute. Args: name", "Yarn.roll()": "Return a Yarn with values rotated forward and wrapped around the index (with a positive shift) or backward and wrapped around the index (with a negative shift). Args: shift: Positive or negative integer shift. include_index: Determine if the Index is shifted with the underlying data. Returns: Yarn", "Yarn.shift()": "Return a Yarn with values shifted forward on the index (with a positive shift) or backward on the index (with a negative shift). Args: shift: Positive or negative integer shift. fill_value: Value to be used to fill data missing after the shift. Returns: Yarn", "Yarn.sort_index()": "Return a new Yarn ordered by the sorted Index. Args: * ascendings: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by. Returns: Yarn", "Yarn.sort_values()": "Return a new Yarn ordered by the sorted values. Note that as a Yarn contains Frames, a key argument must be provided to extract a sortable value, and this key function will process a Series of Frame. Args: * ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by. Returns: Yarn", "Yarn.tail()": "Return a Yarn consisting only of the bottom elements as specified by count. s Args: count: Number of elements to be returned from the bottom of the Yarn Returns: Yarn", "Yarn.unpersist()": "For the Bus contained in this object, replace all loaded Frame with FrameDeferred.", "Yarn.__contains__()": "Inclusion of value in index labels. Returns: bool", "Yarn.__iter__()": "Iterator of index labels, same as Series.keys. Returns: Iterator[Hashasble]", "Yarn.__reversed__()": "Returns a reverse iterator on the Yarn index. Returns: Index", "Yarn.get()": "Return the value found at the index key, else the default if the key is not found. Returns: Any", "Yarn.items()": "Iterator of pairs of Yarn label and contained Frame.", "Yarn.keys()": "Iterator of index labels. Returns: Iterator[Hashable]", "Yarn.values": "A 1D object array of all Frame contained in all contained Bus.", "Yarn.interface": "A Frame documenting the interface of this class.", "Yarn.__repr__()": "", "Yarn.__str__()": "Return str(self).", "Yarn.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Yarn.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Yarn.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Yarn.drop[]": "Label-based selection.", "Yarn.drop.iloc[]": "Interface for iloc selection that does not reduce dimensionality.", "Yarn.drop.loc[]": "", "Yarn.[]": "Selector of values by label. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.", "Yarn.iloc[]": "", "Yarn.loc[]": "", "Yarn.iter_element()": "Iterator of elements.", "Yarn.iter_element().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Yarn.iter_element().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Yarn.iter_element().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Yarn.iter_element().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Yarn.iter_element_items()": "Iterator of label, element pairs.", "Yarn.iter_element_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Yarn.iter_element_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Yarn.iter_element_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Yarn.iter_element_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Yarn.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "Yarn.via_hashlib().md5()": "", "Yarn.via_hashlib().sha256()": "", "Yarn.via_hashlib().sha512()": "", "Yarn.via_hashlib().sha3_256()": "", "Yarn.via_hashlib().sha3_512()": "", "Yarn.via_hashlib().shake_128()": "", "Yarn.via_hashlib().shake_256()": "", "Yarn.via_hashlib().blake2b()": "", "Yarn.via_hashlib().blake2s()": "", "Yarn.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "Yarn.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "Yarn.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "Yarn.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "Yarn.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "Quilt.__init__()": "Args: bus: Bus of Frame to be used for virtual concatenation. axis: Integer specifying axis of virtual concatenation, where 0 is vertically (stacking rows) and 1 is horizontally (extending columns). retain_labels: Boolean to determine if, along the axis of virtual concatentation, if component Frame labels should be used to form the outer depth of an IndexHierarchy. This is required to be True if component Frame labels are not globally unique along the axis of concatenation. deepcopy_from_bus: Boolean to determine if containers are deep-copied from the contained Bus during extraction. Set to True to avoid holding references from the Bus.", "Quilt.from_frame()": "Given a Frame, create a Quilt by partitioning it along the specified axis in units of chunksize, where axis 0 partitions vertically (retaining aligned columns) and 1 partions horizontally (retaining aligned index). Args: label_extractor: Function that, given the partitioned index component along the specified axis, returns a string label for that chunk.", "Quilt.from_frames()": "Return a Quilt from an iterable of Frame; labels will be drawn from Frame.name.", "Quilt.from_items()": "Given an iterable of pairs of label, Frame, create a Quilt.", "Quilt.from_sqlite()": "Given a file path to an SQLite Quilt store, return a Quilt instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig axis: Integer specifying axis of virtual concatenation, where 0 is vertically (stacking rows) and 1 is horizontally (extending columns). retain_labels: Boolean to determine if, along the axis of virtual concatentation, if component Frame labels should be used to form the outer depth of an IndexHierarchy. This is required to be True if component Frame labels are not globally unique along the axis of concatenation. deepcopy_from_bus: Boolean to determine if containers are deep-copied from the contained Bus during extraction. Set to True to avoid holding references from the Bus. max_persist: When loading Frame from a Store, optionally define the maximum number of Frame to remain in the Bus, regardless of the size of the Bus. If more than max_persist number of Frame are loaded, least-recently loaded Frame will be replaced by FrameDeferred. A max_persist of 1, for example, permits reading one Frame at a time without ever holding in memory more than 1 Frame.", "Quilt.from_xlsx()": "Given a file path to an XLSX Quilt store, return a Quilt instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig axis: Integer specifying axis of virtual concatenation, where 0 is vertically (stacking rows) and 1 is horizontally (extending columns). retain_labels: Boolean to determine if, along the axis of virtual concatentation, if component Frame labels should be used to form the outer depth of an IndexHierarchy. This is required to be True if component Frame labels are not globally unique along the axis of concatenation. deepcopy_from_bus: Boolean to determine if containers are deep-copied from the contained Bus during extraction. Set to True to avoid holding references from the Bus. max_persist: When loading Frame from a Store, optionally define the maximum number of Frame to remain in the Bus, regardless of the size of the Bus. If more than max_persist number of Frame are loaded, least-recently loaded Frame will be replaced by FrameDeferred. A max_persist of 1, for example, permits reading one Frame at a time without ever holding in memory more than 1 Frame.", "Quilt.from_zip_csv()": "Given a file path to zipped CSV Quilt store, return a Quilt instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig axis: Integer specifying axis of virtual concatenation, where 0 is vertically (stacking rows) and 1 is horizontally (extending columns). retain_labels: Boolean to determine if, along the axis of virtual concatentation, if component Frame labels should be used to form the outer depth of an IndexHierarchy. This is required to be True if component Frame labels are not globally unique along the axis of concatenation. deepcopy_from_bus: Boolean to determine if containers are deep-copied from the contained Bus during extraction. Set to True to avoid holding references from the Bus. max_persist: When loading Frame from a Store, optionally define the maximum number of Frame to remain in the Bus, regardless of the size of the Bus. If more than max_persist number of Frame are loaded, least-recently loaded Frame will be replaced by FrameDeferred. A max_persist of 1, for example, permits reading one Frame at a time without ever holding in memory more than 1 Frame.", "Quilt.from_zip_npy()": "Given a file path to zipped NPY Quilt store, return a Quilt instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig axis: Integer specifying axis of virtual concatenation, where 0 is vertically (stacking rows) and 1 is horizontally (extending columns). retain_labels: Boolean to determine if, along the axis of virtual concatentation, if component Frame labels should be used to form the outer depth of an IndexHierarchy. This is required to be True if component Frame labels are not globally unique along the axis of concatenation. deepcopy_from_bus: Boolean to determine if containers are deep-copied from the contained Bus during extraction. Set to True to avoid holding references from the Bus. max_persist: When loading Frame from a Store, optionally define the maximum number of Frame to remain in the Bus, regardless of the size of the Bus. If more than max_persist number of Frame are loaded, least-recently loaded Frame will be replaced by FrameDeferred. A max_persist of 1, for example, permits reading one Frame at a time without ever holding in memory more than 1 Frame.", "Quilt.from_zip_npz()": "Given a file path to zipped NPZ Quilt store, return a Quilt instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig axis: Integer specifying axis of virtual concatenation, where 0 is vertically (stacking rows) and 1 is horizontally (extending columns). retain_labels: Boolean to determine if, along the axis of virtual concatentation, if component Frame labels should be used to form the outer depth of an IndexHierarchy. This is required to be True if component Frame labels are not globally unique along the axis of concatenation. deepcopy_from_bus: Boolean to determine if containers are deep-copied from the contained Bus during extraction. Set to True to avoid holding references from the Bus. max_persist: When loading Frame from a Store, optionally define the maximum number of Frame to remain in the Bus, regardless of the size of the Bus. If more than max_persist number of Frame are loaded, least-recently loaded Frame will be replaced by FrameDeferred. A max_persist of 1, for example, permits reading one Frame at a time without ever holding in memory more than 1 Frame.", "Quilt.from_zip_parquet()": "Given a file path to zipped parquet Quilt store, return a Quilt instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig axis: Integer specifying axis of virtual concatenation, where 0 is vertically (stacking rows) and 1 is horizontally (extending columns). retain_labels: Boolean to determine if, along the axis of virtual concatentation, if component Frame labels should be used to form the outer depth of an IndexHierarchy. This is required to be True if component Frame labels are not globally unique along the axis of concatenation. deepcopy_from_bus: Boolean to determine if containers are deep-copied from the contained Bus during extraction. Set to True to avoid holding references from the Bus. max_persist: When loading Frame from a Store, optionally define the maximum number of Frame to remain in the Bus, regardless of the size of the Bus. If more than max_persist number of Frame are loaded, least-recently loaded Frame will be replaced by FrameDeferred. A max_persist of 1, for example, permits reading one Frame at a time without ever holding in memory more than 1 Frame.", "Quilt.from_zip_pickle()": "Given a file path to zipped pickle Quilt store, return a Quilt instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig axis: Integer specifying axis of virtual concatenation, where 0 is vertically (stacking rows) and 1 is horizontally (extending columns). retain_labels: Boolean to determine if, along the axis of virtual concatentation, if component Frame labels should be used to form the outer depth of an IndexHierarchy. This is required to be True if component Frame labels are not globally unique along the axis of concatenation. deepcopy_from_bus: Boolean to determine if containers are deep-copied from the contained Bus during extraction. Set to True to avoid holding references from the Bus. max_persist: When loading Frame from a Store, optionally define the maximum number of Frame to remain in the Bus, regardless of the size of the Bus. If more than max_persist number of Frame are loaded, least-recently loaded Frame will be replaced by FrameDeferred. A max_persist of 1, for example, permits reading one Frame at a time without ever holding in memory more than 1 Frame.", "Quilt.from_zip_tsv()": "Given a file path to zipped TSV Quilt store, return a Quilt instance. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig axis: Integer specifying axis of virtual concatenation, where 0 is vertically (stacking rows) and 1 is horizontally (extending columns). retain_labels: Boolean to determine if, along the axis of virtual concatentation, if component Frame labels should be used to form the outer depth of an IndexHierarchy. This is required to be True if component Frame labels are not globally unique along the axis of concatenation. deepcopy_from_bus: Boolean to determine if containers are deep-copied from the contained Bus during extraction. Set to True to avoid holding references from the Bus. max_persist: When loading Frame from a Store, optionally define the maximum number of Frame to remain in the Bus, regardless of the size of the Bus. If more than max_persist number of Frame are loaded, least-recently loaded Frame will be replaced by FrameDeferred. A max_persist of 1, for example, permits reading one Frame at a time without ever holding in memory more than 1 Frame.", "Quilt.to_frame()": "Return a consolidated Frame.", "Quilt.to_sqlite()": "Write the complete Bus as an SQLite database file. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Quilt.to_visidata()": "Open an interactive VisiData session.", "Quilt.to_xlsx()": "Write the complete Bus as a XLSX workbook. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Quilt.to_zip_csv()": "Write the complete Bus as a zipped archive of CSV files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Quilt.to_zip_npy()": "Write the complete Bus as a zipped archive of NPY files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Quilt.to_zip_npz()": "Write the complete Bus as a zipped archive of NPZ files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Quilt.to_zip_parquet()": "Write the complete Bus as a zipped archive of parquet files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Quilt.to_zip_pickle()": "Write the complete Bus as a zipped archive of pickles. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Quilt.to_zip_tsv()": "Write the complete Bus as a zipped archive of TSV files. Args: fp: A string file path or Path instance. config: A StoreConfig, or a mapping of label ot StoreConfig compression: Provide a zip compression setting using values from the Python zipfile module; zipfile.ZIP_DEFLATED is standard zlib compression; zipfile.ZIP_STORED disables compression and may give better performance at the cost of larger file sizes.", "Quilt.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "Quilt.bus": "The Bus instance assigned to this Quilt.", "Quilt.columns": "The IndexBase instance assigned for column labels.", "Quilt.index": "The IndexBase instance assigned for row labels.", "Quilt.inventory": "Return a Frame indicating file_path, last-modified time, and size of underlying disk-based data stores if used for this Quilt.", "Quilt.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "Quilt.name": "A hashable label attached to this container. Returns: Hashable", "Quilt.nbytes": "Return the total bytes of the underlying NumPy arrays. Returns: int", "Quilt.ndim": "Return the number of dimensions, which for a Frame is always 2. Returns: int", "Quilt.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "Quilt.size": "Return the size of the underlying NumPy array. Returns: int", "Quilt.status": "Return a Frame indicating loaded status, size, bytes, and shape of all loaded Frame in the contained Quilt.", "Quilt.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "Quilt.equals()": "Return a bool from comparison to any other object. Note: this will attempt to load and compare all Frame managed by the Bus stored within this Quilt. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "Quilt.head()": "Return a Quilt consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Quilt", "Quilt.rename()": "Return a new Quilt with an updated name attribute. Args: name", "Quilt.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of labels to select from the index. Number of labels to select from the columns. Initial state of random selection.", "Quilt.tail()": "Return a Quilt consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Quilt", "Quilt.unpersist()": "For the Bus or Yarn contained in this object, replace all loaded Frame with FrameDeferred.", "Quilt.__contains__()": "Inclusion of value in column labels.", "Quilt.__iter__()": "Iterator of column labels, same as Frame.keys.", "Quilt.get()": "Return the value found at the columns key, else the default if the key is not found. This method is implemented to complete the dictionary-like interface.", "Quilt.items()": "Iterator of pairs of column label and corresponding column Series.", "Quilt.keys()": "Iterator of column labels.", "Quilt.values": "A 2D NumPy array of all values in the Quilt. As this is a single array, heterogenous columnar types might be coerced to a compatible type.", "Quilt.interface": "A Frame documenting the interface of this class.", "Quilt.__repr__()": "", "Quilt.__str__()": "Return str(self).", "Quilt.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Quilt.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Quilt.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Quilt.[]": "Selector of columns by label. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.", "Quilt.iloc[]": "", "Quilt.loc[]": "", "Quilt.iter_array()": "Iterator of np.array, where arrays are drawn from columns (axis=0) or rows (axis=1)", "Quilt.iter_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Quilt.iter_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Quilt.iter_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Quilt.iter_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Quilt.iter_array_items()": "Iterator of pairs of label, np.array, where arrays are drawn from columns (axis=0) or rows (axis=1)", "Quilt.iter_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Quilt.iter_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Quilt.iter_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Quilt.iter_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Quilt.iter_series()": "Iterator of Series, where Series are drawn from columns (axis=0) or rows (axis=1)", "Quilt.iter_series().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Quilt.iter_series().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Quilt.iter_series().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Quilt.iter_series().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Quilt.iter_series_items()": "Iterator of pairs of label, Series, where Series are drawn from columns (axis=0) or rows (axis=1)", "Quilt.iter_series_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Quilt.iter_series_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Quilt.iter_series_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Quilt.iter_series_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Quilt.iter_tuple()": "Iterator of NamedTuple, where tuples are drawn from columns (axis=0) or rows (axis=1). An optional constructor callable can be used to provide a NamedTuple class (or any other constructor called with a single iterable) to be used to create each yielded axis value.", "Quilt.iter_tuple().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Quilt.iter_tuple().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Quilt.iter_tuple().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Quilt.iter_tuple().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Quilt.iter_tuple().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Quilt.iter_tuple().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "Quilt.iter_tuple().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "Quilt.iter_tuple().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Quilt.iter_tuple().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "Quilt.iter_tuple().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "Quilt.iter_tuple().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Quilt.iter_tuple().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "Quilt.iter_tuple().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "Quilt.iter_tuple_items()": "Iterator of pairs of label, NamedTuple, where tuples are drawn from columns (axis=0) or rows (axis=1)", "Quilt.iter_tuple_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Quilt.iter_tuple_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Quilt.iter_tuple_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Quilt.iter_tuple_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Quilt.iter_tuple_items().map_all()": "Apply a mapping; for values not in the mapping, an Exception is raised. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Quilt.iter_tuple_items().map_all_iter()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "Quilt.iter_tuple_items().map_all_iter_items()": "Apply a mapping; for values not in the mapping, an Exception is raised. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "Quilt.iter_tuple_items().map_any()": "Apply a mapping; for values not in the mapping, the value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Quilt.iter_tuple_items().map_any_iter()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series.", "Quilt.iter_tuple_items().map_any_iter_items()": "Apply a mapping; for values not in the mapping, the value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series.", "Quilt.iter_tuple_items().map_fill()": "Apply a mapping; for values not in the mapping, the fill_value is returned. Returns a new container. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Quilt.iter_tuple_items().map_fill_iter()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting values. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "Quilt.iter_tuple_items().map_fill_iter_items()": "Apply a mapping; for values not in the mapping, the fill_value is returned. A generator of resulting key, value pairs. Args: mapping: A mapping type, such as a dictionary or Series. fill_value: Value to be returned if the values is not a key in the mapping.", "Quilt.iter_window()": "Iterator of windowed values, where values are given as a Frame. Args: size: Elements per window, given as an integer greater than 0. axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. step: Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the size will result in non-overlapping windows. window_sized: if True, windows with fewer elements than size are skipped. window_func: Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window. window_valid: Function that, given an array window, returns True if the window is valid; invalid windows are skipped. label_shift: A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, label_shift can be set to one less than size. label_missing_skips: If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label. label_missing_raises: If True, a window that cannot derive a label will raise an exception. start_shift: A shift to determine the first element where window collection begins. size_increment: A value to be added to size with each window after the first, so as to, in combination with setting step to 0, permit iterating over expanding windows.", "Quilt.iter_window().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Quilt.iter_window().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Quilt.iter_window().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Quilt.iter_window().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Quilt.iter_window_array()": "Iterator of windowed values, where values are given as a np.array. Args: size: Elements per window, given as an integer greater than 0. axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. step: Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the size will result in non-overlapping windows. window_sized: if True, windows with fewer elements than size are skipped. window_func: Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window. window_valid: Function that, given an array window, returns True if the window is valid; invalid windows are skipped. label_shift: A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, label_shift can be set to one less than size. label_missing_skips: If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label. label_missing_raises: If True, a window that cannot derive a label will raise an exception. start_shift: A shift to determine the first element where window collection begins. size_increment: A value to be added to size with each window after the first, so as to, in combination with setting step to 0, permit iterating over expanding windows.", "Quilt.iter_window_array().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Quilt.iter_window_array().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Quilt.iter_window_array().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Quilt.iter_window_array().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Quilt.iter_window_array_items()": "Iterator of pairs of label, windowed values, where values are given as a np.array. Args: size: Elements per window, given as an integer greater than 0. axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. step: Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the size will result in non-overlapping windows. window_sized: if True, windows with fewer elements than size are skipped. window_func: Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window. window_valid: Function that, given an array window, returns True if the window is valid; invalid windows are skipped. label_shift: A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, label_shift can be set to one less than size. label_missing_skips: If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label. label_missing_raises: If True, a window that cannot derive a label will raise an exception. start_shift: A shift to determine the first element where window collection begins. size_increment: A value to be added to size with each window after the first, so as to, in combination with setting step to 0, permit iterating over expanding windows.", "Quilt.iter_window_array_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Quilt.iter_window_array_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Quilt.iter_window_array_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Quilt.iter_window_array_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Quilt.iter_window_items()": "Iterator of pairs of label, windowed values, where values are given as a Frame. Args: size: Elements per window, given as an integer greater than 0. axis: Integer specifying axis, where 0 is rows and 1 is columns. Axis 0 is set by default. step: Element shift per window, given as an integer greater than 0. Determines the step size between windows. A step of 1 shifts each window 1 element; a step equal to the size will result in non-overlapping windows. window_sized: if True, windows with fewer elements than size are skipped. window_func: Array processor of window values, executed before function application (if used): can be used for applying a weighting function to each window. window_valid: Function that, given an array window, returns True if the window is valid; invalid windows are skipped. label_shift: A shift, relative to the right-most element contained in the window, to derive the label to be paired with the window. For example, to label each window with the label found at the start of the window, label_shift can be set to one less than size. label_missing_skips: If True, a window that cannot derive a label will skip that window; if False, the window will be returned with None as the label. label_missing_raises: If True, a window that cannot derive a label will raise an exception. start_shift: A shift to determine the first element where window collection begins. size_increment: A value to be added to size with each window after the first, so as to, in combination with setting step to 0, permit iterating over expanding windows.", "Quilt.iter_window_items().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Quilt.iter_window_items().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Quilt.iter_window_items().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Quilt.iter_window_items().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Quilt.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "Quilt.via_hashlib().md5()": "", "Quilt.via_hashlib().sha256()": "", "Quilt.via_hashlib().sha512()": "", "Quilt.via_hashlib().sha3_256()": "", "Quilt.via_hashlib().sha3_512()": "", "Quilt.via_hashlib().shake_128()": "", "Quilt.via_hashlib().shake_256()": "", "Quilt.via_hashlib().blake2b()": "", "Quilt.via_hashlib().blake2s()": "", "Quilt.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "Quilt.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "Quilt.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "Quilt.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "Quilt.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "Index.__init__()": "Initializer. Args: labels: An iterable of unique, hashable values, or another Index or IndexHierarchy, to be used as the labels of the index. name: A hashable object to label the container. loc_is_iloc: Optimization when a contiguous integer index is provided as labels. Generally only set by internal clients. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Index.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "Index.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "Index.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "Index.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "Index.to_pandas()": "Return a Pandas Index.", "Index.to_series()": "Return a Series with values from this Index's labels.", "Index.to_visidata()": "Open an interactive VisiData session.", "Index.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "Index.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "Index.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "Index.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "Index.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "Index.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "Index.name": "A hashable label attached to this container. Returns: Hashable", "Index.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "Index.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "Index.ndim": "Return the number of dimensions. Returns: int", "Index.positions": "Return the immutable positions array.", "Index.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "Index.size": "Return the size of the underlying NumPy array. Returns: int", "Index.__array__()": "Support the __array__ interface, returning an array of values.", "Index.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "Index.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "Index.__copy__()": "Return shallow copy of this Index.", "Index.__deepcopy__()": "", "Index.__len__()": "", "Index.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Index.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Index.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Index.copy()": "Return shallow copy of this Index.", "Index.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Index.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Index.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "Index.dropfalsy()": "Return a new Index after removing values of NaN or None.", "Index.dropna()": "Return a new Index after removing values of NaN or None.", "Index.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "Index.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "Index.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "Index.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "Index.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "Index.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "Index.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "Index.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "Index.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "Index.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "Index.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "Index.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "Index.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "Index.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Index.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Index.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Index.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Index.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "Index.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "Index.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Index.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "Index.rename()": "Return a new Frame with an updated name attribute.", "Index.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "Index.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "Index.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "Index.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Index.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Index.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "Index.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "Index.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "Index.values_at_depth()": "Return an NP array for the depth_level specified.", "Index.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "Index.__contains__()": "Return True if value in the labels.", "Index.__iter__()": "Iterate over labels.", "Index.__reversed__()": "Returns a reverse iterator on the index labels.", "Index.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "Index.interface": "A Frame documenting the interface of this class.", "Index.__repr__()": "", "Index.__str__()": "Return str(self).", "Index.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Index.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Index.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "Index.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "Index.drop.loc[]": "", "Index.[]": "Extract a new index given an iloc key.", "Index.iloc[]": "", "Index.loc[]": "", "Index.iter_label()": "", "Index.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "Index.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "Index.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "Index.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "Index.__add__()": "", "Index.__and__()": "", "Index.__eq__()": "", "Index.__floordiv__()": "", "Index.__ge__()": "", "Index.__gt__()": "", "Index.__le__()": "", "Index.__lt__()": "", "Index.__matmul__()": "", "Index.__mod__()": "", "Index.__mul__()": "", "Index.__ne__()": "", "Index.__or__()": "", "Index.__pow__()": "", "Index.__radd__()": "", "Index.__rfloordiv__()": "", "Index.__rmatmul__()": "", "Index.__rmul__()": "", "Index.__rshift__()": "", "Index.__rsub__()": "", "Index.__rtruediv__()": "", "Index.__sub__()": "", "Index.__truediv__()": "", "Index.__xor__()": "", "Index.__abs__()": "", "Index.__invert__()": "", "Index.__neg__()": "", "Index.__pos__()": "", "Index.via_values.apply()": "", "Index.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "Index.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "Index.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "Index.via_dt.year": "Return the year of each element.", "Index.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "Index.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "Index.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "Index.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "Index.via_dt.hour": "Return the hour of each element, between 0 and 24.", "Index.via_dt.minute": "Return the minute of each element, between 0 and 60.", "Index.via_dt.second": "Return the second of each element, between 0 and 60.", "Index.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "Index.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "Index.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "Index.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "Index.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "Index.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "Index.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "Index.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "Index.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "Index.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "Index.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "Index.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "Index.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "Index.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "Index.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "Index.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "Index.via_str.center()": "Return a container with its elements centered in a string of length width.", "Index.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "Index.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "Index.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "Index.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "Index.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "Index.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "Index.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "Index.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "Index.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "Index.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "Index.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "Index.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "Index.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "Index.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "Index.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "Index.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "Index.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "Index.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "Index.via_str.len()": "Return the length of the string.", "Index.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "Index.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "Index.via_str.partition()": "Partition each element around sep.", "Index.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "Index.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "Index.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "Index.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "Index.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "Index.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "Index.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "Index.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "Index.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "Index.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "Index.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "Index.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "Index.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "Index.via_str.zfill()": "Return the string left-filled with zeros.", "Index.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "Index.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "Index.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "Index.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "Index.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "Index.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "Index.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "Index.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "Index.via_hashlib().md5()": "", "Index.via_hashlib().sha256()": "", "Index.via_hashlib().sha512()": "", "Index.via_hashlib().sha3_256()": "", "Index.via_hashlib().sha3_512()": "", "Index.via_hashlib().shake_128()": "", "Index.via_hashlib().shake_256()": "", "Index.via_hashlib().blake2b()": "", "Index.via_hashlib().blake2s()": "", "Index.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "Index.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "Index.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "Index.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "Index.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexGO.__init__()": "Initializer. Args: labels: An iterable of unique, hashable values, or another Index or IndexHierarchy, to be used as the labels of the index. name: A hashable object to label the container. loc_is_iloc: Optimization when a contiguous integer index is provided as labels. Generally only set by internal clients. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexGO.to_pandas()": "Return a Pandas Index.", "IndexGO.to_series()": "Return a Series with values from this Index's labels.", "IndexGO.to_visidata()": "Open an interactive VisiData session.", "IndexGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexGO.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexGO.ndim": "Return the number of dimensions. Returns: int", "IndexGO.positions": "Return the immutable positions array.", "IndexGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexGO.__copy__()": "Return shallow copy of this Index.", "IndexGO.__deepcopy__()": "", "IndexGO.__len__()": "", "IndexGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexGO.append()": "Append a value to this Index. Note: if the appended value not permitted by a specific Index subclass, this will raise and the caller will need to derive a new index type.", "IndexGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexGO.copy()": "Return shallow copy of this Index.", "IndexGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexGO.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexGO.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexGO.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexGO.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexGO.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexGO.rename()": "Return a new Frame with an updated name attribute.", "IndexGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexGO.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexGO.__contains__()": "Return True if value in the labels.", "IndexGO.__iter__()": "Iterate over labels.", "IndexGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexGO.interface": "A Frame documenting the interface of this class.", "IndexGO.__repr__()": "", "IndexGO.__str__()": "Return str(self).", "IndexGO.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexGO.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexGO.drop.loc[]": "", "IndexGO.[]": "Extract a new index given an iloc key.", "IndexGO.iloc[]": "", "IndexGO.loc[]": "", "IndexGO.iter_label()": "", "IndexGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexGO.__add__()": "", "IndexGO.__and__()": "", "IndexGO.__eq__()": "", "IndexGO.__floordiv__()": "", "IndexGO.__ge__()": "", "IndexGO.__gt__()": "", "IndexGO.__le__()": "", "IndexGO.__lt__()": "", "IndexGO.__matmul__()": "", "IndexGO.__mod__()": "", "IndexGO.__mul__()": "", "IndexGO.__ne__()": "", "IndexGO.__or__()": "", "IndexGO.__pow__()": "", "IndexGO.__radd__()": "", "IndexGO.__rfloordiv__()": "", "IndexGO.__rmatmul__()": "", "IndexGO.__rmul__()": "", "IndexGO.__rshift__()": "", "IndexGO.__rsub__()": "", "IndexGO.__rtruediv__()": "", "IndexGO.__sub__()": "", "IndexGO.__truediv__()": "", "IndexGO.__xor__()": "", "IndexGO.__abs__()": "", "IndexGO.__invert__()": "", "IndexGO.__neg__()": "", "IndexGO.__pos__()": "", "IndexGO.via_values.apply()": "", "IndexGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexGO.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexGO.via_dt.year": "Return the year of each element.", "IndexGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexGO.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexGO.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexGO.via_str.len()": "Return the length of the string.", "IndexGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexGO.via_str.partition()": "Partition each element around sep.", "IndexGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexGO.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexGO.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexGO.via_hashlib().md5()": "", "IndexGO.via_hashlib().sha256()": "", "IndexGO.via_hashlib().sha512()": "", "IndexGO.via_hashlib().sha3_256()": "", "IndexGO.via_hashlib().sha3_512()": "", "IndexGO.via_hashlib().shake_128()": "", "IndexGO.via_hashlib().shake_256()": "", "IndexGO.via_hashlib().blake2b()": "", "IndexGO.via_hashlib().blake2s()": "", "IndexGO.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexGO.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexGO.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexGO.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexGO.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexHierarchy.__init__()": "Initializer. Args: indices: list of Index objects indexers: a 2D indexer array name: name of the IndexHierarchy blocks: own_blocks:", "IndexHierarchy.from_index_items()": "Given an iterable of pairs of label, IndexBase, produce an IndexHierarchy where the labels are depth 0, the indices are depth 1. While the provided IndexBase can be Index or IndexHierarchy, across all pairs all depths must be the same. Args: items: iterable of pairs of label, IndexBase. index_constructor: Optionally provide index constructor for outermost index.", "IndexHierarchy.from_labels()": "Construct an IndexHierarchy from an iterable of labels, where each label is tuple defining the component labels for all hierarchies. Args: labels: an iterator or generator of tuples. * name: reorder_for_hierarchy: an optional argument that will ensure the resulting index is arranged in a tree-like structure. index_constructors: depth_reference: continuation_token: a Hashable that will be used as a token to identify when a value in a label should use the previously encountered value at the same depth. Returns: IndexHierarchy", "IndexHierarchy.from_labels_delimited()": "Construct an IndexHierarchy from an iterable of labels, where each label is string defining the component labels for all hierarchies using a string delimiter. All components after splitting the string by the delimited will be literal evaled to produce proper types; thus, strings must be quoted. Args: labels: an iterator or generator of tuples. Returns: IndexHierarchy", "IndexHierarchy.from_names()": "Construct a zero-length IndexHierarchy from an iterable of names, where the length of names defines the zero-length depth. Args: names: Iterable of hashable names per depth.", "IndexHierarchy.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexHierarchy.from_product()": "Given groups of iterables, return an IndexHierarchy made of the product of a values in those groups, where the first group is the top-most hierarchy. Args: *levels: index initializers (or Index instances) for each level name: index_consructors: Returns: IndexHierarchy", "IndexHierarchy.from_tree()": "Convert into a IndexHierarchy a dictionary defining keys to either iterables or nested dictionaries of the same. Returns: IndexHierarchy", "IndexHierarchy.from_values_per_depth()": "Construct an IndexHierarchy from a 2D NumPy array, or a collection of 1D arrays per depth. Very similar implementation to :meth:_from_type_blocks, but avoids creating TypeBlocks instance. Returns: IndexHierarchy", "IndexHierarchy.to_frame()": "Return Frame version of this IndexHierarchy.", "IndexHierarchy.to_frame_go()": "Return a FrameGO version of this IndexHierarchy.", "IndexHierarchy.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexHierarchy.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexHierarchy.to_pandas()": "Return a Pandas MultiIndex.", "IndexHierarchy.to_tree()": "Returns the tree representation of an IndexHierarchy", "IndexHierarchy.to_visidata()": "Open an interactive VisiData session.", "IndexHierarchy.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexHierarchy.depth": "Return the depth of the index hierarchy.", "IndexHierarchy.dtypes": "Return a Series of dytpes for each index depth. Returns: Series", "IndexHierarchy.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexHierarchy.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexHierarchy.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexHierarchy.name": "A hashable label attached to this container. Returns: Hashable", "IndexHierarchy.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexHierarchy.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexHierarchy.ndim": "Return the number of dimensions. Returns: int", "IndexHierarchy.positions": "Return the immutable positions array.", "IndexHierarchy.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexHierarchy.size": "Return the size of the underlying NumPy array. Returns: int", "IndexHierarchy.__array__()": "Support the __array__ interface, returning an array of values.", "IndexHierarchy.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexHierarchy.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexHierarchy.__copy__()": "Return a shallow copy of this IndexHierarchy.", "IndexHierarchy.__deepcopy__()": "Return a deep copy of this IndexHierarchy.", "IndexHierarchy.__len__()": "", "IndexHierarchy.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchy.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchy.astype[]()": "Selector of columns by label. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.", "IndexHierarchy.astype()": "Apply a single dtype to all columns.", "IndexHierarchy.copy()": "Return a shallow copy of this IndexHierarchy.", "IndexHierarchy.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchy.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchy.difference()": "", "IndexHierarchy.dropfalsy()": "Return a new obj:IndexHierarchy after removing labels where any or all values are falsy. The condition is determined by a NumPy ufunc that process the Boolean array returned by isna(); the default is np.all. Args: * condition:", "IndexHierarchy.dropna()": "Return a new obj:IndexHierarchy after removing labels where any or all values are NA (NaN or None). The condition is determined by a NumPy ufunc that process the Boolean array returned by isna(); the default is np.all. Args: * condition:", "IndexHierarchy.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexHierarchy.fillfalsy()": "Return an IndexHierarchy after replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexHierarchy.fillna()": "Return an IndexHierarchy after replacing NA (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexHierarchy.flat()": "Return a flat, one-dimensional index of tuples for each level.", "IndexHierarchy.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexHierarchy.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexHierarchy.index_at_depth()": "Return an index, or a tuple of indices for the depth_level specified. Args: depth_level: a single depth level, or iterable depth of depth levels.", "IndexHierarchy.indexer_at_depth()": "Return the indexers for the depth_level specified. Array will 2D if multiple depths are selected. Args: depth_level: a single depth level, or iterable depth of depth levels.", "IndexHierarchy.intersection()": "", "IndexHierarchy.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexHierarchy.isin()": "Return a Boolean array showing True where one or more of the passed in iterable of labels is found in the index.", "IndexHierarchy.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexHierarchy.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexHierarchy.level_add()": "Return an IndexHierarchy with a new root (outer) level added.", "IndexHierarchy.level_drop()": "Return an IndexHierarchy with one or more leaf levels removed. Args: count: A positive value is the number of depths to remove from the root (outer) side of the hierarchy; a negative value is the number of depths to remove from the leaf (inner) side of the hierarchy.", "IndexHierarchy.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexHierarchy.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, an HLoc object, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexHierarchy.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchy.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchy.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchy.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchy.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexHierarchy.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexHierarchy.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchy.rehierarch()": "Return a new IndexHierarchy that conforms to the new depth assignments given be depth_map.", "IndexHierarchy.relabel()": "Return a new IndexHierarchy with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping should map tuple representation of labels, and need not map all origin keys.", "IndexHierarchy.relabel_at_depth()": "Return a new IndexHierarchy after applying mapper to a level or each individual level specified by depth_level. mapper can be a callable, mapping, or iterable. - If a callable, it must accept a single hashable, and return a single hashable. - If a mapping, it must map a single hashable to a single hashable. - If a iterable, it must be the same length as self. This call: >>> index.relabel_at_depth(mapper, depth_level=[0, 1, 2]) is equivalent to: >>> for level in [0, 1, 2]: >>> index = index.relabel_at_depth(mapper, depth_level=level) albeit more efficient.", "IndexHierarchy.rename()": "Return a new IndexHierarchy with an updated name attribute.", "IndexHierarchy.roll()": "Return an IndexHierarchy with values rotated forward and wrapped around (with a positive shift) or backward and wrapped around (with a negative shift).", "IndexHierarchy.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexHierarchy.sort()": "Return a new Index with the labels sorted. Args: ascendings: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexHierarchy.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchy.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchy.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexHierarchy.union()": "", "IndexHierarchy.unique()": "Return a NumPy array of unique values. Args: depth_level: Specify a single depth or multiple depths in an iterable. order_by_occurrence: if True, values are ordered by when they first appear Returns: numpy.ndarray", "IndexHierarchy.values_at_depth()": "Return an NP array for the depth_level specified. Args: depth_level: a single depth level, or iterable depth of depth levels.", "IndexHierarchy.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchy.__contains__()": "Determine if a label value is contained in this Index.", "IndexHierarchy.__iter__()": "Iterate over labels.", "IndexHierarchy.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexHierarchy.values": "A 2D NumPy array of all values in the IndexHierarchy. As this is a single array, heterogenous columnar types might be coerced to a compatible type.", "IndexHierarchy.interface": "A Frame documenting the interface of this class.", "IndexHierarchy.__repr__()": "", "IndexHierarchy.__str__()": "Return str(self).", "IndexHierarchy.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexHierarchy.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexHierarchy.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexHierarchy.[]": "Extract a new index given a key.", "IndexHierarchy.iloc[]": "", "IndexHierarchy.loc[]": "", "IndexHierarchy.iter_label()": "", "IndexHierarchy.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexHierarchy.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexHierarchy.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexHierarchy.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexHierarchy.__add__()": "", "IndexHierarchy.__and__()": "", "IndexHierarchy.__eq__()": "", "IndexHierarchy.__floordiv__()": "", "IndexHierarchy.__ge__()": "", "IndexHierarchy.__gt__()": "", "IndexHierarchy.__le__()": "", "IndexHierarchy.__lt__()": "", "IndexHierarchy.__matmul__()": "", "IndexHierarchy.__mod__()": "", "IndexHierarchy.__mul__()": "", "IndexHierarchy.__ne__()": "", "IndexHierarchy.__or__()": "", "IndexHierarchy.__pow__()": "", "IndexHierarchy.__radd__()": "", "IndexHierarchy.__rfloordiv__()": "", "IndexHierarchy.__rmatmul__()": "", "IndexHierarchy.__rmul__()": "", "IndexHierarchy.__rshift__()": "", "IndexHierarchy.__rsub__()": "", "IndexHierarchy.__rtruediv__()": "", "IndexHierarchy.__sub__()": "", "IndexHierarchy.__truediv__()": "", "IndexHierarchy.__xor__()": "", "IndexHierarchy.__abs__()": "", "IndexHierarchy.__invert__()": "", "IndexHierarchy.__neg__()": "", "IndexHierarchy.__pos__()": "", "IndexHierarchy.via_values.apply()": "", "IndexHierarchy.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexHierarchy.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexHierarchy.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexHierarchy.via_dt.year": "Return the year of each element.", "IndexHierarchy.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexHierarchy.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexHierarchy.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexHierarchy.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexHierarchy.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexHierarchy.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexHierarchy.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexHierarchy.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexHierarchy.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexHierarchy.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexHierarchy.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexHierarchy.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexHierarchy.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexHierarchy.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexHierarchy.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexHierarchy.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexHierarchy.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexHierarchy.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexHierarchy.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexHierarchy.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexHierarchy.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexHierarchy.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexHierarchy.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexHierarchy.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexHierarchy.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexHierarchy.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexHierarchy.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexHierarchy.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexHierarchy.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexHierarchy.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexHierarchy.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexHierarchy.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexHierarchy.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexHierarchy.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexHierarchy.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexHierarchy.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexHierarchy.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexHierarchy.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexHierarchy.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexHierarchy.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexHierarchy.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexHierarchy.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexHierarchy.via_str.len()": "Return the length of the string.", "IndexHierarchy.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexHierarchy.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexHierarchy.via_str.partition()": "Partition each element around sep.", "IndexHierarchy.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexHierarchy.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexHierarchy.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexHierarchy.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexHierarchy.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexHierarchy.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexHierarchy.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexHierarchy.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexHierarchy.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexHierarchy.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexHierarchy.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexHierarchy.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexHierarchy.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexHierarchy.via_str.zfill()": "Return the string left-filled with zeros.", "IndexHierarchy.via_T.via_fill_value()": "Interface for using binary operators and methods with a pre-defined fill value.", "IndexHierarchy.via_T.__add__()": "", "IndexHierarchy.via_T.__sub__()": "", "IndexHierarchy.via_T.__mul__()": "", "IndexHierarchy.via_T.__truediv__()": "", "IndexHierarchy.via_T.__floordiv__()": "", "IndexHierarchy.via_T.__mod__()": "", "IndexHierarchy.via_T.__pow__()": "", "IndexHierarchy.via_T.__lshift__()": "", "IndexHierarchy.via_T.__rshift__()": "", "IndexHierarchy.via_T.__and__()": "", "IndexHierarchy.via_T.__xor__()": "", "IndexHierarchy.via_T.__or__()": "", "IndexHierarchy.via_T.__lt__()": "", "IndexHierarchy.via_T.__le__()": "", "IndexHierarchy.via_T.__eq__()": "", "IndexHierarchy.via_T.__ne__()": "", "IndexHierarchy.via_T.__gt__()": "", "IndexHierarchy.via_T.__ge__()": "", "IndexHierarchy.via_T.__radd__()": "", "IndexHierarchy.via_T.__rsub__()": "", "IndexHierarchy.via_T.__rmul__()": "", "IndexHierarchy.via_T.__rtruediv__()": "", "IndexHierarchy.via_T.__rfloordiv__()": "", "IndexHierarchy.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexHierarchy.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexHierarchy.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexHierarchy.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexHierarchy.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexHierarchy.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexHierarchy.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexHierarchy.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexHierarchy.via_hashlib().md5()": "", "IndexHierarchy.via_hashlib().sha256()": "", "IndexHierarchy.via_hashlib().sha512()": "", "IndexHierarchy.via_hashlib().sha3_256()": "", "IndexHierarchy.via_hashlib().sha3_512()": "", "IndexHierarchy.via_hashlib().shake_128()": "", "IndexHierarchy.via_hashlib().shake_256()": "", "IndexHierarchy.via_hashlib().blake2b()": "", "IndexHierarchy.via_hashlib().blake2s()": "", "IndexHierarchy.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexHierarchy.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexHierarchy.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexHierarchy.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexHierarchy.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexHierarchyGO.__init__()": "Initializer. Args: indices: list of Index objects indexers: a 2D indexer array name: name of the IndexHierarchy blocks: own_blocks:", "IndexHierarchyGO.from_index_items()": "Given an iterable of pairs of label, IndexBase, produce an IndexHierarchy where the labels are depth 0, the indices are depth 1. While the provided IndexBase can be Index or IndexHierarchy, across all pairs all depths must be the same. Args: items: iterable of pairs of label, IndexBase. index_constructor: Optionally provide index constructor for outermost index.", "IndexHierarchyGO.from_labels()": "Construct an IndexHierarchy from an iterable of labels, where each label is tuple defining the component labels for all hierarchies. Args: labels: an iterator or generator of tuples. * name: reorder_for_hierarchy: an optional argument that will ensure the resulting index is arranged in a tree-like structure. index_constructors: depth_reference: continuation_token: a Hashable that will be used as a token to identify when a value in a label should use the previously encountered value at the same depth. Returns: IndexHierarchy", "IndexHierarchyGO.from_labels_delimited()": "Construct an IndexHierarchy from an iterable of labels, where each label is string defining the component labels for all hierarchies using a string delimiter. All components after splitting the string by the delimited will be literal evaled to produce proper types; thus, strings must be quoted. Args: labels: an iterator or generator of tuples. Returns: IndexHierarchy", "IndexHierarchyGO.from_names()": "Construct a zero-length IndexHierarchy from an iterable of names, where the length of names defines the zero-length depth. Args: names: Iterable of hashable names per depth.", "IndexHierarchyGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexHierarchyGO.from_product()": "Given groups of iterables, return an IndexHierarchy made of the product of a values in those groups, where the first group is the top-most hierarchy. Args: *levels: index initializers (or Index instances) for each level name: index_consructors: Returns: IndexHierarchy", "IndexHierarchyGO.from_tree()": "Convert into a IndexHierarchy a dictionary defining keys to either iterables or nested dictionaries of the same. Returns: IndexHierarchy", "IndexHierarchyGO.from_values_per_depth()": "Construct an IndexHierarchy from a 2D NumPy array, or a collection of 1D arrays per depth. Very similar implementation to :meth:_from_type_blocks, but avoids creating TypeBlocks instance. Returns: IndexHierarchy", "IndexHierarchyGO.to_frame()": "Return Frame version of this IndexHierarchy.", "IndexHierarchyGO.to_frame_go()": "Return a FrameGO version of this IndexHierarchy.", "IndexHierarchyGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexHierarchyGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexHierarchyGO.to_pandas()": "Return a Pandas MultiIndex.", "IndexHierarchyGO.to_tree()": "Returns the tree representation of an IndexHierarchy", "IndexHierarchyGO.to_visidata()": "Open an interactive VisiData session.", "IndexHierarchyGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexHierarchyGO.depth": "Return the depth of the index hierarchy.", "IndexHierarchyGO.dtypes": "Return a Series of dytpes for each index depth. Returns: Series", "IndexHierarchyGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexHierarchyGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexHierarchyGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexHierarchyGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexHierarchyGO.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexHierarchyGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexHierarchyGO.ndim": "Return the number of dimensions. Returns: int", "IndexHierarchyGO.positions": "Return the immutable positions array.", "IndexHierarchyGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexHierarchyGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexHierarchyGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexHierarchyGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexHierarchyGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexHierarchyGO.__copy__()": "Return a shallow copy of this IndexHierarchy.", "IndexHierarchyGO.__deepcopy__()": "Return a deep copy of this IndexHierarchy.", "IndexHierarchyGO.__len__()": "", "IndexHierarchyGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchyGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchyGO.append()": "Append a single label to this IndexHierarchyGO in-place", "IndexHierarchyGO.astype[]()": "Selector of columns by label. Args: key: A loc selector, either a label, a list of labels, a slice of labels, or a Boolean array.", "IndexHierarchyGO.astype()": "Apply a single dtype to all columns.", "IndexHierarchyGO.copy()": "Return a shallow copy of this IndexHierarchy.", "IndexHierarchyGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchyGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchyGO.difference()": "", "IndexHierarchyGO.dropfalsy()": "Return a new obj:IndexHierarchy after removing labels where any or all values are falsy. The condition is determined by a NumPy ufunc that process the Boolean array returned by isna(); the default is np.all. Args: * condition:", "IndexHierarchyGO.dropna()": "Return a new obj:IndexHierarchy after removing labels where any or all values are NA (NaN or None). The condition is determined by a NumPy ufunc that process the Boolean array returned by isna(); the default is np.all. Args: * condition:", "IndexHierarchyGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexHierarchyGO.extend()": "Extend this IndexHierarchyGO in-place", "IndexHierarchyGO.fillfalsy()": "Return an IndexHierarchy after replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexHierarchyGO.fillna()": "Return an IndexHierarchy after replacing NA (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexHierarchyGO.flat()": "Return a flat, one-dimensional index of tuples for each level.", "IndexHierarchyGO.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexHierarchyGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexHierarchyGO.index_at_depth()": "Return an index, or a tuple of indices for the depth_level specified. Args: depth_level: a single depth level, or iterable depth of depth levels.", "IndexHierarchyGO.indexer_at_depth()": "Return the indexers for the depth_level specified. Array will 2D if multiple depths are selected. Args: depth_level: a single depth level, or iterable depth of depth levels.", "IndexHierarchyGO.intersection()": "", "IndexHierarchyGO.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexHierarchyGO.isin()": "Return a Boolean array showing True where one or more of the passed in iterable of labels is found in the index.", "IndexHierarchyGO.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexHierarchyGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexHierarchyGO.level_add()": "Return an IndexHierarchy with a new root (outer) level added.", "IndexHierarchyGO.level_drop()": "Return an IndexHierarchy with one or more leaf levels removed. Args: count: A positive value is the number of depths to remove from the root (outer) side of the hierarchy; a negative value is the number of depths to remove from the leaf (inner) side of the hierarchy.", "IndexHierarchyGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexHierarchyGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, an HLoc object, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexHierarchyGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchyGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchyGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchyGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchyGO.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexHierarchyGO.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexHierarchyGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchyGO.rehierarch()": "Return a new IndexHierarchy that conforms to the new depth assignments given be depth_map.", "IndexHierarchyGO.relabel()": "Return a new IndexHierarchy with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping should map tuple representation of labels, and need not map all origin keys.", "IndexHierarchyGO.relabel_at_depth()": "Return a new IndexHierarchy after applying mapper to a level or each individual level specified by depth_level. mapper can be a callable, mapping, or iterable. - If a callable, it must accept a single hashable, and return a single hashable. - If a mapping, it must map a single hashable to a single hashable. - If a iterable, it must be the same length as self. This call: >>> index.relabel_at_depth(mapper, depth_level=[0, 1, 2]) is equivalent to: >>> for level in [0, 1, 2]: >>> index = index.relabel_at_depth(mapper, depth_level=level) albeit more efficient.", "IndexHierarchyGO.rename()": "Return a new IndexHierarchy with an updated name attribute.", "IndexHierarchyGO.roll()": "Return an IndexHierarchy with values rotated forward and wrapped around (with a positive shift) or backward and wrapped around (with a negative shift).", "IndexHierarchyGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexHierarchyGO.sort()": "Return a new Index with the labels sorted. Args: ascendings: Boolean, or iterable of Booleans; if True, the lowest ranks correspond to the lowest values; if an iterable, apply per column or row. The default is True. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexHierarchyGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchyGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchyGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexHierarchyGO.union()": "", "IndexHierarchyGO.unique()": "Return a NumPy array of unique values. Args: depth_level: Specify a single depth or multiple depths in an iterable. order_by_occurrence: if True, values are ordered by when they first appear Returns: numpy.ndarray", "IndexHierarchyGO.values_at_depth()": "Return an NP array for the depth_level specified. Args: depth_level: a single depth level, or iterable depth of depth levels.", "IndexHierarchyGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHierarchyGO.__contains__()": "Determine if a label value is contained in this Index.", "IndexHierarchyGO.__iter__()": "Iterate over labels.", "IndexHierarchyGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexHierarchyGO.values": "A 2D NumPy array of all values in the IndexHierarchy. As this is a single array, heterogenous columnar types might be coerced to a compatible type.", "IndexHierarchyGO.interface": "A Frame documenting the interface of this class.", "IndexHierarchyGO.__repr__()": "", "IndexHierarchyGO.__str__()": "Return str(self).", "IndexHierarchyGO.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexHierarchyGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexHierarchyGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexHierarchyGO.[]": "Extract a new index given a key.", "IndexHierarchyGO.iloc[]": "", "IndexHierarchyGO.loc[]": "", "IndexHierarchyGO.iter_label()": "", "IndexHierarchyGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexHierarchyGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexHierarchyGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexHierarchyGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexHierarchyGO.__add__()": "", "IndexHierarchyGO.__and__()": "", "IndexHierarchyGO.__eq__()": "", "IndexHierarchyGO.__floordiv__()": "", "IndexHierarchyGO.__ge__()": "", "IndexHierarchyGO.__gt__()": "", "IndexHierarchyGO.__le__()": "", "IndexHierarchyGO.__lt__()": "", "IndexHierarchyGO.__matmul__()": "", "IndexHierarchyGO.__mod__()": "", "IndexHierarchyGO.__mul__()": "", "IndexHierarchyGO.__ne__()": "", "IndexHierarchyGO.__or__()": "", "IndexHierarchyGO.__pow__()": "", "IndexHierarchyGO.__radd__()": "", "IndexHierarchyGO.__rfloordiv__()": "", "IndexHierarchyGO.__rmatmul__()": "", "IndexHierarchyGO.__rmul__()": "", "IndexHierarchyGO.__rshift__()": "", "IndexHierarchyGO.__rsub__()": "", "IndexHierarchyGO.__rtruediv__()": "", "IndexHierarchyGO.__sub__()": "", "IndexHierarchyGO.__truediv__()": "", "IndexHierarchyGO.__xor__()": "", "IndexHierarchyGO.__abs__()": "", "IndexHierarchyGO.__invert__()": "", "IndexHierarchyGO.__neg__()": "", "IndexHierarchyGO.__pos__()": "", "IndexHierarchyGO.via_values.apply()": "", "IndexHierarchyGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexHierarchyGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexHierarchyGO.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexHierarchyGO.via_dt.year": "Return the year of each element.", "IndexHierarchyGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexHierarchyGO.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexHierarchyGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexHierarchyGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexHierarchyGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexHierarchyGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexHierarchyGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexHierarchyGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexHierarchyGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexHierarchyGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexHierarchyGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexHierarchyGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexHierarchyGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexHierarchyGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexHierarchyGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexHierarchyGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexHierarchyGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexHierarchyGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexHierarchyGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexHierarchyGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexHierarchyGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexHierarchyGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexHierarchyGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexHierarchyGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexHierarchyGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexHierarchyGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexHierarchyGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexHierarchyGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexHierarchyGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexHierarchyGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexHierarchyGO.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexHierarchyGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexHierarchyGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexHierarchyGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexHierarchyGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexHierarchyGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexHierarchyGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexHierarchyGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexHierarchyGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexHierarchyGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexHierarchyGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexHierarchyGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexHierarchyGO.via_str.len()": "Return the length of the string.", "IndexHierarchyGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexHierarchyGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexHierarchyGO.via_str.partition()": "Partition each element around sep.", "IndexHierarchyGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexHierarchyGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexHierarchyGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexHierarchyGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexHierarchyGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexHierarchyGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexHierarchyGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexHierarchyGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexHierarchyGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexHierarchyGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexHierarchyGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexHierarchyGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexHierarchyGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexHierarchyGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexHierarchyGO.via_T.via_fill_value()": "Interface for using binary operators and methods with a pre-defined fill value.", "IndexHierarchyGO.via_T.__add__()": "", "IndexHierarchyGO.via_T.__sub__()": "", "IndexHierarchyGO.via_T.__mul__()": "", "IndexHierarchyGO.via_T.__truediv__()": "", "IndexHierarchyGO.via_T.__floordiv__()": "", "IndexHierarchyGO.via_T.__mod__()": "", "IndexHierarchyGO.via_T.__pow__()": "", "IndexHierarchyGO.via_T.__lshift__()": "", "IndexHierarchyGO.via_T.__rshift__()": "", "IndexHierarchyGO.via_T.__and__()": "", "IndexHierarchyGO.via_T.__xor__()": "", "IndexHierarchyGO.via_T.__or__()": "", "IndexHierarchyGO.via_T.__lt__()": "", "IndexHierarchyGO.via_T.__le__()": "", "IndexHierarchyGO.via_T.__eq__()": "", "IndexHierarchyGO.via_T.__ne__()": "", "IndexHierarchyGO.via_T.__gt__()": "", "IndexHierarchyGO.via_T.__ge__()": "", "IndexHierarchyGO.via_T.__radd__()": "", "IndexHierarchyGO.via_T.__rsub__()": "", "IndexHierarchyGO.via_T.__rmul__()": "", "IndexHierarchyGO.via_T.__rtruediv__()": "", "IndexHierarchyGO.via_T.__rfloordiv__()": "", "IndexHierarchyGO.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexHierarchyGO.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexHierarchyGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexHierarchyGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexHierarchyGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexHierarchyGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexHierarchyGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexHierarchyGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexHierarchyGO.via_hashlib().md5()": "", "IndexHierarchyGO.via_hashlib().sha256()": "", "IndexHierarchyGO.via_hashlib().sha512()": "", "IndexHierarchyGO.via_hashlib().sha3_256()": "", "IndexHierarchyGO.via_hashlib().sha3_512()": "", "IndexHierarchyGO.via_hashlib().shake_128()": "", "IndexHierarchyGO.via_hashlib().shake_256()": "", "IndexHierarchyGO.via_hashlib().blake2b()": "", "IndexHierarchyGO.via_hashlib().blake2s()": "", "IndexHierarchyGO.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexHierarchyGO.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexHierarchyGO.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexHierarchyGO.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexHierarchyGO.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexYear.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexYear.from_date_range()": "Get an IndexYearMonth instance over a range of dates, where start and stop are inclusive.", "IndexYear.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexYear.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexYear.from_year_month_range()": "Get an IndexYearMonth instance over a range of months, where start and end are inclusive.", "IndexYear.from_year_range()": "Get an IndexDate instance over a range of years, where start and end are inclusive.", "IndexYear.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexYear.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexYear.to_pandas()": "Return a Pandas Index.", "IndexYear.to_series()": "Return a Series with values from this Index's labels.", "IndexYear.to_visidata()": "Open an interactive VisiData session.", "IndexYear.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexYear.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexYear.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexYear.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexYear.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexYear.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexYear.name": "A hashable label attached to this container. Returns: Hashable", "IndexYear.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexYear.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexYear.ndim": "Return the number of dimensions. Returns: int", "IndexYear.positions": "Return the immutable positions array.", "IndexYear.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexYear.size": "Return the size of the underlying NumPy array. Returns: int", "IndexYear.__array__()": "Support the __array__ interface, returning an array of values.", "IndexYear.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexYear.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexYear.__copy__()": "Return shallow copy of this Index.", "IndexYear.__deepcopy__()": "", "IndexYear.__len__()": "", "IndexYear.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYear.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYear.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexYear.copy()": "Return shallow copy of this Index.", "IndexYear.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYear.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYear.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexYear.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexYear.dropna()": "Return a new Index after removing values of NaN or None.", "IndexYear.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexYear.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexYear.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexYear.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexYear.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexYear.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexYear.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexYear.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexYear.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexYear.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexYear.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexYear.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexYear.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexYear.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYear.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYear.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYear.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYear.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexYear.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexYear.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYear.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexYear.rename()": "Return a new Frame with an updated name attribute.", "IndexYear.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexYear.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexYear.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexYear.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYear.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYear.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexYear.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexYear.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexYear.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexYear.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYear.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexYear.__iter__()": "Iterate over labels.", "IndexYear.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexYear.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexYear.interface": "A Frame documenting the interface of this class.", "IndexYear.__repr__()": "", "IndexYear.__str__()": "Return str(self).", "IndexYear.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexYear.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexYear.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexYear.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexYear.drop.loc[]": "", "IndexYear.[]": "Extract a new index given an iloc key.", "IndexYear.iloc[]": "", "IndexYear.loc[]": "", "IndexYear.iter_label()": "", "IndexYear.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexYear.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexYear.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexYear.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexYear.__add__()": "", "IndexYear.__and__()": "", "IndexYear.__eq__()": "", "IndexYear.__floordiv__()": "", "IndexYear.__ge__()": "", "IndexYear.__gt__()": "", "IndexYear.__le__()": "", "IndexYear.__lt__()": "", "IndexYear.__matmul__()": "", "IndexYear.__mod__()": "", "IndexYear.__mul__()": "", "IndexYear.__ne__()": "", "IndexYear.__or__()": "", "IndexYear.__pow__()": "", "IndexYear.__radd__()": "", "IndexYear.__rfloordiv__()": "", "IndexYear.__rmatmul__()": "", "IndexYear.__rmul__()": "", "IndexYear.__rshift__()": "", "IndexYear.__rsub__()": "", "IndexYear.__rtruediv__()": "", "IndexYear.__sub__()": "", "IndexYear.__truediv__()": "", "IndexYear.__xor__()": "", "IndexYear.__abs__()": "", "IndexYear.__invert__()": "", "IndexYear.__neg__()": "", "IndexYear.__pos__()": "", "IndexYear.via_values.apply()": "", "IndexYear.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexYear.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexYear.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexYear.via_dt.year": "Return the year of each element.", "IndexYear.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexYear.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexYear.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexYear.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexYear.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexYear.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexYear.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexYear.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexYear.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexYear.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexYear.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexYear.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexYear.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexYear.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexYear.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexYear.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexYear.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexYear.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexYear.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexYear.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexYear.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexYear.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexYear.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexYear.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexYear.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexYear.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexYear.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexYear.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexYear.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexYear.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexYear.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexYear.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexYear.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexYear.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexYear.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexYear.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexYear.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexYear.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexYear.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexYear.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexYear.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexYear.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexYear.via_str.len()": "Return the length of the string.", "IndexYear.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexYear.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexYear.via_str.partition()": "Partition each element around sep.", "IndexYear.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexYear.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexYear.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexYear.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexYear.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexYear.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexYear.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexYear.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexYear.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexYear.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexYear.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexYear.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexYear.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexYear.via_str.zfill()": "Return the string left-filled with zeros.", "IndexYear.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexYear.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexYear.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexYear.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexYear.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexYear.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexYear.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexYear.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexYear.via_hashlib().md5()": "", "IndexYear.via_hashlib().sha256()": "", "IndexYear.via_hashlib().sha512()": "", "IndexYear.via_hashlib().sha3_256()": "", "IndexYear.via_hashlib().sha3_512()": "", "IndexYear.via_hashlib().shake_128()": "", "IndexYear.via_hashlib().shake_256()": "", "IndexYear.via_hashlib().blake2b()": "", "IndexYear.via_hashlib().blake2s()": "", "IndexYear.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexYear.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexYear.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexYear.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexYear.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexYearGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexYearGO.from_date_range()": "Get an IndexYearMonth instance over a range of dates, where start and stop are inclusive.", "IndexYearGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexYearGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexYearGO.from_year_month_range()": "Get an IndexYearMonth instance over a range of months, where start and end are inclusive.", "IndexYearGO.from_year_range()": "Get an IndexDate instance over a range of years, where start and end are inclusive.", "IndexYearGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexYearGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexYearGO.to_pandas()": "Return a Pandas Index.", "IndexYearGO.to_series()": "Return a Series with values from this Index's labels.", "IndexYearGO.to_visidata()": "Open an interactive VisiData session.", "IndexYearGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexYearGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexYearGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexYearGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexYearGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexYearGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexYearGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexYearGO.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexYearGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexYearGO.ndim": "Return the number of dimensions. Returns: int", "IndexYearGO.positions": "Return the immutable positions array.", "IndexYearGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexYearGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexYearGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexYearGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexYearGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexYearGO.__copy__()": "Return shallow copy of this Index.", "IndexYearGO.__deepcopy__()": "", "IndexYearGO.__len__()": "", "IndexYearGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resolve_dtype with each addition; self._map is never None", "IndexYearGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexYearGO.copy()": "Return shallow copy of this Index.", "IndexYearGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexYearGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexYearGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexYearGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexYearGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexYearGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexYearGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexYearGO.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexYearGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexYearGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexYearGO.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexYearGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexYearGO.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexYearGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexYearGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexYearGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexYearGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexYearGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearGO.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexYearGO.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexYearGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexYearGO.rename()": "Return a new Frame with an updated name attribute.", "IndexYearGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexYearGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexYearGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexYearGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexYearGO.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexYearGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexYearGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexYearGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexYearGO.__iter__()": "Iterate over labels.", "IndexYearGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexYearGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexYearGO.interface": "A Frame documenting the interface of this class.", "IndexYearGO.__repr__()": "", "IndexYearGO.__str__()": "Return str(self).", "IndexYearGO.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexYearGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexYearGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexYearGO.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexYearGO.drop.loc[]": "", "IndexYearGO.[]": "Extract a new index given an iloc key.", "IndexYearGO.iloc[]": "", "IndexYearGO.loc[]": "", "IndexYearGO.iter_label()": "", "IndexYearGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexYearGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexYearGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexYearGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexYearGO.__add__()": "", "IndexYearGO.__and__()": "", "IndexYearGO.__eq__()": "", "IndexYearGO.__floordiv__()": "", "IndexYearGO.__ge__()": "", "IndexYearGO.__gt__()": "", "IndexYearGO.__le__()": "", "IndexYearGO.__lt__()": "", "IndexYearGO.__matmul__()": "", "IndexYearGO.__mod__()": "", "IndexYearGO.__mul__()": "", "IndexYearGO.__ne__()": "", "IndexYearGO.__or__()": "", "IndexYearGO.__pow__()": "", "IndexYearGO.__radd__()": "", "IndexYearGO.__rfloordiv__()": "", "IndexYearGO.__rmatmul__()": "", "IndexYearGO.__rmul__()": "", "IndexYearGO.__rshift__()": "", "IndexYearGO.__rsub__()": "", "IndexYearGO.__rtruediv__()": "", "IndexYearGO.__sub__()": "", "IndexYearGO.__truediv__()": "", "IndexYearGO.__xor__()": "", "IndexYearGO.__abs__()": "", "IndexYearGO.__invert__()": "", "IndexYearGO.__neg__()": "", "IndexYearGO.__pos__()": "", "IndexYearGO.via_values.apply()": "", "IndexYearGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexYearGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexYearGO.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexYearGO.via_dt.year": "Return the year of each element.", "IndexYearGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexYearGO.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexYearGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexYearGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexYearGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexYearGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexYearGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexYearGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexYearGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexYearGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexYearGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexYearGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexYearGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexYearGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexYearGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexYearGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexYearGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexYearGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexYearGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexYearGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexYearGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexYearGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexYearGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexYearGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexYearGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexYearGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexYearGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexYearGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexYearGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexYearGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexYearGO.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexYearGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexYearGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexYearGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexYearGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexYearGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexYearGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexYearGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexYearGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexYearGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexYearGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexYearGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexYearGO.via_str.len()": "Return the length of the string.", "IndexYearGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexYearGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexYearGO.via_str.partition()": "Partition each element around sep.", "IndexYearGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexYearGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexYearGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexYearGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexYearGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexYearGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexYearGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexYearGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexYearGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexYearGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexYearGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexYearGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexYearGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexYearGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexYearGO.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexYearGO.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexYearGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexYearGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexYearGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexYearGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexYearGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexYearGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexYearGO.via_hashlib().md5()": "", "IndexYearGO.via_hashlib().sha256()": "", "IndexYearGO.via_hashlib().sha512()": "", "IndexYearGO.via_hashlib().sha3_256()": "", "IndexYearGO.via_hashlib().sha3_512()": "", "IndexYearGO.via_hashlib().shake_128()": "", "IndexYearGO.via_hashlib().shake_256()": "", "IndexYearGO.via_hashlib().blake2b()": "", "IndexYearGO.via_hashlib().blake2s()": "", "IndexYearGO.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexYearGO.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexYearGO.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexYearGO.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexYearGO.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexYearMonth.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexYearMonth.from_date_range()": "Get an IndexYearMonth instance over a range of dates, where start and stop is inclusive.", "IndexYearMonth.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexYearMonth.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexYearMonth.from_year_month_range()": "Get an IndexYearMonth instance over a range of months, where start and end are inclusive.", "IndexYearMonth.from_year_range()": "Get an IndexYearMonth instance over a range of years, where start and end are inclusive.", "IndexYearMonth.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexYearMonth.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexYearMonth.to_pandas()": "Return a Pandas Index.", "IndexYearMonth.to_series()": "Return a Series with values from this Index's labels.", "IndexYearMonth.to_visidata()": "Open an interactive VisiData session.", "IndexYearMonth.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexYearMonth.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexYearMonth.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexYearMonth.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexYearMonth.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexYearMonth.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexYearMonth.name": "A hashable label attached to this container. Returns: Hashable", "IndexYearMonth.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexYearMonth.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexYearMonth.ndim": "Return the number of dimensions. Returns: int", "IndexYearMonth.positions": "Return the immutable positions array.", "IndexYearMonth.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexYearMonth.size": "Return the size of the underlying NumPy array. Returns: int", "IndexYearMonth.__array__()": "Support the __array__ interface, returning an array of values.", "IndexYearMonth.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexYearMonth.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexYearMonth.__copy__()": "Return shallow copy of this Index.", "IndexYearMonth.__deepcopy__()": "", "IndexYearMonth.__len__()": "", "IndexYearMonth.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonth.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonth.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexYearMonth.copy()": "Return shallow copy of this Index.", "IndexYearMonth.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonth.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonth.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexYearMonth.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexYearMonth.dropna()": "Return a new Index after removing values of NaN or None.", "IndexYearMonth.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexYearMonth.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexYearMonth.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexYearMonth.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexYearMonth.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexYearMonth.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexYearMonth.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexYearMonth.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexYearMonth.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexYearMonth.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexYearMonth.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexYearMonth.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexYearMonth.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexYearMonth.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonth.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonth.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonth.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonth.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexYearMonth.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexYearMonth.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonth.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexYearMonth.rename()": "Return a new Frame with an updated name attribute.", "IndexYearMonth.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexYearMonth.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexYearMonth.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexYearMonth.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonth.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonth.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexYearMonth.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexYearMonth.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexYearMonth.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexYearMonth.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonth.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexYearMonth.__iter__()": "Iterate over labels.", "IndexYearMonth.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexYearMonth.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexYearMonth.interface": "A Frame documenting the interface of this class.", "IndexYearMonth.__repr__()": "", "IndexYearMonth.__str__()": "Return str(self).", "IndexYearMonth.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexYearMonth.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexYearMonth.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexYearMonth.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexYearMonth.drop.loc[]": "", "IndexYearMonth.[]": "Extract a new index given an iloc key.", "IndexYearMonth.iloc[]": "", "IndexYearMonth.loc[]": "", "IndexYearMonth.iter_label()": "", "IndexYearMonth.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexYearMonth.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexYearMonth.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexYearMonth.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexYearMonth.__add__()": "", "IndexYearMonth.__and__()": "", "IndexYearMonth.__eq__()": "", "IndexYearMonth.__floordiv__()": "", "IndexYearMonth.__ge__()": "", "IndexYearMonth.__gt__()": "", "IndexYearMonth.__le__()": "", "IndexYearMonth.__lt__()": "", "IndexYearMonth.__matmul__()": "", "IndexYearMonth.__mod__()": "", "IndexYearMonth.__mul__()": "", "IndexYearMonth.__ne__()": "", "IndexYearMonth.__or__()": "", "IndexYearMonth.__pow__()": "", "IndexYearMonth.__radd__()": "", "IndexYearMonth.__rfloordiv__()": "", "IndexYearMonth.__rmatmul__()": "", "IndexYearMonth.__rmul__()": "", "IndexYearMonth.__rshift__()": "", "IndexYearMonth.__rsub__()": "", "IndexYearMonth.__rtruediv__()": "", "IndexYearMonth.__sub__()": "", "IndexYearMonth.__truediv__()": "", "IndexYearMonth.__xor__()": "", "IndexYearMonth.__abs__()": "", "IndexYearMonth.__invert__()": "", "IndexYearMonth.__neg__()": "", "IndexYearMonth.__pos__()": "", "IndexYearMonth.via_values.apply()": "", "IndexYearMonth.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexYearMonth.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexYearMonth.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexYearMonth.via_dt.year": "Return the year of each element.", "IndexYearMonth.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexYearMonth.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexYearMonth.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexYearMonth.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexYearMonth.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexYearMonth.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexYearMonth.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexYearMonth.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexYearMonth.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexYearMonth.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexYearMonth.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexYearMonth.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexYearMonth.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexYearMonth.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexYearMonth.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexYearMonth.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexYearMonth.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexYearMonth.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexYearMonth.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexYearMonth.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexYearMonth.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexYearMonth.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexYearMonth.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexYearMonth.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexYearMonth.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexYearMonth.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexYearMonth.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexYearMonth.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexYearMonth.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexYearMonth.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexYearMonth.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexYearMonth.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexYearMonth.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexYearMonth.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexYearMonth.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexYearMonth.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexYearMonth.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexYearMonth.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexYearMonth.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexYearMonth.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexYearMonth.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexYearMonth.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexYearMonth.via_str.len()": "Return the length of the string.", "IndexYearMonth.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexYearMonth.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexYearMonth.via_str.partition()": "Partition each element around sep.", "IndexYearMonth.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexYearMonth.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexYearMonth.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexYearMonth.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexYearMonth.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexYearMonth.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexYearMonth.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexYearMonth.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexYearMonth.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexYearMonth.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexYearMonth.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexYearMonth.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexYearMonth.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexYearMonth.via_str.zfill()": "Return the string left-filled with zeros.", "IndexYearMonth.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexYearMonth.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexYearMonth.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexYearMonth.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexYearMonth.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexYearMonth.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexYearMonth.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexYearMonth.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexYearMonth.via_hashlib().md5()": "", "IndexYearMonth.via_hashlib().sha256()": "", "IndexYearMonth.via_hashlib().sha512()": "", "IndexYearMonth.via_hashlib().sha3_256()": "", "IndexYearMonth.via_hashlib().sha3_512()": "", "IndexYearMonth.via_hashlib().shake_128()": "", "IndexYearMonth.via_hashlib().shake_256()": "", "IndexYearMonth.via_hashlib().blake2b()": "", "IndexYearMonth.via_hashlib().blake2s()": "", "IndexYearMonth.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexYearMonth.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexYearMonth.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexYearMonth.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexYearMonth.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexYearMonthGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexYearMonthGO.from_date_range()": "Get an IndexYearMonth instance over a range of dates, where start and stop is inclusive.", "IndexYearMonthGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexYearMonthGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexYearMonthGO.from_year_month_range()": "Get an IndexYearMonth instance over a range of months, where start and end are inclusive.", "IndexYearMonthGO.from_year_range()": "Get an IndexYearMonth instance over a range of years, where start and end are inclusive.", "IndexYearMonthGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexYearMonthGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexYearMonthGO.to_pandas()": "Return a Pandas Index.", "IndexYearMonthGO.to_series()": "Return a Series with values from this Index's labels.", "IndexYearMonthGO.to_visidata()": "Open an interactive VisiData session.", "IndexYearMonthGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexYearMonthGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexYearMonthGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexYearMonthGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexYearMonthGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexYearMonthGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexYearMonthGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexYearMonthGO.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexYearMonthGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexYearMonthGO.ndim": "Return the number of dimensions. Returns: int", "IndexYearMonthGO.positions": "Return the immutable positions array.", "IndexYearMonthGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexYearMonthGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexYearMonthGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexYearMonthGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexYearMonthGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexYearMonthGO.__copy__()": "Return shallow copy of this Index.", "IndexYearMonthGO.__deepcopy__()": "", "IndexYearMonthGO.__len__()": "", "IndexYearMonthGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonthGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonthGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resolve_dtype with each addition; self._map is never None", "IndexYearMonthGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexYearMonthGO.copy()": "Return shallow copy of this Index.", "IndexYearMonthGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonthGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonthGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexYearMonthGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexYearMonthGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexYearMonthGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexYearMonthGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexYearMonthGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexYearMonthGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexYearMonthGO.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexYearMonthGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexYearMonthGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexYearMonthGO.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexYearMonthGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexYearMonthGO.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexYearMonthGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexYearMonthGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexYearMonthGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexYearMonthGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexYearMonthGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonthGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonthGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonthGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonthGO.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexYearMonthGO.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexYearMonthGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonthGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexYearMonthGO.rename()": "Return a new Frame with an updated name attribute.", "IndexYearMonthGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexYearMonthGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexYearMonthGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexYearMonthGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonthGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonthGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexYearMonthGO.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexYearMonthGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexYearMonthGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexYearMonthGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexYearMonthGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexYearMonthGO.__iter__()": "Iterate over labels.", "IndexYearMonthGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexYearMonthGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexYearMonthGO.interface": "A Frame documenting the interface of this class.", "IndexYearMonthGO.__repr__()": "", "IndexYearMonthGO.__str__()": "Return str(self).", "IndexYearMonthGO.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexYearMonthGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexYearMonthGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexYearMonthGO.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexYearMonthGO.drop.loc[]": "", "IndexYearMonthGO.[]": "Extract a new index given an iloc key.", "IndexYearMonthGO.iloc[]": "", "IndexYearMonthGO.loc[]": "", "IndexYearMonthGO.iter_label()": "", "IndexYearMonthGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexYearMonthGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexYearMonthGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexYearMonthGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexYearMonthGO.__add__()": "", "IndexYearMonthGO.__and__()": "", "IndexYearMonthGO.__eq__()": "", "IndexYearMonthGO.__floordiv__()": "", "IndexYearMonthGO.__ge__()": "", "IndexYearMonthGO.__gt__()": "", "IndexYearMonthGO.__le__()": "", "IndexYearMonthGO.__lt__()": "", "IndexYearMonthGO.__matmul__()": "", "IndexYearMonthGO.__mod__()": "", "IndexYearMonthGO.__mul__()": "", "IndexYearMonthGO.__ne__()": "", "IndexYearMonthGO.__or__()": "", "IndexYearMonthGO.__pow__()": "", "IndexYearMonthGO.__radd__()": "", "IndexYearMonthGO.__rfloordiv__()": "", "IndexYearMonthGO.__rmatmul__()": "", "IndexYearMonthGO.__rmul__()": "", "IndexYearMonthGO.__rshift__()": "", "IndexYearMonthGO.__rsub__()": "", "IndexYearMonthGO.__rtruediv__()": "", "IndexYearMonthGO.__sub__()": "", "IndexYearMonthGO.__truediv__()": "", "IndexYearMonthGO.__xor__()": "", "IndexYearMonthGO.__abs__()": "", "IndexYearMonthGO.__invert__()": "", "IndexYearMonthGO.__neg__()": "", "IndexYearMonthGO.__pos__()": "", "IndexYearMonthGO.via_values.apply()": "", "IndexYearMonthGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexYearMonthGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexYearMonthGO.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexYearMonthGO.via_dt.year": "Return the year of each element.", "IndexYearMonthGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexYearMonthGO.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexYearMonthGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexYearMonthGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexYearMonthGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexYearMonthGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexYearMonthGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexYearMonthGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexYearMonthGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexYearMonthGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexYearMonthGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexYearMonthGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexYearMonthGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexYearMonthGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexYearMonthGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexYearMonthGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexYearMonthGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexYearMonthGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexYearMonthGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexYearMonthGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexYearMonthGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexYearMonthGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexYearMonthGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexYearMonthGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexYearMonthGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexYearMonthGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexYearMonthGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexYearMonthGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexYearMonthGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexYearMonthGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexYearMonthGO.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexYearMonthGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexYearMonthGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexYearMonthGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexYearMonthGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexYearMonthGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexYearMonthGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexYearMonthGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexYearMonthGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexYearMonthGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexYearMonthGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexYearMonthGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexYearMonthGO.via_str.len()": "Return the length of the string.", "IndexYearMonthGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexYearMonthGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexYearMonthGO.via_str.partition()": "Partition each element around sep.", "IndexYearMonthGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexYearMonthGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexYearMonthGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexYearMonthGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexYearMonthGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexYearMonthGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexYearMonthGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexYearMonthGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexYearMonthGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexYearMonthGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexYearMonthGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexYearMonthGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexYearMonthGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexYearMonthGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexYearMonthGO.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexYearMonthGO.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexYearMonthGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexYearMonthGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexYearMonthGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexYearMonthGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexYearMonthGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexYearMonthGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexYearMonthGO.via_hashlib().md5()": "", "IndexYearMonthGO.via_hashlib().sha256()": "", "IndexYearMonthGO.via_hashlib().sha512()": "", "IndexYearMonthGO.via_hashlib().sha3_256()": "", "IndexYearMonthGO.via_hashlib().sha3_512()": "", "IndexYearMonthGO.via_hashlib().shake_128()": "", "IndexYearMonthGO.via_hashlib().shake_256()": "", "IndexYearMonthGO.via_hashlib().blake2b()": "", "IndexYearMonthGO.via_hashlib().blake2s()": "", "IndexYearMonthGO.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexYearMonthGO.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexYearMonthGO.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexYearMonthGO.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexYearMonthGO.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexDate.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexDate.from_date_range()": "Get an IndexDate instance over a range of dates, where start and stop is inclusive.", "IndexDate.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexDate.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexDate.from_year_month_range()": "Get an IndexDate instance over a range of months, where start and end are inclusive.", "IndexDate.from_year_range()": "Get an IndexDate instance over a range of years, where start and end are inclusive.", "IndexDate.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexDate.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexDate.to_pandas()": "Return a Pandas Index.", "IndexDate.to_series()": "Return a Series with values from this Index's labels.", "IndexDate.to_visidata()": "Open an interactive VisiData session.", "IndexDate.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexDate.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexDate.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexDate.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexDate.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexDate.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexDate.name": "A hashable label attached to this container. Returns: Hashable", "IndexDate.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexDate.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexDate.ndim": "Return the number of dimensions. Returns: int", "IndexDate.positions": "Return the immutable positions array.", "IndexDate.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexDate.size": "Return the size of the underlying NumPy array. Returns: int", "IndexDate.__array__()": "Support the __array__ interface, returning an array of values.", "IndexDate.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexDate.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexDate.__copy__()": "Return shallow copy of this Index.", "IndexDate.__deepcopy__()": "", "IndexDate.__len__()": "", "IndexDate.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDate.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDate.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexDate.copy()": "Return shallow copy of this Index.", "IndexDate.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDate.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDate.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexDate.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexDate.dropna()": "Return a new Index after removing values of NaN or None.", "IndexDate.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexDate.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexDate.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexDate.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexDate.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexDate.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexDate.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexDate.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexDate.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexDate.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexDate.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexDate.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexDate.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexDate.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDate.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDate.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDate.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDate.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexDate.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexDate.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDate.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexDate.rename()": "Return a new Frame with an updated name attribute.", "IndexDate.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexDate.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexDate.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexDate.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDate.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDate.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexDate.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexDate.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexDate.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexDate.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDate.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexDate.__iter__()": "Iterate over labels.", "IndexDate.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexDate.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexDate.interface": "A Frame documenting the interface of this class.", "IndexDate.__repr__()": "", "IndexDate.__str__()": "Return str(self).", "IndexDate.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexDate.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexDate.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexDate.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexDate.drop.loc[]": "", "IndexDate.[]": "Extract a new index given an iloc key.", "IndexDate.iloc[]": "", "IndexDate.loc[]": "", "IndexDate.iter_label()": "", "IndexDate.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexDate.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexDate.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexDate.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexDate.__add__()": "", "IndexDate.__and__()": "", "IndexDate.__eq__()": "", "IndexDate.__floordiv__()": "", "IndexDate.__ge__()": "", "IndexDate.__gt__()": "", "IndexDate.__le__()": "", "IndexDate.__lt__()": "", "IndexDate.__matmul__()": "", "IndexDate.__mod__()": "", "IndexDate.__mul__()": "", "IndexDate.__ne__()": "", "IndexDate.__or__()": "", "IndexDate.__pow__()": "", "IndexDate.__radd__()": "", "IndexDate.__rfloordiv__()": "", "IndexDate.__rmatmul__()": "", "IndexDate.__rmul__()": "", "IndexDate.__rshift__()": "", "IndexDate.__rsub__()": "", "IndexDate.__rtruediv__()": "", "IndexDate.__sub__()": "", "IndexDate.__truediv__()": "", "IndexDate.__xor__()": "", "IndexDate.__abs__()": "", "IndexDate.__invert__()": "", "IndexDate.__neg__()": "", "IndexDate.__pos__()": "", "IndexDate.via_values.apply()": "", "IndexDate.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexDate.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexDate.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexDate.via_dt.year": "Return the year of each element.", "IndexDate.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexDate.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexDate.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexDate.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexDate.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexDate.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexDate.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexDate.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexDate.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexDate.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexDate.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexDate.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexDate.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexDate.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexDate.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexDate.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexDate.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexDate.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexDate.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexDate.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexDate.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexDate.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexDate.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexDate.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexDate.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexDate.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexDate.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexDate.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexDate.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexDate.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexDate.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexDate.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexDate.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexDate.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexDate.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexDate.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexDate.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexDate.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexDate.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexDate.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexDate.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexDate.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexDate.via_str.len()": "Return the length of the string.", "IndexDate.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexDate.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexDate.via_str.partition()": "Partition each element around sep.", "IndexDate.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexDate.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexDate.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexDate.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexDate.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexDate.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexDate.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexDate.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexDate.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexDate.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexDate.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexDate.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexDate.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexDate.via_str.zfill()": "Return the string left-filled with zeros.", "IndexDate.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexDate.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexDate.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexDate.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexDate.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexDate.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexDate.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexDate.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexDate.via_hashlib().md5()": "", "IndexDate.via_hashlib().sha256()": "", "IndexDate.via_hashlib().sha512()": "", "IndexDate.via_hashlib().sha3_256()": "", "IndexDate.via_hashlib().sha3_512()": "", "IndexDate.via_hashlib().shake_128()": "", "IndexDate.via_hashlib().shake_256()": "", "IndexDate.via_hashlib().blake2b()": "", "IndexDate.via_hashlib().blake2s()": "", "IndexDate.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexDate.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexDate.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexDate.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexDate.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexDateGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexDateGO.from_date_range()": "Get an IndexDate instance over a range of dates, where start and stop is inclusive.", "IndexDateGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexDateGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexDateGO.from_year_month_range()": "Get an IndexDate instance over a range of months, where start and end are inclusive.", "IndexDateGO.from_year_range()": "Get an IndexDate instance over a range of years, where start and end are inclusive.", "IndexDateGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexDateGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexDateGO.to_pandas()": "Return a Pandas Index.", "IndexDateGO.to_series()": "Return a Series with values from this Index's labels.", "IndexDateGO.to_visidata()": "Open an interactive VisiData session.", "IndexDateGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexDateGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexDateGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexDateGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexDateGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexDateGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexDateGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexDateGO.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexDateGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexDateGO.ndim": "Return the number of dimensions. Returns: int", "IndexDateGO.positions": "Return the immutable positions array.", "IndexDateGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexDateGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexDateGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexDateGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexDateGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexDateGO.__copy__()": "Return shallow copy of this Index.", "IndexDateGO.__deepcopy__()": "", "IndexDateGO.__len__()": "", "IndexDateGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDateGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDateGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resolve_dtype with each addition; self._map is never None", "IndexDateGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexDateGO.copy()": "Return shallow copy of this Index.", "IndexDateGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDateGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDateGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexDateGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexDateGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexDateGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexDateGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexDateGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexDateGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexDateGO.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexDateGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexDateGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexDateGO.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexDateGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexDateGO.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexDateGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexDateGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexDateGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexDateGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexDateGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDateGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDateGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDateGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDateGO.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexDateGO.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexDateGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDateGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexDateGO.rename()": "Return a new Frame with an updated name attribute.", "IndexDateGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexDateGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexDateGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexDateGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDateGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDateGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexDateGO.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexDateGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexDateGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexDateGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexDateGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexDateGO.__iter__()": "Iterate over labels.", "IndexDateGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexDateGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexDateGO.interface": "A Frame documenting the interface of this class.", "IndexDateGO.__repr__()": "", "IndexDateGO.__str__()": "Return str(self).", "IndexDateGO.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexDateGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexDateGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexDateGO.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexDateGO.drop.loc[]": "", "IndexDateGO.[]": "Extract a new index given an iloc key.", "IndexDateGO.iloc[]": "", "IndexDateGO.loc[]": "", "IndexDateGO.iter_label()": "", "IndexDateGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexDateGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexDateGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexDateGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexDateGO.__add__()": "", "IndexDateGO.__and__()": "", "IndexDateGO.__eq__()": "", "IndexDateGO.__floordiv__()": "", "IndexDateGO.__ge__()": "", "IndexDateGO.__gt__()": "", "IndexDateGO.__le__()": "", "IndexDateGO.__lt__()": "", "IndexDateGO.__matmul__()": "", "IndexDateGO.__mod__()": "", "IndexDateGO.__mul__()": "", "IndexDateGO.__ne__()": "", "IndexDateGO.__or__()": "", "IndexDateGO.__pow__()": "", "IndexDateGO.__radd__()": "", "IndexDateGO.__rfloordiv__()": "", "IndexDateGO.__rmatmul__()": "", "IndexDateGO.__rmul__()": "", "IndexDateGO.__rshift__()": "", "IndexDateGO.__rsub__()": "", "IndexDateGO.__rtruediv__()": "", "IndexDateGO.__sub__()": "", "IndexDateGO.__truediv__()": "", "IndexDateGO.__xor__()": "", "IndexDateGO.__abs__()": "", "IndexDateGO.__invert__()": "", "IndexDateGO.__neg__()": "", "IndexDateGO.__pos__()": "", "IndexDateGO.via_values.apply()": "", "IndexDateGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexDateGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexDateGO.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexDateGO.via_dt.year": "Return the year of each element.", "IndexDateGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexDateGO.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexDateGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexDateGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexDateGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexDateGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexDateGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexDateGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexDateGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexDateGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexDateGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexDateGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexDateGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexDateGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexDateGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexDateGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexDateGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexDateGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexDateGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexDateGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexDateGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexDateGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexDateGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexDateGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexDateGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexDateGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexDateGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexDateGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexDateGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexDateGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexDateGO.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexDateGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexDateGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexDateGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexDateGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexDateGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexDateGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexDateGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexDateGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexDateGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexDateGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexDateGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexDateGO.via_str.len()": "Return the length of the string.", "IndexDateGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexDateGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexDateGO.via_str.partition()": "Partition each element around sep.", "IndexDateGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexDateGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexDateGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexDateGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexDateGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexDateGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexDateGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexDateGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexDateGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexDateGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexDateGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexDateGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexDateGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexDateGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexDateGO.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexDateGO.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexDateGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexDateGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexDateGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexDateGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexDateGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexDateGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexDateGO.via_hashlib().md5()": "", "IndexDateGO.via_hashlib().sha256()": "", "IndexDateGO.via_hashlib().sha512()": "", "IndexDateGO.via_hashlib().sha3_256()": "", "IndexDateGO.via_hashlib().sha3_512()": "", "IndexDateGO.via_hashlib().shake_128()": "", "IndexDateGO.via_hashlib().shake_256()": "", "IndexDateGO.via_hashlib().blake2b()": "", "IndexDateGO.via_hashlib().blake2s()": "", "IndexDateGO.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexDateGO.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexDateGO.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexDateGO.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexDateGO.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexMinute.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexMinute.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexMinute.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexMinute.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexMinute.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexMinute.to_pandas()": "Return a Pandas Index.", "IndexMinute.to_series()": "Return a Series with values from this Index's labels.", "IndexMinute.to_visidata()": "Open an interactive VisiData session.", "IndexMinute.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexMinute.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexMinute.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexMinute.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexMinute.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexMinute.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexMinute.name": "A hashable label attached to this container. Returns: Hashable", "IndexMinute.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexMinute.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexMinute.ndim": "Return the number of dimensions. Returns: int", "IndexMinute.positions": "Return the immutable positions array.", "IndexMinute.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexMinute.size": "Return the size of the underlying NumPy array. Returns: int", "IndexMinute.__array__()": "Support the __array__ interface, returning an array of values.", "IndexMinute.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexMinute.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexMinute.__copy__()": "Return shallow copy of this Index.", "IndexMinute.__deepcopy__()": "", "IndexMinute.__len__()": "", "IndexMinute.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinute.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinute.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexMinute.copy()": "Return shallow copy of this Index.", "IndexMinute.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinute.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinute.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexMinute.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexMinute.dropna()": "Return a new Index after removing values of NaN or None.", "IndexMinute.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexMinute.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexMinute.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexMinute.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexMinute.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexMinute.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexMinute.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexMinute.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexMinute.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexMinute.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexMinute.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexMinute.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexMinute.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexMinute.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinute.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinute.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinute.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinute.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexMinute.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexMinute.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinute.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexMinute.rename()": "Return a new Frame with an updated name attribute.", "IndexMinute.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexMinute.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexMinute.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexMinute.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinute.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinute.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexMinute.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexMinute.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexMinute.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexMinute.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinute.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexMinute.__iter__()": "Iterate over labels.", "IndexMinute.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexMinute.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexMinute.interface": "A Frame documenting the interface of this class.", "IndexMinute.__repr__()": "", "IndexMinute.__str__()": "Return str(self).", "IndexMinute.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMinute.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMinute.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMinute.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexMinute.drop.loc[]": "", "IndexMinute.[]": "Extract a new index given an iloc key.", "IndexMinute.iloc[]": "", "IndexMinute.loc[]": "", "IndexMinute.iter_label()": "", "IndexMinute.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexMinute.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexMinute.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexMinute.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexMinute.__add__()": "", "IndexMinute.__and__()": "", "IndexMinute.__eq__()": "", "IndexMinute.__floordiv__()": "", "IndexMinute.__ge__()": "", "IndexMinute.__gt__()": "", "IndexMinute.__le__()": "", "IndexMinute.__lt__()": "", "IndexMinute.__matmul__()": "", "IndexMinute.__mod__()": "", "IndexMinute.__mul__()": "", "IndexMinute.__ne__()": "", "IndexMinute.__or__()": "", "IndexMinute.__pow__()": "", "IndexMinute.__radd__()": "", "IndexMinute.__rfloordiv__()": "", "IndexMinute.__rmatmul__()": "", "IndexMinute.__rmul__()": "", "IndexMinute.__rshift__()": "", "IndexMinute.__rsub__()": "", "IndexMinute.__rtruediv__()": "", "IndexMinute.__sub__()": "", "IndexMinute.__truediv__()": "", "IndexMinute.__xor__()": "", "IndexMinute.__abs__()": "", "IndexMinute.__invert__()": "", "IndexMinute.__neg__()": "", "IndexMinute.__pos__()": "", "IndexMinute.via_values.apply()": "", "IndexMinute.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexMinute.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexMinute.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexMinute.via_dt.year": "Return the year of each element.", "IndexMinute.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexMinute.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexMinute.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexMinute.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexMinute.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexMinute.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexMinute.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexMinute.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexMinute.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexMinute.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexMinute.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexMinute.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexMinute.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexMinute.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexMinute.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexMinute.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexMinute.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexMinute.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexMinute.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexMinute.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexMinute.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexMinute.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexMinute.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexMinute.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexMinute.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexMinute.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexMinute.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexMinute.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexMinute.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexMinute.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexMinute.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexMinute.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexMinute.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexMinute.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexMinute.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexMinute.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexMinute.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexMinute.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexMinute.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexMinute.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexMinute.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexMinute.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexMinute.via_str.len()": "Return the length of the string.", "IndexMinute.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexMinute.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexMinute.via_str.partition()": "Partition each element around sep.", "IndexMinute.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexMinute.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexMinute.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexMinute.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexMinute.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexMinute.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexMinute.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexMinute.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexMinute.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexMinute.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexMinute.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMinute.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMinute.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMinute.via_str.zfill()": "Return the string left-filled with zeros.", "IndexMinute.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMinute.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMinute.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMinute.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexMinute.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMinute.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexMinute.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexMinute.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexMinute.via_hashlib().md5()": "", "IndexMinute.via_hashlib().sha256()": "", "IndexMinute.via_hashlib().sha512()": "", "IndexMinute.via_hashlib().sha3_256()": "", "IndexMinute.via_hashlib().sha3_512()": "", "IndexMinute.via_hashlib().shake_128()": "", "IndexMinute.via_hashlib().shake_256()": "", "IndexMinute.via_hashlib().blake2b()": "", "IndexMinute.via_hashlib().blake2s()": "", "IndexMinute.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexMinute.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexMinute.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexMinute.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexMinute.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexMinuteGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexMinuteGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexMinuteGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexMinuteGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexMinuteGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexMinuteGO.to_pandas()": "Return a Pandas Index.", "IndexMinuteGO.to_series()": "Return a Series with values from this Index's labels.", "IndexMinuteGO.to_visidata()": "Open an interactive VisiData session.", "IndexMinuteGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexMinuteGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexMinuteGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexMinuteGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexMinuteGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexMinuteGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexMinuteGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexMinuteGO.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexMinuteGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexMinuteGO.ndim": "Return the number of dimensions. Returns: int", "IndexMinuteGO.positions": "Return the immutable positions array.", "IndexMinuteGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexMinuteGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexMinuteGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexMinuteGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexMinuteGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexMinuteGO.__copy__()": "Return shallow copy of this Index.", "IndexMinuteGO.__deepcopy__()": "", "IndexMinuteGO.__len__()": "", "IndexMinuteGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinuteGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinuteGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resolve_dtype with each addition; self._map is never None", "IndexMinuteGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexMinuteGO.copy()": "Return shallow copy of this Index.", "IndexMinuteGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinuteGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinuteGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexMinuteGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexMinuteGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexMinuteGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexMinuteGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexMinuteGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexMinuteGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexMinuteGO.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexMinuteGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexMinuteGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexMinuteGO.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexMinuteGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexMinuteGO.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexMinuteGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexMinuteGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexMinuteGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexMinuteGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexMinuteGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinuteGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinuteGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinuteGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinuteGO.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexMinuteGO.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexMinuteGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinuteGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexMinuteGO.rename()": "Return a new Frame with an updated name attribute.", "IndexMinuteGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexMinuteGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexMinuteGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexMinuteGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinuteGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinuteGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexMinuteGO.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexMinuteGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexMinuteGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexMinuteGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMinuteGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexMinuteGO.__iter__()": "Iterate over labels.", "IndexMinuteGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexMinuteGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexMinuteGO.interface": "A Frame documenting the interface of this class.", "IndexMinuteGO.__repr__()": "", "IndexMinuteGO.__str__()": "Return str(self).", "IndexMinuteGO.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMinuteGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMinuteGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMinuteGO.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexMinuteGO.drop.loc[]": "", "IndexMinuteGO.[]": "Extract a new index given an iloc key.", "IndexMinuteGO.iloc[]": "", "IndexMinuteGO.loc[]": "", "IndexMinuteGO.iter_label()": "", "IndexMinuteGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexMinuteGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexMinuteGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexMinuteGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexMinuteGO.__add__()": "", "IndexMinuteGO.__and__()": "", "IndexMinuteGO.__eq__()": "", "IndexMinuteGO.__floordiv__()": "", "IndexMinuteGO.__ge__()": "", "IndexMinuteGO.__gt__()": "", "IndexMinuteGO.__le__()": "", "IndexMinuteGO.__lt__()": "", "IndexMinuteGO.__matmul__()": "", "IndexMinuteGO.__mod__()": "", "IndexMinuteGO.__mul__()": "", "IndexMinuteGO.__ne__()": "", "IndexMinuteGO.__or__()": "", "IndexMinuteGO.__pow__()": "", "IndexMinuteGO.__radd__()": "", "IndexMinuteGO.__rfloordiv__()": "", "IndexMinuteGO.__rmatmul__()": "", "IndexMinuteGO.__rmul__()": "", "IndexMinuteGO.__rshift__()": "", "IndexMinuteGO.__rsub__()": "", "IndexMinuteGO.__rtruediv__()": "", "IndexMinuteGO.__sub__()": "", "IndexMinuteGO.__truediv__()": "", "IndexMinuteGO.__xor__()": "", "IndexMinuteGO.__abs__()": "", "IndexMinuteGO.__invert__()": "", "IndexMinuteGO.__neg__()": "", "IndexMinuteGO.__pos__()": "", "IndexMinuteGO.via_values.apply()": "", "IndexMinuteGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexMinuteGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexMinuteGO.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexMinuteGO.via_dt.year": "Return the year of each element.", "IndexMinuteGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexMinuteGO.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexMinuteGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexMinuteGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexMinuteGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexMinuteGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexMinuteGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexMinuteGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexMinuteGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexMinuteGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexMinuteGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexMinuteGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexMinuteGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexMinuteGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexMinuteGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexMinuteGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexMinuteGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexMinuteGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexMinuteGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexMinuteGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexMinuteGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexMinuteGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexMinuteGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexMinuteGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexMinuteGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexMinuteGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexMinuteGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexMinuteGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexMinuteGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexMinuteGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexMinuteGO.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexMinuteGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexMinuteGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexMinuteGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexMinuteGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexMinuteGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexMinuteGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexMinuteGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexMinuteGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexMinuteGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexMinuteGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexMinuteGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexMinuteGO.via_str.len()": "Return the length of the string.", "IndexMinuteGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexMinuteGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexMinuteGO.via_str.partition()": "Partition each element around sep.", "IndexMinuteGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexMinuteGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexMinuteGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexMinuteGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexMinuteGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexMinuteGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexMinuteGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexMinuteGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexMinuteGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexMinuteGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexMinuteGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMinuteGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMinuteGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMinuteGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexMinuteGO.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMinuteGO.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMinuteGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMinuteGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexMinuteGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMinuteGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexMinuteGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexMinuteGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexMinuteGO.via_hashlib().md5()": "", "IndexMinuteGO.via_hashlib().sha256()": "", "IndexMinuteGO.via_hashlib().sha512()": "", "IndexMinuteGO.via_hashlib().sha3_256()": "", "IndexMinuteGO.via_hashlib().sha3_512()": "", "IndexMinuteGO.via_hashlib().shake_128()": "", "IndexMinuteGO.via_hashlib().shake_256()": "", "IndexMinuteGO.via_hashlib().blake2b()": "", "IndexMinuteGO.via_hashlib().blake2s()": "", "IndexMinuteGO.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexMinuteGO.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexMinuteGO.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexMinuteGO.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexMinuteGO.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexHour.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexHour.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexHour.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexHour.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexHour.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexHour.to_pandas()": "Return a Pandas Index.", "IndexHour.to_series()": "Return a Series with values from this Index's labels.", "IndexHour.to_visidata()": "Open an interactive VisiData session.", "IndexHour.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexHour.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexHour.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexHour.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexHour.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexHour.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexHour.name": "A hashable label attached to this container. Returns: Hashable", "IndexHour.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexHour.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexHour.ndim": "Return the number of dimensions. Returns: int", "IndexHour.positions": "Return the immutable positions array.", "IndexHour.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexHour.size": "Return the size of the underlying NumPy array. Returns: int", "IndexHour.__array__()": "Support the __array__ interface, returning an array of values.", "IndexHour.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexHour.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexHour.__copy__()": "Return shallow copy of this Index.", "IndexHour.__deepcopy__()": "", "IndexHour.__len__()": "", "IndexHour.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHour.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHour.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexHour.copy()": "Return shallow copy of this Index.", "IndexHour.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHour.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHour.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexHour.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexHour.dropna()": "Return a new Index after removing values of NaN or None.", "IndexHour.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexHour.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexHour.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexHour.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexHour.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexHour.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexHour.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexHour.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexHour.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexHour.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexHour.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexHour.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexHour.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexHour.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHour.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHour.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHour.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHour.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexHour.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexHour.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHour.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexHour.rename()": "Return a new Frame with an updated name attribute.", "IndexHour.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexHour.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexHour.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexHour.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHour.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHour.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexHour.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexHour.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexHour.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexHour.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHour.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexHour.__iter__()": "Iterate over labels.", "IndexHour.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexHour.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexHour.interface": "A Frame documenting the interface of this class.", "IndexHour.__repr__()": "", "IndexHour.__str__()": "Return str(self).", "IndexHour.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexHour.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexHour.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexHour.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexHour.drop.loc[]": "", "IndexHour.[]": "Extract a new index given an iloc key.", "IndexHour.iloc[]": "", "IndexHour.loc[]": "", "IndexHour.iter_label()": "", "IndexHour.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexHour.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexHour.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexHour.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexHour.__add__()": "", "IndexHour.__and__()": "", "IndexHour.__eq__()": "", "IndexHour.__floordiv__()": "", "IndexHour.__ge__()": "", "IndexHour.__gt__()": "", "IndexHour.__le__()": "", "IndexHour.__lt__()": "", "IndexHour.__matmul__()": "", "IndexHour.__mod__()": "", "IndexHour.__mul__()": "", "IndexHour.__ne__()": "", "IndexHour.__or__()": "", "IndexHour.__pow__()": "", "IndexHour.__radd__()": "", "IndexHour.__rfloordiv__()": "", "IndexHour.__rmatmul__()": "", "IndexHour.__rmul__()": "", "IndexHour.__rshift__()": "", "IndexHour.__rsub__()": "", "IndexHour.__rtruediv__()": "", "IndexHour.__sub__()": "", "IndexHour.__truediv__()": "", "IndexHour.__xor__()": "", "IndexHour.__abs__()": "", "IndexHour.__invert__()": "", "IndexHour.__neg__()": "", "IndexHour.__pos__()": "", "IndexHour.via_values.apply()": "", "IndexHour.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexHour.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexHour.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexHour.via_dt.year": "Return the year of each element.", "IndexHour.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexHour.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexHour.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexHour.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexHour.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexHour.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexHour.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexHour.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexHour.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexHour.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexHour.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexHour.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexHour.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexHour.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexHour.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexHour.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexHour.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexHour.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexHour.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexHour.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexHour.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexHour.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexHour.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexHour.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexHour.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexHour.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexHour.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexHour.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexHour.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexHour.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexHour.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexHour.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexHour.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexHour.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexHour.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexHour.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexHour.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexHour.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexHour.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexHour.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexHour.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexHour.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexHour.via_str.len()": "Return the length of the string.", "IndexHour.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexHour.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexHour.via_str.partition()": "Partition each element around sep.", "IndexHour.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexHour.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexHour.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexHour.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexHour.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexHour.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexHour.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexHour.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexHour.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexHour.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexHour.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexHour.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexHour.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexHour.via_str.zfill()": "Return the string left-filled with zeros.", "IndexHour.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexHour.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexHour.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexHour.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexHour.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexHour.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexHour.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexHour.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexHour.via_hashlib().md5()": "", "IndexHour.via_hashlib().sha256()": "", "IndexHour.via_hashlib().sha512()": "", "IndexHour.via_hashlib().sha3_256()": "", "IndexHour.via_hashlib().sha3_512()": "", "IndexHour.via_hashlib().shake_128()": "", "IndexHour.via_hashlib().shake_256()": "", "IndexHour.via_hashlib().blake2b()": "", "IndexHour.via_hashlib().blake2s()": "", "IndexHour.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexHour.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexHour.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexHour.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexHour.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexHourGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexHourGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexHourGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexHourGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexHourGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexHourGO.to_pandas()": "Return a Pandas Index.", "IndexHourGO.to_series()": "Return a Series with values from this Index's labels.", "IndexHourGO.to_visidata()": "Open an interactive VisiData session.", "IndexHourGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexHourGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexHourGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexHourGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexHourGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexHourGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexHourGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexHourGO.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexHourGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexHourGO.ndim": "Return the number of dimensions. Returns: int", "IndexHourGO.positions": "Return the immutable positions array.", "IndexHourGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexHourGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexHourGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexHourGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexHourGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexHourGO.__copy__()": "Return shallow copy of this Index.", "IndexHourGO.__deepcopy__()": "", "IndexHourGO.__len__()": "", "IndexHourGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHourGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHourGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resolve_dtype with each addition; self._map is never None", "IndexHourGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexHourGO.copy()": "Return shallow copy of this Index.", "IndexHourGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHourGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHourGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexHourGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexHourGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexHourGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexHourGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexHourGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexHourGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexHourGO.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexHourGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexHourGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexHourGO.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexHourGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexHourGO.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexHourGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexHourGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexHourGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexHourGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexHourGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHourGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHourGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHourGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHourGO.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexHourGO.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexHourGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHourGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexHourGO.rename()": "Return a new Frame with an updated name attribute.", "IndexHourGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexHourGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexHourGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexHourGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHourGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHourGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexHourGO.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexHourGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexHourGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexHourGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexHourGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexHourGO.__iter__()": "Iterate over labels.", "IndexHourGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexHourGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexHourGO.interface": "A Frame documenting the interface of this class.", "IndexHourGO.__repr__()": "", "IndexHourGO.__str__()": "Return str(self).", "IndexHourGO.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexHourGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexHourGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexHourGO.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexHourGO.drop.loc[]": "", "IndexHourGO.[]": "Extract a new index given an iloc key.", "IndexHourGO.iloc[]": "", "IndexHourGO.loc[]": "", "IndexHourGO.iter_label()": "", "IndexHourGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexHourGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexHourGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexHourGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexHourGO.__add__()": "", "IndexHourGO.__and__()": "", "IndexHourGO.__eq__()": "", "IndexHourGO.__floordiv__()": "", "IndexHourGO.__ge__()": "", "IndexHourGO.__gt__()": "", "IndexHourGO.__le__()": "", "IndexHourGO.__lt__()": "", "IndexHourGO.__matmul__()": "", "IndexHourGO.__mod__()": "", "IndexHourGO.__mul__()": "", "IndexHourGO.__ne__()": "", "IndexHourGO.__or__()": "", "IndexHourGO.__pow__()": "", "IndexHourGO.__radd__()": "", "IndexHourGO.__rfloordiv__()": "", "IndexHourGO.__rmatmul__()": "", "IndexHourGO.__rmul__()": "", "IndexHourGO.__rshift__()": "", "IndexHourGO.__rsub__()": "", "IndexHourGO.__rtruediv__()": "", "IndexHourGO.__sub__()": "", "IndexHourGO.__truediv__()": "", "IndexHourGO.__xor__()": "", "IndexHourGO.__abs__()": "", "IndexHourGO.__invert__()": "", "IndexHourGO.__neg__()": "", "IndexHourGO.__pos__()": "", "IndexHourGO.via_values.apply()": "", "IndexHourGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexHourGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexHourGO.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexHourGO.via_dt.year": "Return the year of each element.", "IndexHourGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexHourGO.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexHourGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexHourGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexHourGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexHourGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexHourGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexHourGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexHourGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexHourGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexHourGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexHourGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexHourGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexHourGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexHourGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexHourGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexHourGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexHourGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexHourGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexHourGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexHourGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexHourGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexHourGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexHourGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexHourGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexHourGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexHourGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexHourGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexHourGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexHourGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexHourGO.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexHourGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexHourGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexHourGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexHourGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexHourGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexHourGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexHourGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexHourGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexHourGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexHourGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexHourGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexHourGO.via_str.len()": "Return the length of the string.", "IndexHourGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexHourGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexHourGO.via_str.partition()": "Partition each element around sep.", "IndexHourGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexHourGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexHourGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexHourGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexHourGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexHourGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexHourGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexHourGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexHourGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexHourGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexHourGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexHourGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexHourGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexHourGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexHourGO.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexHourGO.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexHourGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexHourGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexHourGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexHourGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexHourGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexHourGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexHourGO.via_hashlib().md5()": "", "IndexHourGO.via_hashlib().sha256()": "", "IndexHourGO.via_hashlib().sha512()": "", "IndexHourGO.via_hashlib().sha3_256()": "", "IndexHourGO.via_hashlib().sha3_512()": "", "IndexHourGO.via_hashlib().shake_128()": "", "IndexHourGO.via_hashlib().shake_256()": "", "IndexHourGO.via_hashlib().blake2b()": "", "IndexHourGO.via_hashlib().blake2s()": "", "IndexHourGO.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexHourGO.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexHourGO.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexHourGO.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexHourGO.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexSecond.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexSecond.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexSecond.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexSecond.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexSecond.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexSecond.to_pandas()": "Return a Pandas Index.", "IndexSecond.to_series()": "Return a Series with values from this Index's labels.", "IndexSecond.to_visidata()": "Open an interactive VisiData session.", "IndexSecond.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexSecond.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexSecond.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexSecond.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexSecond.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexSecond.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexSecond.name": "A hashable label attached to this container. Returns: Hashable", "IndexSecond.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexSecond.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexSecond.ndim": "Return the number of dimensions. Returns: int", "IndexSecond.positions": "Return the immutable positions array.", "IndexSecond.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexSecond.size": "Return the size of the underlying NumPy array. Returns: int", "IndexSecond.__array__()": "Support the __array__ interface, returning an array of values.", "IndexSecond.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexSecond.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexSecond.__copy__()": "Return shallow copy of this Index.", "IndexSecond.__deepcopy__()": "", "IndexSecond.__len__()": "", "IndexSecond.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecond.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecond.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexSecond.copy()": "Return shallow copy of this Index.", "IndexSecond.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecond.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecond.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexSecond.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexSecond.dropna()": "Return a new Index after removing values of NaN or None.", "IndexSecond.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexSecond.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexSecond.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexSecond.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexSecond.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexSecond.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexSecond.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexSecond.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexSecond.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexSecond.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexSecond.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexSecond.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexSecond.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexSecond.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecond.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecond.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecond.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecond.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexSecond.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexSecond.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecond.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexSecond.rename()": "Return a new Frame with an updated name attribute.", "IndexSecond.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexSecond.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexSecond.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexSecond.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecond.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecond.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexSecond.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexSecond.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexSecond.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexSecond.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecond.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexSecond.__iter__()": "Iterate over labels.", "IndexSecond.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexSecond.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexSecond.interface": "A Frame documenting the interface of this class.", "IndexSecond.__repr__()": "", "IndexSecond.__str__()": "Return str(self).", "IndexSecond.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexSecond.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexSecond.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexSecond.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexSecond.drop.loc[]": "", "IndexSecond.[]": "Extract a new index given an iloc key.", "IndexSecond.iloc[]": "", "IndexSecond.loc[]": "", "IndexSecond.iter_label()": "", "IndexSecond.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexSecond.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexSecond.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexSecond.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexSecond.__add__()": "", "IndexSecond.__and__()": "", "IndexSecond.__eq__()": "", "IndexSecond.__floordiv__()": "", "IndexSecond.__ge__()": "", "IndexSecond.__gt__()": "", "IndexSecond.__le__()": "", "IndexSecond.__lt__()": "", "IndexSecond.__matmul__()": "", "IndexSecond.__mod__()": "", "IndexSecond.__mul__()": "", "IndexSecond.__ne__()": "", "IndexSecond.__or__()": "", "IndexSecond.__pow__()": "", "IndexSecond.__radd__()": "", "IndexSecond.__rfloordiv__()": "", "IndexSecond.__rmatmul__()": "", "IndexSecond.__rmul__()": "", "IndexSecond.__rshift__()": "", "IndexSecond.__rsub__()": "", "IndexSecond.__rtruediv__()": "", "IndexSecond.__sub__()": "", "IndexSecond.__truediv__()": "", "IndexSecond.__xor__()": "", "IndexSecond.__abs__()": "", "IndexSecond.__invert__()": "", "IndexSecond.__neg__()": "", "IndexSecond.__pos__()": "", "IndexSecond.via_values.apply()": "", "IndexSecond.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexSecond.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexSecond.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexSecond.via_dt.year": "Return the year of each element.", "IndexSecond.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexSecond.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexSecond.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexSecond.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexSecond.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexSecond.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexSecond.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexSecond.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexSecond.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexSecond.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexSecond.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexSecond.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexSecond.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexSecond.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexSecond.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexSecond.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexSecond.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexSecond.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexSecond.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexSecond.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexSecond.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexSecond.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexSecond.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexSecond.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexSecond.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexSecond.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexSecond.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexSecond.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexSecond.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexSecond.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexSecond.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexSecond.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexSecond.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexSecond.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexSecond.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexSecond.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexSecond.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexSecond.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexSecond.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexSecond.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexSecond.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexSecond.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexSecond.via_str.len()": "Return the length of the string.", "IndexSecond.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexSecond.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexSecond.via_str.partition()": "Partition each element around sep.", "IndexSecond.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexSecond.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexSecond.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexSecond.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexSecond.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexSecond.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexSecond.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexSecond.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexSecond.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexSecond.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexSecond.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexSecond.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexSecond.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexSecond.via_str.zfill()": "Return the string left-filled with zeros.", "IndexSecond.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexSecond.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexSecond.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexSecond.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexSecond.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexSecond.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexSecond.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexSecond.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexSecond.via_hashlib().md5()": "", "IndexSecond.via_hashlib().sha256()": "", "IndexSecond.via_hashlib().sha512()": "", "IndexSecond.via_hashlib().sha3_256()": "", "IndexSecond.via_hashlib().sha3_512()": "", "IndexSecond.via_hashlib().shake_128()": "", "IndexSecond.via_hashlib().shake_256()": "", "IndexSecond.via_hashlib().blake2b()": "", "IndexSecond.via_hashlib().blake2s()": "", "IndexSecond.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexSecond.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexSecond.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexSecond.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexSecond.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexSecondGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexSecondGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexSecondGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexSecondGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexSecondGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexSecondGO.to_pandas()": "Return a Pandas Index.", "IndexSecondGO.to_series()": "Return a Series with values from this Index's labels.", "IndexSecondGO.to_visidata()": "Open an interactive VisiData session.", "IndexSecondGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexSecondGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexSecondGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexSecondGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexSecondGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexSecondGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexSecondGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexSecondGO.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexSecondGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexSecondGO.ndim": "Return the number of dimensions. Returns: int", "IndexSecondGO.positions": "Return the immutable positions array.", "IndexSecondGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexSecondGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexSecondGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexSecondGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexSecondGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexSecondGO.__copy__()": "Return shallow copy of this Index.", "IndexSecondGO.__deepcopy__()": "", "IndexSecondGO.__len__()": "", "IndexSecondGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecondGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecondGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resolve_dtype with each addition; self._map is never None", "IndexSecondGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexSecondGO.copy()": "Return shallow copy of this Index.", "IndexSecondGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecondGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecondGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexSecondGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexSecondGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexSecondGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexSecondGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexSecondGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexSecondGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexSecondGO.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexSecondGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexSecondGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexSecondGO.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexSecondGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexSecondGO.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexSecondGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexSecondGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexSecondGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexSecondGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexSecondGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecondGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecondGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecondGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecondGO.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexSecondGO.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexSecondGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecondGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexSecondGO.rename()": "Return a new Frame with an updated name attribute.", "IndexSecondGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexSecondGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexSecondGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexSecondGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecondGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecondGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexSecondGO.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexSecondGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexSecondGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexSecondGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexSecondGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexSecondGO.__iter__()": "Iterate over labels.", "IndexSecondGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexSecondGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexSecondGO.interface": "A Frame documenting the interface of this class.", "IndexSecondGO.__repr__()": "", "IndexSecondGO.__str__()": "Return str(self).", "IndexSecondGO.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexSecondGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexSecondGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexSecondGO.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexSecondGO.drop.loc[]": "", "IndexSecondGO.[]": "Extract a new index given an iloc key.", "IndexSecondGO.iloc[]": "", "IndexSecondGO.loc[]": "", "IndexSecondGO.iter_label()": "", "IndexSecondGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexSecondGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexSecondGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexSecondGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexSecondGO.__add__()": "", "IndexSecondGO.__and__()": "", "IndexSecondGO.__eq__()": "", "IndexSecondGO.__floordiv__()": "", "IndexSecondGO.__ge__()": "", "IndexSecondGO.__gt__()": "", "IndexSecondGO.__le__()": "", "IndexSecondGO.__lt__()": "", "IndexSecondGO.__matmul__()": "", "IndexSecondGO.__mod__()": "", "IndexSecondGO.__mul__()": "", "IndexSecondGO.__ne__()": "", "IndexSecondGO.__or__()": "", "IndexSecondGO.__pow__()": "", "IndexSecondGO.__radd__()": "", "IndexSecondGO.__rfloordiv__()": "", "IndexSecondGO.__rmatmul__()": "", "IndexSecondGO.__rmul__()": "", "IndexSecondGO.__rshift__()": "", "IndexSecondGO.__rsub__()": "", "IndexSecondGO.__rtruediv__()": "", "IndexSecondGO.__sub__()": "", "IndexSecondGO.__truediv__()": "", "IndexSecondGO.__xor__()": "", "IndexSecondGO.__abs__()": "", "IndexSecondGO.__invert__()": "", "IndexSecondGO.__neg__()": "", "IndexSecondGO.__pos__()": "", "IndexSecondGO.via_values.apply()": "", "IndexSecondGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexSecondGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexSecondGO.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexSecondGO.via_dt.year": "Return the year of each element.", "IndexSecondGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexSecondGO.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexSecondGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexSecondGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexSecondGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexSecondGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexSecondGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexSecondGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexSecondGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexSecondGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexSecondGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexSecondGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexSecondGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexSecondGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexSecondGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexSecondGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexSecondGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexSecondGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexSecondGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexSecondGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexSecondGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexSecondGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexSecondGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexSecondGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexSecondGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexSecondGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexSecondGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexSecondGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexSecondGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexSecondGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexSecondGO.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexSecondGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexSecondGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexSecondGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexSecondGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexSecondGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexSecondGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexSecondGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexSecondGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexSecondGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexSecondGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexSecondGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexSecondGO.via_str.len()": "Return the length of the string.", "IndexSecondGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexSecondGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexSecondGO.via_str.partition()": "Partition each element around sep.", "IndexSecondGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexSecondGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexSecondGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexSecondGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexSecondGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexSecondGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexSecondGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexSecondGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexSecondGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexSecondGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexSecondGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexSecondGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexSecondGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexSecondGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexSecondGO.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexSecondGO.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexSecondGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexSecondGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexSecondGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexSecondGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexSecondGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexSecondGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexSecondGO.via_hashlib().md5()": "", "IndexSecondGO.via_hashlib().sha256()": "", "IndexSecondGO.via_hashlib().sha512()": "", "IndexSecondGO.via_hashlib().sha3_256()": "", "IndexSecondGO.via_hashlib().sha3_512()": "", "IndexSecondGO.via_hashlib().shake_128()": "", "IndexSecondGO.via_hashlib().shake_256()": "", "IndexSecondGO.via_hashlib().blake2b()": "", "IndexSecondGO.via_hashlib().blake2s()": "", "IndexSecondGO.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexSecondGO.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexSecondGO.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexSecondGO.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexSecondGO.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexMillisecond.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexMillisecond.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexMillisecond.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexMillisecond.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexMillisecond.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexMillisecond.to_pandas()": "Return a Pandas Index.", "IndexMillisecond.to_series()": "Return a Series with values from this Index's labels.", "IndexMillisecond.to_visidata()": "Open an interactive VisiData session.", "IndexMillisecond.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexMillisecond.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexMillisecond.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexMillisecond.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexMillisecond.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexMillisecond.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexMillisecond.name": "A hashable label attached to this container. Returns: Hashable", "IndexMillisecond.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexMillisecond.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexMillisecond.ndim": "Return the number of dimensions. Returns: int", "IndexMillisecond.positions": "Return the immutable positions array.", "IndexMillisecond.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexMillisecond.size": "Return the size of the underlying NumPy array. Returns: int", "IndexMillisecond.__array__()": "Support the __array__ interface, returning an array of values.", "IndexMillisecond.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexMillisecond.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexMillisecond.__copy__()": "Return shallow copy of this Index.", "IndexMillisecond.__deepcopy__()": "", "IndexMillisecond.__len__()": "", "IndexMillisecond.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecond.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecond.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexMillisecond.copy()": "Return shallow copy of this Index.", "IndexMillisecond.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecond.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecond.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexMillisecond.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexMillisecond.dropna()": "Return a new Index after removing values of NaN or None.", "IndexMillisecond.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexMillisecond.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexMillisecond.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexMillisecond.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexMillisecond.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexMillisecond.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexMillisecond.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexMillisecond.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexMillisecond.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexMillisecond.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexMillisecond.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexMillisecond.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexMillisecond.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexMillisecond.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecond.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecond.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecond.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecond.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexMillisecond.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexMillisecond.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecond.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexMillisecond.rename()": "Return a new Frame with an updated name attribute.", "IndexMillisecond.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexMillisecond.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexMillisecond.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexMillisecond.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecond.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecond.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexMillisecond.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexMillisecond.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexMillisecond.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexMillisecond.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecond.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexMillisecond.__iter__()": "Iterate over labels.", "IndexMillisecond.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexMillisecond.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexMillisecond.interface": "A Frame documenting the interface of this class.", "IndexMillisecond.__repr__()": "", "IndexMillisecond.__str__()": "Return str(self).", "IndexMillisecond.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMillisecond.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMillisecond.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMillisecond.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexMillisecond.drop.loc[]": "", "IndexMillisecond.[]": "Extract a new index given an iloc key.", "IndexMillisecond.iloc[]": "", "IndexMillisecond.loc[]": "", "IndexMillisecond.iter_label()": "", "IndexMillisecond.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexMillisecond.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexMillisecond.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexMillisecond.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexMillisecond.__add__()": "", "IndexMillisecond.__and__()": "", "IndexMillisecond.__eq__()": "", "IndexMillisecond.__floordiv__()": "", "IndexMillisecond.__ge__()": "", "IndexMillisecond.__gt__()": "", "IndexMillisecond.__le__()": "", "IndexMillisecond.__lt__()": "", "IndexMillisecond.__matmul__()": "", "IndexMillisecond.__mod__()": "", "IndexMillisecond.__mul__()": "", "IndexMillisecond.__ne__()": "", "IndexMillisecond.__or__()": "", "IndexMillisecond.__pow__()": "", "IndexMillisecond.__radd__()": "", "IndexMillisecond.__rfloordiv__()": "", "IndexMillisecond.__rmatmul__()": "", "IndexMillisecond.__rmul__()": "", "IndexMillisecond.__rshift__()": "", "IndexMillisecond.__rsub__()": "", "IndexMillisecond.__rtruediv__()": "", "IndexMillisecond.__sub__()": "", "IndexMillisecond.__truediv__()": "", "IndexMillisecond.__xor__()": "", "IndexMillisecond.__abs__()": "", "IndexMillisecond.__invert__()": "", "IndexMillisecond.__neg__()": "", "IndexMillisecond.__pos__()": "", "IndexMillisecond.via_values.apply()": "", "IndexMillisecond.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexMillisecond.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexMillisecond.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexMillisecond.via_dt.year": "Return the year of each element.", "IndexMillisecond.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexMillisecond.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexMillisecond.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexMillisecond.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexMillisecond.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexMillisecond.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexMillisecond.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexMillisecond.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexMillisecond.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexMillisecond.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexMillisecond.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexMillisecond.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexMillisecond.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexMillisecond.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexMillisecond.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexMillisecond.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexMillisecond.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexMillisecond.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexMillisecond.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexMillisecond.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexMillisecond.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexMillisecond.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexMillisecond.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexMillisecond.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexMillisecond.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexMillisecond.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexMillisecond.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexMillisecond.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexMillisecond.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexMillisecond.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexMillisecond.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexMillisecond.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexMillisecond.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexMillisecond.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexMillisecond.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexMillisecond.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexMillisecond.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexMillisecond.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexMillisecond.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexMillisecond.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexMillisecond.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexMillisecond.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexMillisecond.via_str.len()": "Return the length of the string.", "IndexMillisecond.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexMillisecond.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexMillisecond.via_str.partition()": "Partition each element around sep.", "IndexMillisecond.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexMillisecond.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexMillisecond.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexMillisecond.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexMillisecond.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexMillisecond.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexMillisecond.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexMillisecond.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexMillisecond.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexMillisecond.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexMillisecond.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMillisecond.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMillisecond.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMillisecond.via_str.zfill()": "Return the string left-filled with zeros.", "IndexMillisecond.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMillisecond.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMillisecond.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMillisecond.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexMillisecond.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMillisecond.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexMillisecond.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexMillisecond.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexMillisecond.via_hashlib().md5()": "", "IndexMillisecond.via_hashlib().sha256()": "", "IndexMillisecond.via_hashlib().sha512()": "", "IndexMillisecond.via_hashlib().sha3_256()": "", "IndexMillisecond.via_hashlib().sha3_512()": "", "IndexMillisecond.via_hashlib().shake_128()": "", "IndexMillisecond.via_hashlib().shake_256()": "", "IndexMillisecond.via_hashlib().blake2b()": "", "IndexMillisecond.via_hashlib().blake2s()": "", "IndexMillisecond.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexMillisecond.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexMillisecond.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexMillisecond.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexMillisecond.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexMillisecondGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexMillisecondGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexMillisecondGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexMillisecondGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexMillisecondGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexMillisecondGO.to_pandas()": "Return a Pandas Index.", "IndexMillisecondGO.to_series()": "Return a Series with values from this Index's labels.", "IndexMillisecondGO.to_visidata()": "Open an interactive VisiData session.", "IndexMillisecondGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexMillisecondGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexMillisecondGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexMillisecondGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexMillisecondGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexMillisecondGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexMillisecondGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexMillisecondGO.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexMillisecondGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexMillisecondGO.ndim": "Return the number of dimensions. Returns: int", "IndexMillisecondGO.positions": "Return the immutable positions array.", "IndexMillisecondGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexMillisecondGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexMillisecondGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexMillisecondGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexMillisecondGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexMillisecondGO.__copy__()": "Return shallow copy of this Index.", "IndexMillisecondGO.__deepcopy__()": "", "IndexMillisecondGO.__len__()": "", "IndexMillisecondGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecondGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecondGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resolve_dtype with each addition; self._map is never None", "IndexMillisecondGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexMillisecondGO.copy()": "Return shallow copy of this Index.", "IndexMillisecondGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecondGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecondGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexMillisecondGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexMillisecondGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexMillisecondGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexMillisecondGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexMillisecondGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexMillisecondGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexMillisecondGO.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexMillisecondGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexMillisecondGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexMillisecondGO.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexMillisecondGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexMillisecondGO.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexMillisecondGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexMillisecondGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexMillisecondGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexMillisecondGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexMillisecondGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecondGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecondGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecondGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecondGO.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexMillisecondGO.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexMillisecondGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecondGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexMillisecondGO.rename()": "Return a new Frame with an updated name attribute.", "IndexMillisecondGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexMillisecondGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexMillisecondGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexMillisecondGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecondGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecondGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexMillisecondGO.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexMillisecondGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexMillisecondGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexMillisecondGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMillisecondGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexMillisecondGO.__iter__()": "Iterate over labels.", "IndexMillisecondGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexMillisecondGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexMillisecondGO.interface": "A Frame documenting the interface of this class.", "IndexMillisecondGO.__repr__()": "", "IndexMillisecondGO.__str__()": "Return str(self).", "IndexMillisecondGO.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMillisecondGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMillisecondGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMillisecondGO.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexMillisecondGO.drop.loc[]": "", "IndexMillisecondGO.[]": "Extract a new index given an iloc key.", "IndexMillisecondGO.iloc[]": "", "IndexMillisecondGO.loc[]": "", "IndexMillisecondGO.iter_label()": "", "IndexMillisecondGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexMillisecondGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexMillisecondGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexMillisecondGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexMillisecondGO.__add__()": "", "IndexMillisecondGO.__and__()": "", "IndexMillisecondGO.__eq__()": "", "IndexMillisecondGO.__floordiv__()": "", "IndexMillisecondGO.__ge__()": "", "IndexMillisecondGO.__gt__()": "", "IndexMillisecondGO.__le__()": "", "IndexMillisecondGO.__lt__()": "", "IndexMillisecondGO.__matmul__()": "", "IndexMillisecondGO.__mod__()": "", "IndexMillisecondGO.__mul__()": "", "IndexMillisecondGO.__ne__()": "", "IndexMillisecondGO.__or__()": "", "IndexMillisecondGO.__pow__()": "", "IndexMillisecondGO.__radd__()": "", "IndexMillisecondGO.__rfloordiv__()": "", "IndexMillisecondGO.__rmatmul__()": "", "IndexMillisecondGO.__rmul__()": "", "IndexMillisecondGO.__rshift__()": "", "IndexMillisecondGO.__rsub__()": "", "IndexMillisecondGO.__rtruediv__()": "", "IndexMillisecondGO.__sub__()": "", "IndexMillisecondGO.__truediv__()": "", "IndexMillisecondGO.__xor__()": "", "IndexMillisecondGO.__abs__()": "", "IndexMillisecondGO.__invert__()": "", "IndexMillisecondGO.__neg__()": "", "IndexMillisecondGO.__pos__()": "", "IndexMillisecondGO.via_values.apply()": "", "IndexMillisecondGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexMillisecondGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexMillisecondGO.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexMillisecondGO.via_dt.year": "Return the year of each element.", "IndexMillisecondGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexMillisecondGO.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexMillisecondGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexMillisecondGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexMillisecondGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexMillisecondGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexMillisecondGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexMillisecondGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexMillisecondGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexMillisecondGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexMillisecondGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexMillisecondGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexMillisecondGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexMillisecondGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexMillisecondGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexMillisecondGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexMillisecondGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexMillisecondGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexMillisecondGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexMillisecondGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexMillisecondGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexMillisecondGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexMillisecondGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexMillisecondGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexMillisecondGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexMillisecondGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexMillisecondGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexMillisecondGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexMillisecondGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexMillisecondGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexMillisecondGO.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexMillisecondGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexMillisecondGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexMillisecondGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexMillisecondGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexMillisecondGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexMillisecondGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexMillisecondGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexMillisecondGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexMillisecondGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexMillisecondGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexMillisecondGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexMillisecondGO.via_str.len()": "Return the length of the string.", "IndexMillisecondGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexMillisecondGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexMillisecondGO.via_str.partition()": "Partition each element around sep.", "IndexMillisecondGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexMillisecondGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexMillisecondGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexMillisecondGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexMillisecondGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexMillisecondGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexMillisecondGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexMillisecondGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexMillisecondGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexMillisecondGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexMillisecondGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMillisecondGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMillisecondGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMillisecondGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexMillisecondGO.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMillisecondGO.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMillisecondGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMillisecondGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexMillisecondGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMillisecondGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexMillisecondGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexMillisecondGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexMillisecondGO.via_hashlib().md5()": "", "IndexMillisecondGO.via_hashlib().sha256()": "", "IndexMillisecondGO.via_hashlib().sha512()": "", "IndexMillisecondGO.via_hashlib().sha3_256()": "", "IndexMillisecondGO.via_hashlib().sha3_512()": "", "IndexMillisecondGO.via_hashlib().shake_128()": "", "IndexMillisecondGO.via_hashlib().shake_256()": "", "IndexMillisecondGO.via_hashlib().blake2b()": "", "IndexMillisecondGO.via_hashlib().blake2s()": "", "IndexMillisecondGO.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexMillisecondGO.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexMillisecondGO.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexMillisecondGO.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexMillisecondGO.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexMicrosecond.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexMicrosecond.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexMicrosecond.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexMicrosecond.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexMicrosecond.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexMicrosecond.to_pandas()": "Return a Pandas Index.", "IndexMicrosecond.to_series()": "Return a Series with values from this Index's labels.", "IndexMicrosecond.to_visidata()": "Open an interactive VisiData session.", "IndexMicrosecond.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexMicrosecond.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexMicrosecond.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexMicrosecond.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexMicrosecond.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexMicrosecond.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexMicrosecond.name": "A hashable label attached to this container. Returns: Hashable", "IndexMicrosecond.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexMicrosecond.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexMicrosecond.ndim": "Return the number of dimensions. Returns: int", "IndexMicrosecond.positions": "Return the immutable positions array.", "IndexMicrosecond.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexMicrosecond.size": "Return the size of the underlying NumPy array. Returns: int", "IndexMicrosecond.__array__()": "Support the __array__ interface, returning an array of values.", "IndexMicrosecond.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexMicrosecond.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexMicrosecond.__copy__()": "Return shallow copy of this Index.", "IndexMicrosecond.__deepcopy__()": "", "IndexMicrosecond.__len__()": "", "IndexMicrosecond.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecond.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecond.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexMicrosecond.copy()": "Return shallow copy of this Index.", "IndexMicrosecond.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecond.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecond.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexMicrosecond.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexMicrosecond.dropna()": "Return a new Index after removing values of NaN or None.", "IndexMicrosecond.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexMicrosecond.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexMicrosecond.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexMicrosecond.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexMicrosecond.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexMicrosecond.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexMicrosecond.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexMicrosecond.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexMicrosecond.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexMicrosecond.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexMicrosecond.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexMicrosecond.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexMicrosecond.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexMicrosecond.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecond.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecond.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecond.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecond.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexMicrosecond.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexMicrosecond.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecond.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexMicrosecond.rename()": "Return a new Frame with an updated name attribute.", "IndexMicrosecond.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexMicrosecond.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexMicrosecond.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexMicrosecond.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecond.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecond.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexMicrosecond.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexMicrosecond.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexMicrosecond.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexMicrosecond.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecond.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexMicrosecond.__iter__()": "Iterate over labels.", "IndexMicrosecond.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexMicrosecond.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexMicrosecond.interface": "A Frame documenting the interface of this class.", "IndexMicrosecond.__repr__()": "", "IndexMicrosecond.__str__()": "Return str(self).", "IndexMicrosecond.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMicrosecond.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMicrosecond.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMicrosecond.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexMicrosecond.drop.loc[]": "", "IndexMicrosecond.[]": "Extract a new index given an iloc key.", "IndexMicrosecond.iloc[]": "", "IndexMicrosecond.loc[]": "", "IndexMicrosecond.iter_label()": "", "IndexMicrosecond.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexMicrosecond.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexMicrosecond.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexMicrosecond.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexMicrosecond.__add__()": "", "IndexMicrosecond.__and__()": "", "IndexMicrosecond.__eq__()": "", "IndexMicrosecond.__floordiv__()": "", "IndexMicrosecond.__ge__()": "", "IndexMicrosecond.__gt__()": "", "IndexMicrosecond.__le__()": "", "IndexMicrosecond.__lt__()": "", "IndexMicrosecond.__matmul__()": "", "IndexMicrosecond.__mod__()": "", "IndexMicrosecond.__mul__()": "", "IndexMicrosecond.__ne__()": "", "IndexMicrosecond.__or__()": "", "IndexMicrosecond.__pow__()": "", "IndexMicrosecond.__radd__()": "", "IndexMicrosecond.__rfloordiv__()": "", "IndexMicrosecond.__rmatmul__()": "", "IndexMicrosecond.__rmul__()": "", "IndexMicrosecond.__rshift__()": "", "IndexMicrosecond.__rsub__()": "", "IndexMicrosecond.__rtruediv__()": "", "IndexMicrosecond.__sub__()": "", "IndexMicrosecond.__truediv__()": "", "IndexMicrosecond.__xor__()": "", "IndexMicrosecond.__abs__()": "", "IndexMicrosecond.__invert__()": "", "IndexMicrosecond.__neg__()": "", "IndexMicrosecond.__pos__()": "", "IndexMicrosecond.via_values.apply()": "", "IndexMicrosecond.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexMicrosecond.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexMicrosecond.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexMicrosecond.via_dt.year": "Return the year of each element.", "IndexMicrosecond.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexMicrosecond.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexMicrosecond.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexMicrosecond.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexMicrosecond.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexMicrosecond.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexMicrosecond.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexMicrosecond.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexMicrosecond.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexMicrosecond.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexMicrosecond.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexMicrosecond.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexMicrosecond.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexMicrosecond.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexMicrosecond.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexMicrosecond.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexMicrosecond.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexMicrosecond.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexMicrosecond.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexMicrosecond.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexMicrosecond.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexMicrosecond.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexMicrosecond.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexMicrosecond.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexMicrosecond.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexMicrosecond.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexMicrosecond.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexMicrosecond.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexMicrosecond.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexMicrosecond.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexMicrosecond.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexMicrosecond.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexMicrosecond.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexMicrosecond.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexMicrosecond.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexMicrosecond.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexMicrosecond.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexMicrosecond.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexMicrosecond.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexMicrosecond.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexMicrosecond.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexMicrosecond.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexMicrosecond.via_str.len()": "Return the length of the string.", "IndexMicrosecond.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexMicrosecond.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexMicrosecond.via_str.partition()": "Partition each element around sep.", "IndexMicrosecond.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexMicrosecond.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexMicrosecond.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexMicrosecond.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexMicrosecond.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexMicrosecond.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexMicrosecond.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexMicrosecond.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexMicrosecond.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexMicrosecond.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexMicrosecond.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMicrosecond.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMicrosecond.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMicrosecond.via_str.zfill()": "Return the string left-filled with zeros.", "IndexMicrosecond.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMicrosecond.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMicrosecond.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMicrosecond.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexMicrosecond.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMicrosecond.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexMicrosecond.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexMicrosecond.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexMicrosecond.via_hashlib().md5()": "", "IndexMicrosecond.via_hashlib().sha256()": "", "IndexMicrosecond.via_hashlib().sha512()": "", "IndexMicrosecond.via_hashlib().sha3_256()": "", "IndexMicrosecond.via_hashlib().sha3_512()": "", "IndexMicrosecond.via_hashlib().shake_128()": "", "IndexMicrosecond.via_hashlib().shake_256()": "", "IndexMicrosecond.via_hashlib().blake2b()": "", "IndexMicrosecond.via_hashlib().blake2s()": "", "IndexMicrosecond.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexMicrosecond.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexMicrosecond.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexMicrosecond.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexMicrosecond.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexMicrosecondGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexMicrosecondGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexMicrosecondGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexMicrosecondGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexMicrosecondGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexMicrosecondGO.to_pandas()": "Return a Pandas Index.", "IndexMicrosecondGO.to_series()": "Return a Series with values from this Index's labels.", "IndexMicrosecondGO.to_visidata()": "Open an interactive VisiData session.", "IndexMicrosecondGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexMicrosecondGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexMicrosecondGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexMicrosecondGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexMicrosecondGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexMicrosecondGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexMicrosecondGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexMicrosecondGO.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexMicrosecondGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexMicrosecondGO.ndim": "Return the number of dimensions. Returns: int", "IndexMicrosecondGO.positions": "Return the immutable positions array.", "IndexMicrosecondGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexMicrosecondGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexMicrosecondGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexMicrosecondGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexMicrosecondGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexMicrosecondGO.__copy__()": "Return shallow copy of this Index.", "IndexMicrosecondGO.__deepcopy__()": "", "IndexMicrosecondGO.__len__()": "", "IndexMicrosecondGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecondGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecondGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resolve_dtype with each addition; self._map is never None", "IndexMicrosecondGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexMicrosecondGO.copy()": "Return shallow copy of this Index.", "IndexMicrosecondGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecondGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecondGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexMicrosecondGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexMicrosecondGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexMicrosecondGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexMicrosecondGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexMicrosecondGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexMicrosecondGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexMicrosecondGO.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexMicrosecondGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexMicrosecondGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexMicrosecondGO.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexMicrosecondGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexMicrosecondGO.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexMicrosecondGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexMicrosecondGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexMicrosecondGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexMicrosecondGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexMicrosecondGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecondGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecondGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecondGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecondGO.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexMicrosecondGO.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexMicrosecondGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecondGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexMicrosecondGO.rename()": "Return a new Frame with an updated name attribute.", "IndexMicrosecondGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexMicrosecondGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexMicrosecondGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexMicrosecondGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecondGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecondGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexMicrosecondGO.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexMicrosecondGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexMicrosecondGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexMicrosecondGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexMicrosecondGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexMicrosecondGO.__iter__()": "Iterate over labels.", "IndexMicrosecondGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexMicrosecondGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexMicrosecondGO.interface": "A Frame documenting the interface of this class.", "IndexMicrosecondGO.__repr__()": "", "IndexMicrosecondGO.__str__()": "Return str(self).", "IndexMicrosecondGO.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMicrosecondGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMicrosecondGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexMicrosecondGO.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexMicrosecondGO.drop.loc[]": "", "IndexMicrosecondGO.[]": "Extract a new index given an iloc key.", "IndexMicrosecondGO.iloc[]": "", "IndexMicrosecondGO.loc[]": "", "IndexMicrosecondGO.iter_label()": "", "IndexMicrosecondGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexMicrosecondGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexMicrosecondGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexMicrosecondGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexMicrosecondGO.__add__()": "", "IndexMicrosecondGO.__and__()": "", "IndexMicrosecondGO.__eq__()": "", "IndexMicrosecondGO.__floordiv__()": "", "IndexMicrosecondGO.__ge__()": "", "IndexMicrosecondGO.__gt__()": "", "IndexMicrosecondGO.__le__()": "", "IndexMicrosecondGO.__lt__()": "", "IndexMicrosecondGO.__matmul__()": "", "IndexMicrosecondGO.__mod__()": "", "IndexMicrosecondGO.__mul__()": "", "IndexMicrosecondGO.__ne__()": "", "IndexMicrosecondGO.__or__()": "", "IndexMicrosecondGO.__pow__()": "", "IndexMicrosecondGO.__radd__()": "", "IndexMicrosecondGO.__rfloordiv__()": "", "IndexMicrosecondGO.__rmatmul__()": "", "IndexMicrosecondGO.__rmul__()": "", "IndexMicrosecondGO.__rshift__()": "", "IndexMicrosecondGO.__rsub__()": "", "IndexMicrosecondGO.__rtruediv__()": "", "IndexMicrosecondGO.__sub__()": "", "IndexMicrosecondGO.__truediv__()": "", "IndexMicrosecondGO.__xor__()": "", "IndexMicrosecondGO.__abs__()": "", "IndexMicrosecondGO.__invert__()": "", "IndexMicrosecondGO.__neg__()": "", "IndexMicrosecondGO.__pos__()": "", "IndexMicrosecondGO.via_values.apply()": "", "IndexMicrosecondGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexMicrosecondGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexMicrosecondGO.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexMicrosecondGO.via_dt.year": "Return the year of each element.", "IndexMicrosecondGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexMicrosecondGO.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexMicrosecondGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexMicrosecondGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexMicrosecondGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexMicrosecondGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexMicrosecondGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexMicrosecondGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexMicrosecondGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexMicrosecondGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexMicrosecondGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexMicrosecondGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexMicrosecondGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexMicrosecondGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexMicrosecondGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexMicrosecondGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexMicrosecondGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexMicrosecondGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexMicrosecondGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexMicrosecondGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexMicrosecondGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexMicrosecondGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexMicrosecondGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexMicrosecondGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexMicrosecondGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexMicrosecondGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexMicrosecondGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexMicrosecondGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexMicrosecondGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexMicrosecondGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexMicrosecondGO.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexMicrosecondGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexMicrosecondGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexMicrosecondGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexMicrosecondGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexMicrosecondGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexMicrosecondGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexMicrosecondGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexMicrosecondGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexMicrosecondGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexMicrosecondGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexMicrosecondGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexMicrosecondGO.via_str.len()": "Return the length of the string.", "IndexMicrosecondGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexMicrosecondGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexMicrosecondGO.via_str.partition()": "Partition each element around sep.", "IndexMicrosecondGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexMicrosecondGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexMicrosecondGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexMicrosecondGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexMicrosecondGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexMicrosecondGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexMicrosecondGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexMicrosecondGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexMicrosecondGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexMicrosecondGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexMicrosecondGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMicrosecondGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMicrosecondGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexMicrosecondGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexMicrosecondGO.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMicrosecondGO.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMicrosecondGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMicrosecondGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexMicrosecondGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexMicrosecondGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexMicrosecondGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexMicrosecondGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexMicrosecondGO.via_hashlib().md5()": "", "IndexMicrosecondGO.via_hashlib().sha256()": "", "IndexMicrosecondGO.via_hashlib().sha512()": "", "IndexMicrosecondGO.via_hashlib().sha3_256()": "", "IndexMicrosecondGO.via_hashlib().sha3_512()": "", "IndexMicrosecondGO.via_hashlib().shake_128()": "", "IndexMicrosecondGO.via_hashlib().shake_256()": "", "IndexMicrosecondGO.via_hashlib().blake2b()": "", "IndexMicrosecondGO.via_hashlib().blake2s()": "", "IndexMicrosecondGO.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexMicrosecondGO.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexMicrosecondGO.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexMicrosecondGO.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexMicrosecondGO.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexNanosecond.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexNanosecond.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexNanosecond.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexNanosecond.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexNanosecond.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexNanosecond.to_pandas()": "Return a Pandas Index.", "IndexNanosecond.to_series()": "Return a Series with values from this Index's labels.", "IndexNanosecond.to_visidata()": "Open an interactive VisiData session.", "IndexNanosecond.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexNanosecond.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexNanosecond.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexNanosecond.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexNanosecond.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexNanosecond.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexNanosecond.name": "A hashable label attached to this container. Returns: Hashable", "IndexNanosecond.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexNanosecond.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexNanosecond.ndim": "Return the number of dimensions. Returns: int", "IndexNanosecond.positions": "Return the immutable positions array.", "IndexNanosecond.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexNanosecond.size": "Return the size of the underlying NumPy array. Returns: int", "IndexNanosecond.__array__()": "Support the __array__ interface, returning an array of values.", "IndexNanosecond.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexNanosecond.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexNanosecond.__copy__()": "Return shallow copy of this Index.", "IndexNanosecond.__deepcopy__()": "", "IndexNanosecond.__len__()": "", "IndexNanosecond.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecond.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecond.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexNanosecond.copy()": "Return shallow copy of this Index.", "IndexNanosecond.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecond.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecond.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexNanosecond.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexNanosecond.dropna()": "Return a new Index after removing values of NaN or None.", "IndexNanosecond.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexNanosecond.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexNanosecond.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexNanosecond.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexNanosecond.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexNanosecond.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexNanosecond.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexNanosecond.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexNanosecond.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexNanosecond.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexNanosecond.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexNanosecond.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexNanosecond.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexNanosecond.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecond.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecond.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecond.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecond.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexNanosecond.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexNanosecond.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecond.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexNanosecond.rename()": "Return a new Frame with an updated name attribute.", "IndexNanosecond.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexNanosecond.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexNanosecond.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexNanosecond.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecond.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecond.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexNanosecond.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexNanosecond.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexNanosecond.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexNanosecond.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecond.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexNanosecond.__iter__()": "Iterate over labels.", "IndexNanosecond.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexNanosecond.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexNanosecond.interface": "A Frame documenting the interface of this class.", "IndexNanosecond.__repr__()": "", "IndexNanosecond.__str__()": "Return str(self).", "IndexNanosecond.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexNanosecond.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexNanosecond.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexNanosecond.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexNanosecond.drop.loc[]": "", "IndexNanosecond.[]": "Extract a new index given an iloc key.", "IndexNanosecond.iloc[]": "", "IndexNanosecond.loc[]": "", "IndexNanosecond.iter_label()": "", "IndexNanosecond.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexNanosecond.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexNanosecond.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexNanosecond.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexNanosecond.__add__()": "", "IndexNanosecond.__and__()": "", "IndexNanosecond.__eq__()": "", "IndexNanosecond.__floordiv__()": "", "IndexNanosecond.__ge__()": "", "IndexNanosecond.__gt__()": "", "IndexNanosecond.__le__()": "", "IndexNanosecond.__lt__()": "", "IndexNanosecond.__matmul__()": "", "IndexNanosecond.__mod__()": "", "IndexNanosecond.__mul__()": "", "IndexNanosecond.__ne__()": "", "IndexNanosecond.__or__()": "", "IndexNanosecond.__pow__()": "", "IndexNanosecond.__radd__()": "", "IndexNanosecond.__rfloordiv__()": "", "IndexNanosecond.__rmatmul__()": "", "IndexNanosecond.__rmul__()": "", "IndexNanosecond.__rshift__()": "", "IndexNanosecond.__rsub__()": "", "IndexNanosecond.__rtruediv__()": "", "IndexNanosecond.__sub__()": "", "IndexNanosecond.__truediv__()": "", "IndexNanosecond.__xor__()": "", "IndexNanosecond.__abs__()": "", "IndexNanosecond.__invert__()": "", "IndexNanosecond.__neg__()": "", "IndexNanosecond.__pos__()": "", "IndexNanosecond.via_values.apply()": "", "IndexNanosecond.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexNanosecond.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexNanosecond.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexNanosecond.via_dt.year": "Return the year of each element.", "IndexNanosecond.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexNanosecond.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexNanosecond.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexNanosecond.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexNanosecond.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexNanosecond.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexNanosecond.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexNanosecond.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexNanosecond.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexNanosecond.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexNanosecond.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexNanosecond.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexNanosecond.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexNanosecond.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexNanosecond.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexNanosecond.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexNanosecond.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexNanosecond.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexNanosecond.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexNanosecond.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexNanosecond.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexNanosecond.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexNanosecond.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexNanosecond.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexNanosecond.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexNanosecond.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexNanosecond.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexNanosecond.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexNanosecond.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexNanosecond.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexNanosecond.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexNanosecond.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexNanosecond.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexNanosecond.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexNanosecond.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexNanosecond.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexNanosecond.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexNanosecond.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexNanosecond.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexNanosecond.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexNanosecond.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexNanosecond.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexNanosecond.via_str.len()": "Return the length of the string.", "IndexNanosecond.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexNanosecond.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexNanosecond.via_str.partition()": "Partition each element around sep.", "IndexNanosecond.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexNanosecond.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexNanosecond.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexNanosecond.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexNanosecond.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexNanosecond.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexNanosecond.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexNanosecond.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexNanosecond.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexNanosecond.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexNanosecond.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexNanosecond.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexNanosecond.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexNanosecond.via_str.zfill()": "Return the string left-filled with zeros.", "IndexNanosecond.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexNanosecond.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexNanosecond.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexNanosecond.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexNanosecond.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexNanosecond.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexNanosecond.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexNanosecond.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexNanosecond.via_hashlib().md5()": "", "IndexNanosecond.via_hashlib().sha256()": "", "IndexNanosecond.via_hashlib().sha512()": "", "IndexNanosecond.via_hashlib().sha3_256()": "", "IndexNanosecond.via_hashlib().sha3_512()": "", "IndexNanosecond.via_hashlib().shake_128()": "", "IndexNanosecond.via_hashlib().shake_256()": "", "IndexNanosecond.via_hashlib().blake2b()": "", "IndexNanosecond.via_hashlib().blake2s()": "", "IndexNanosecond.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexNanosecond.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexNanosecond.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexNanosecond.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexNanosecond.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexNanosecondGO.__init__()": "Initializer. Args: labels: Iterable of hashable values to be used as the index labels. If strings, NumPy datetime conversions will be applied. name: A hashable object to label the container.", "IndexNanosecondGO.from_labels()": "Construct an Index from an iterable of labels, where each label is a hashable. Provided for a compatible interface to IndexHierarchy.", "IndexNanosecondGO.from_pandas()": "Given a Pandas index, return the appropriate IndexBase derived class.", "IndexNanosecondGO.to_html()": "Return an HTML table representation of this Index using standard TABLE, TR, and TD tags. This is not a complete HTML page. Args: config: Optional DisplayConfig instance. Returns: str", "IndexNanosecondGO.to_html_datatables()": "Return a complete HTML representation of this Index using the DataTables JS library for table naviagation and search. The page links to CDNs for JS resources, and thus will not fully render without an internet connection. Args: fp: optional file path to write; if not provided, a temporary file will be created. Note: the caller is responsible for deleting this file. show: if True, the file will be opened with a webbrowser. config: Optional DisplayConfig instance. Returns: str, absolute file path to the file written.", "IndexNanosecondGO.to_pandas()": "Return a Pandas Index.", "IndexNanosecondGO.to_series()": "Return a Series with values from this Index's labels.", "IndexNanosecondGO.to_visidata()": "Open an interactive VisiData session.", "IndexNanosecondGO.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "IndexNanosecondGO.depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "IndexNanosecondGO.dtype": "Return the dtype of the underlying NumPy array. Returns: numpy.dtype", "IndexNanosecondGO.index_types": "Return a Series of Index classes for each index depth. Returns: Series", "IndexNanosecondGO.memory": "Return a MemoryDisplay, providing the size in memory of this object. For compound containers, component sizes will also be provided. Size can be interpreted through six combinations of three configurations: L: Local: memory ignoring referenced array data provided via views. LM: Local Materialized: memory where arrays that are locally owned report their byte payload LMD: Local Materialized Data: locally owned memory of arrays byte payloads, excluding all other components R: Referenced: memory including referenced array data provided via views RM: Referenced Materialized: memory where arrays that are locally owned or referenced report their byte payload RMD: Referenced Materialized Data: localy owned and referenced array byte payloads, excluding all other components", "IndexNanosecondGO.mloc": "The memory location, represented as an integer, of the underlying NumPy array.", "IndexNanosecondGO.name": "A hashable label attached to this container. Returns: Hashable", "IndexNanosecondGO.names": "Provide a suitable iterable of names for usage in output formats that require a field name as string for the index.", "IndexNanosecondGO.nbytes": "Return the total bytes of the underlying NumPy array. Returns: int", "IndexNanosecondGO.ndim": "Return the number of dimensions. Returns: int", "IndexNanosecondGO.positions": "Return the immutable positions array.", "IndexNanosecondGO.shape": "Return a tuple describing the shape of the underlying NumPy array. Returns: tp.Tuple[int]", "IndexNanosecondGO.size": "Return the size of the underlying NumPy array. Returns: int", "IndexNanosecondGO.__array__()": "Support the __array__ interface, returning an array of values.", "IndexNanosecondGO.__array_ufunc__()": "Support for NumPy elements or arrays on the left hand of binary operators.", "IndexNanosecondGO.__bool__()": "Raises ValueError to prohibit ambiguous use of truthy evaluation.", "IndexNanosecondGO.__copy__()": "Return shallow copy of this Index.", "IndexNanosecondGO.__deepcopy__()": "", "IndexNanosecondGO.__len__()": "", "IndexNanosecondGO.all()": "Logical and over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecondGO.any()": "Logical or over values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecondGO.append()": "Specialize for fixed-typed indices: convert value argument; do not need to resolve_dtype with each addition; self._map is never None", "IndexNanosecondGO.astype()": "Return an Index with type determined by dtype argument. If a datetime64 dtype is provided, the appropriate Index subclass will be returned. Note that for Index, this is a simple function, whereas for IndexHierarchy, this is an interface exposing both a callable and a getitem interface. Args: dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexNanosecondGO.copy()": "Return shallow copy of this Index.", "IndexNanosecondGO.cumprod()": "Return the cumulative product over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecondGO.cumsum()": "Return the cumulative sum over the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecondGO.difference()": "Perform difference with another Index, container, or NumPy array. Retains order.", "IndexNanosecondGO.dropfalsy()": "Return a new Index after removing values of NaN or None.", "IndexNanosecondGO.dropna()": "Return a new Index after removing values of NaN or None.", "IndexNanosecondGO.equals()": "Return a bool from comparison to any other object. Args: compare_name: Include equality of the container's name (and all composed containers) in the comparison. compare_dtype: Include equality of the container's dtype (and all composed containers) in the comparison. compare_class: Include equality of the container's class (and all composed containers) in the comparison. skipna: If True, comparisons between missing values are equal.", "IndexNanosecondGO.extend()": "Append multiple values Args: values: can be a generator.", "IndexNanosecondGO.fillfalsy()": "Return an Index with replacing falsy values with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexNanosecondGO.fillna()": "Return an Index with replacing null (NaN or None) with the supplied value. Args: value: Value to be used to replace missing values (NaN or None).", "IndexNanosecondGO.head()": "Return a Index consisting only of the top elements as specified by count. Args: count: Number of elements to be returned from the top of the Index", "IndexNanosecondGO.iloc_searchsorted()": "Given a sorted Series, return the iloc (integer) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length).", "IndexNanosecondGO.intersection()": "Perform intersection with one or many Index, container, or NumPy array. Identical comparisons retain order.", "IndexNanosecondGO.isfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexNanosecondGO.isin()": "Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.", "IndexNanosecondGO.isna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexNanosecondGO.label_widths_at_depth()": "A generator of pairs, where each pair is the label and the contiguous count of that label found at the depth specified by depth_level. Args: depth_level: a depth level, starting from zero.", "IndexNanosecondGO.level_add()": "Return an IndexHierarchy with an added root level. Args: level: A hashable to used as the new root. * index_constructor", "IndexNanosecondGO.loc_searchsorted()": "Given a sorted Series, return the loc (label) position(s) at which insertion in values would retain sort order. Args: values: a single value, or iterable of values. side_left: If True, the index of the first suitable location found is given, else return the last such index. If matching an existing value, side_left==True will return that position, side_left==Right will return the next position (or the length). fill_value: A value to be used to fill the label beyond the last label.", "IndexNanosecondGO.loc_to_iloc()": "Given a label (loc) style key (either a label, a list of labels, a slice, or a Boolean selection), return the index position (iloc) style key. Keys that are not found will raise a KeyError or a sf.LocInvalid error. Args: key: a label key.", "IndexNanosecondGO.max()": "Return the maximum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecondGO.mean()": "Return the mean along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecondGO.median()": "Return the median along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecondGO.min()": "Return the minimum along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecondGO.notfalsy()": "Return a same-shaped, Boolean ndarray indicating which values are falsy.", "IndexNanosecondGO.notna()": "Return a same-shaped, Boolean ndarray indicating which values are NaN or None.", "IndexNanosecondGO.prod()": "Return the product along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecondGO.relabel()": "Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.", "IndexNanosecondGO.rename()": "Return a new Frame with an updated name attribute.", "IndexNanosecondGO.roll()": "Return an Index with values rotated forward and wrapped around (with a postive shift) or backward and wrapped around (with a negative shift).", "IndexNanosecondGO.sample()": "Randomly (optionally made deterministic with a fixed seed) extract items from the container to return a subset of the container. Args: Number of elements to select. Initial state of random selection.", "IndexNanosecondGO.sort()": "Return a new Index with the labels sorted. Args: ascending: If True, sort in ascending order; if False, sort in descending order. kind: Name of the sort algorithm as passed to NumPy. key: A function that is used to pre-process the selected columns or rows and derive new values to sort by.", "IndexNanosecondGO.std()": "Return the standard deviaton along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecondGO.sum()": "Sum values along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecondGO.tail()": "Return a Index consisting only of the bottom elements as specified by count. Args: count: Number of elements to be returned from the bottom of the Index", "IndexNanosecondGO.union()": "Perform union with another Index, container, or NumPy array. Identical comparisons retain order.", "IndexNanosecondGO.unique()": "Return a NumPy array of unique values. Args: depth_level: defaults to 0 for for a 1D Index. order_by_occurrence: for 1D indices, this argument is a no-op. Provided for compatibility with IndexHierarchy. Returns: numpy.ndarray", "IndexNanosecondGO.values_at_depth()": "Return an NP array for the depth_level specified.", "IndexNanosecondGO.var()": "Return the variance along the specified axis. Args: axis: Axis, defaulting to axis 0. skipna: Skip missing (NaN) values, defaulting to True.", "IndexNanosecondGO.__contains__()": "Return True if value in the labels. Will only return True for an exact match to the type of dates stored within.", "IndexNanosecondGO.__iter__()": "Iterate over labels.", "IndexNanosecondGO.__reversed__()": "Returns a reverse iterator on the index labels.", "IndexNanosecondGO.values": "A 1D NumPy array of the values in the Index. This array will have the same dtype as the container.", "IndexNanosecondGO.interface": "A Frame documenting the interface of this class.", "IndexNanosecondGO.__repr__()": "", "IndexNanosecondGO.__str__()": "Return str(self).", "IndexNanosecondGO.display()": "Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexNanosecondGO.display_tall()": "Maximize vertical presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexNanosecondGO.display_wide()": "Maximize horizontal presentation. Return a Display, capable of providing a string representation. Args: config: A DisplayConfig instance. If not provided, the DisplayActive will be used.", "IndexNanosecondGO.drop.iloc[]": "Interface for iloc selection that reduces dimensionality.", "IndexNanosecondGO.drop.loc[]": "", "IndexNanosecondGO.[]": "Extract a new index given an iloc key.", "IndexNanosecondGO.iloc[]": "", "IndexNanosecondGO.loc[]": "", "IndexNanosecondGO.iter_label()": "", "IndexNanosecondGO.iter_label().apply()": "Apply a function to each value. Returns a new container. Args: func: A function that takes a value. dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance.", "IndexNanosecondGO.iter_label().apply_iter()": "Apply a function to each value. A generator of resulting values. Args: func: A function that takes a value. Yields: Values after function application.", "IndexNanosecondGO.iter_label().apply_iter_items()": "Apply a function to each value. A generator of resulting key, value pairs. Args: func: A function that takes a value. Yields: Pairs of label, value after function application.", "IndexNanosecondGO.iter_label().apply_pool()": "Apply a function to each value. Employ parallel processing with either the ProcessPoolExecutor or ThreadPoolExecutor. Args: func: A function that takes a value. * dtype: A value suitable for specyfying a NumPy dtype, such as a Python type (float), NumPy array protocol strings ('f8'), or a dtype instance. name: A hashable object to label the container. max_workers: Number of parallel executors, as passed to the Thread- or ProcessPoolExecutor; None defaults to the max number of machine processes. chunksize: Units of work per executor, as passed to the Thread- or ProcessPoolExecutor. use_threads: Use the ThreadPoolExecutor instead of the ProcessPoolExecutor.", "IndexNanosecondGO.__add__()": "", "IndexNanosecondGO.__and__()": "", "IndexNanosecondGO.__eq__()": "", "IndexNanosecondGO.__floordiv__()": "", "IndexNanosecondGO.__ge__()": "", "IndexNanosecondGO.__gt__()": "", "IndexNanosecondGO.__le__()": "", "IndexNanosecondGO.__lt__()": "", "IndexNanosecondGO.__matmul__()": "", "IndexNanosecondGO.__mod__()": "", "IndexNanosecondGO.__mul__()": "", "IndexNanosecondGO.__ne__()": "", "IndexNanosecondGO.__or__()": "", "IndexNanosecondGO.__pow__()": "", "IndexNanosecondGO.__radd__()": "", "IndexNanosecondGO.__rfloordiv__()": "", "IndexNanosecondGO.__rmatmul__()": "", "IndexNanosecondGO.__rmul__()": "", "IndexNanosecondGO.__rshift__()": "", "IndexNanosecondGO.__rsub__()": "", "IndexNanosecondGO.__rtruediv__()": "", "IndexNanosecondGO.__sub__()": "", "IndexNanosecondGO.__truediv__()": "", "IndexNanosecondGO.__xor__()": "", "IndexNanosecondGO.__abs__()": "", "IndexNanosecondGO.__invert__()": "", "IndexNanosecondGO.__neg__()": "", "IndexNanosecondGO.__pos__()": "", "IndexNanosecondGO.via_values.apply()": "", "IndexNanosecondGO.via_values.__array_ufunc__()": "Support for applying NumPy functions directly on containers.", "IndexNanosecondGO.via_values.__call__()": "Args: consolidate_blocks: Group adjacent same-typed arrays into 2D arrays. unify_blocks: Group all arrays into single array, re-typing to an appropriate dtype. dtype: specify a dtype to be used in conversion before consolidation or unification, and before function application.", "IndexNanosecondGO.via_dt.__call__()": "Args: fill_value: If NAT are encountered, use this value.", "IndexNanosecondGO.via_dt.year": "Return the year of each element.", "IndexNanosecondGO.via_dt.year_month": "Return the year and month of each element as string formatted YYYY-MM.", "IndexNanosecondGO.via_dt.year_quarter": "Return the year and quarter of each element as a string formatted YYYY-QQ.", "IndexNanosecondGO.via_dt.month": "Return the month of each element, between 1 and 12 inclusive.", "IndexNanosecondGO.via_dt.day": "Return the day of each element, between 1 and the number of days in the given month of the given year.", "IndexNanosecondGO.via_dt.hour": "Return the hour of each element, between 0 and 24.", "IndexNanosecondGO.via_dt.minute": "Return the minute of each element, between 0 and 60.", "IndexNanosecondGO.via_dt.second": "Return the second of each element, between 0 and 60.", "IndexNanosecondGO.via_dt.weekday()": "Return the day of the week as an integer, where Monday is 0 and Sunday is 6.", "IndexNanosecondGO.via_dt.quarter()": "Return the quarter of the year as an integer, where January through March is quarter 1.", "IndexNanosecondGO.via_dt.is_month_end()": "Return Boolean indicators if the day is the month end.", "IndexNanosecondGO.via_dt.is_month_start()": "Return Boolean indicators if the day is the month start.", "IndexNanosecondGO.via_dt.is_year_end()": "Return Boolean indicators if the day is the year end.", "IndexNanosecondGO.via_dt.is_year_start()": "Return Boolean indicators if the day is the year start.", "IndexNanosecondGO.via_dt.is_quarter_end()": "Return Boolean indicators if the day is the quarter end.", "IndexNanosecondGO.via_dt.is_quarter_start()": "Return Boolean indicators if the day is the quarter start.", "IndexNanosecondGO.via_dt.timetuple()": "Return a time.struct_time such as returned by time.localtime().", "IndexNanosecondGO.via_dt.isoformat()": "Return a string representing the date in ISO 8601 format, YYYY-MM-DD.", "IndexNanosecondGO.via_dt.fromisoformat()": "Return a datetime.date object from an ISO 8601 format.", "IndexNanosecondGO.via_dt.strftime()": "Return a string representing the date, controlled by an explicit format string.", "IndexNanosecondGO.via_dt.strptime()": "Return a Python datetime object from parsing a string defined with format.", "IndexNanosecondGO.via_dt.strpdate()": "Return a Python date object from parsing a string defined with format.", "IndexNanosecondGO.via_str.__getitem__()": "Return a container with the provided selection or slice of each element.", "IndexNanosecondGO.via_str.capitalize()": "Return a container with only the first character of each element capitalized.", "IndexNanosecondGO.via_str.center()": "Return a container with its elements centered in a string of length width.", "IndexNanosecondGO.via_str.contains()": "Return a Boolean container showing True of item is a substring of elements.", "IndexNanosecondGO.via_str.count()": "Returns a container with the number of non-overlapping occurrences of substring sub in the optional range start, end.", "IndexNanosecondGO.via_str.decode()": "Apply str.decode() to each element. Elements must be bytes.", "IndexNanosecondGO.via_str.encode()": "Apply str.encode() to each element. Elements must be strings.", "IndexNanosecondGO.via_str.endswith()": "Returns a container with the number of non-overlapping occurrences of substring suffix (or an iterable of suffixes) in the optional range start, end.", "IndexNanosecondGO.via_str.find()": "For each element, return the lowest index in the string where substring sub is found.", "IndexNanosecondGO.via_str.format()": "For each element, return a string resulting from calling the string format argument's format method with the the element. Format strings (given within curly braces) can use Python's format mini language: https://docs.python.org/3/library/string.html#formatspec Args: format: A string, an iterable of strings, or a mapping of labels to strings. For 1D containers, an iterable of strings must be of length equal to the container; a mapping can use Index labels (for a Series) or positions (for an Index). For 2D containers, an iterable of strings must be of length equal to the columns (for a Frame) or the depth (for an Index Hierarchy); a mapping can use column labels (for a Frame) or depths (for an IndexHierarchy).", "IndexNanosecondGO.via_str.index()": "Like find, but raises ValueError when the substring is not found.", "IndexNanosecondGO.via_str.isalnum()": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.", "IndexNanosecondGO.via_str.isalpha()": "Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.", "IndexNanosecondGO.via_str.isdecimal()": "For each element, return True if there are only decimal characters in the element.", "IndexNanosecondGO.via_str.isdigit()": "Returns true for each element if all characters in the string are digits and there is at least one character, false otherwise.", "IndexNanosecondGO.via_str.islower()": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.", "IndexNanosecondGO.via_str.isnumeric()": "For each element in self, return True if there are only numeric characters in the element.", "IndexNanosecondGO.via_str.isspace()": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.", "IndexNanosecondGO.via_str.istitle()": "Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.", "IndexNanosecondGO.via_str.isupper()": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.", "IndexNanosecondGO.via_str.ljust()": "Return a container with its elements ljusted in a string of length width.", "IndexNanosecondGO.via_str.len()": "Return the length of the string.", "IndexNanosecondGO.via_str.lower()": "Return an array with the elements of self converted to lowercase.", "IndexNanosecondGO.via_str.lstrip()": "For each element, return a copy with the leading characters removed.", "IndexNanosecondGO.via_str.partition()": "Partition each element around sep.", "IndexNanosecondGO.via_str.replace()": "Return a container with its elements replaced in a string of length width.", "IndexNanosecondGO.via_str.rfind()": "For each element, return the highest index in the string where substring sub is found, such that sub is contained within start, end.", "IndexNanosecondGO.via_str.rindex()": "Like rfind, but raises ValueError when the substring sub is not found.", "IndexNanosecondGO.via_str.rjust()": "Return a container with its elements rjusted in a string of length width.", "IndexNanosecondGO.via_str.rpartition()": "Partition (split) each element around the right-most separator.", "IndexNanosecondGO.via_str.rsplit()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexNanosecondGO.via_str.rstrip()": "For each element, return a copy with the trailing characters removed.", "IndexNanosecondGO.via_str.split()": "For each element, return a tuple of the words in the string, using sep as the delimiter string.", "IndexNanosecondGO.via_str.startswith()": "Returns a container with the number of non-overlapping occurrences of substring prefix (or an iterable of prefixes) in the optional range start, end.", "IndexNanosecondGO.via_str.strip()": "For each element, return a copy with the leading and trailing characters removed.", "IndexNanosecondGO.via_str.swapcase()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexNanosecondGO.via_str.title()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexNanosecondGO.via_str.upper()": "Return a container with uppercase characters converted to lowercase and vice versa.", "IndexNanosecondGO.via_str.zfill()": "Return the string left-filled with zeros.", "IndexNanosecondGO.via_re().search()": "Scan through string looking for the first location where this regular expression produces a match and return True, else False. Note that this is different from finding a zero-length match at some point in the string. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexNanosecondGO.via_re().match()": "If zero or more characters at the beginning of string match this regular expression return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexNanosecondGO.via_re().fullmatch()": "If the whole string matches this regular expression, return True, else False. Note that this is different from a zero-length match. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexNanosecondGO.via_re().split()": "Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting tuple. Args: maxsplit: If nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the tuple.", "IndexNanosecondGO.via_re().findall()": "Return all non-overlapping matches of pattern in string, as a tuple of strings. The string is scanned left-to-right, and matches are returned in the order found. If one or more groups are present in the pattern, return a tuple of groups; this will be a tuple of tuples if the pattern has more than one group. Empty matches are included in the result. Args: pos: Gives an index in the string where the search is to start; it defaults to 0. endpos: Limits how far the string will be searched; it will be as if the string is endpos characters long.", "IndexNanosecondGO.via_re().sub()": "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern is not found, the string is returned unchanged. Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexNanosecondGO.via_re().subn()": "Perform the same operation as sub(), but return a tuple (new_string, number_of_subs_made). Args: repl: A string or a function; if it is a string, any backslash escapes in it are processed. count: The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced.", "IndexNanosecondGO.via_hashlib().to_bytes()": "Return the byte signature for this container, suitable for passing to a cryptographic hash function.", "IndexNanosecondGO.via_hashlib().md5()": "", "IndexNanosecondGO.via_hashlib().sha256()": "", "IndexNanosecondGO.via_hashlib().sha512()": "", "IndexNanosecondGO.via_hashlib().sha3_256()": "", "IndexNanosecondGO.via_hashlib().sha3_512()": "", "IndexNanosecondGO.via_hashlib().shake_128()": "", "IndexNanosecondGO.via_hashlib().shake_256()": "", "IndexNanosecondGO.via_hashlib().blake2b()": "", "IndexNanosecondGO.via_hashlib().blake2s()": "", "IndexNanosecondGO.via_type_clinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "IndexNanosecondGO.via_type_clinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexNanosecondGO.via_type_clinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "IndexNanosecondGO.via_type_clinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "IndexNanosecondGO.via_type_clinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "HLoc.__init__()": "", "HLoc.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "HLoc.key": "Built-in immutable sequence. If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items. If the argument is a tuple, the return value is the same object.", "HLoc.__len__()": "", "HLoc.__iter__()": "", "HLoc.__repr__()": "", "HLoc.__str__()": "Return str(self).", "ILoc.__init__()": "", "ILoc.STATIC": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "ILoc.key": "Built-in immutable sequence. If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items. If the argument is a tuple, the return value is the same object.", "ILoc.__repr__()": "", "ILoc.__str__()": "Return str(self).", "TypeClinic.__init__()": "", "TypeClinic.to_hint()": "Return the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "TypeClinic.__call__()": "Given a hint (a type and/or generic alias), return a ClinicResult object describing the result of the check. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "TypeClinic.check()": "Given a hint (a type and/or generic alias), raise a ClinicError exception describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported.", "TypeClinic.warn()": "Given a hint (a type and/or generic alias), issue a warning describing the result of the check if an error is found. Args: fail_fast: If True, return on first failure. If False, all failures are discovered and reported. category: The Warning subclass to be used for issueing the warning.", "TypeClinic.__repr__()": "Return a compact string representation of the type hint (the type and/or generic aliases necessary) to represent the object given at initialization.", "TypeClinic.__str__()": "Return str(self).", "CallGuard.check()": "A function decorator to perform run-time checking of function arguments and return values based on the function type annotations, including type hints and Require-provided validators. Raises ClinicError on failure.", "CallGuard.warn()": "A function decorator to perform run-time checking of function arguments and return values based on the function type annotations, including type hints and Require-provided validators. Issues a warning on failure.", "ClinicResult.__init__()": "", "ClinicResult.to_str()": "Return error messages as a formatted string with line breaks and indentation.", "ClinicResult.validated": "", "ClinicResult.__bool__()": "Return True if there are validation issues.", "ClinicResult.__len__()": "", "ClinicResult.__iter__()": "", "ClinicResult.__repr__()": "", "ClinicResult.__str__()": "Return str(self).", "Require.Apply()": "Apply a function to a container with an arbitrary function. The validation passes if the function returns True (or a truthy value). Args: func: A function that takes a container and returns a Boolean.", "Require.LabelsMatch()": "Validate the presence of one or more labels, specified with the value, a pattern, or set of values. Order of labels is not relevant. Args: \\*labels: Provide labels matchers as args. A label matcher can be a label, a set of labels (of which at least one contained label must match), or a compiled regular expression (with which the search method is used to determine a match of string labels). Each label matcher provided must find at least one match, otherwise an error is returned.", "Require.LabelsOrder()": "Validate the ordering of labels. Args: \\*labels: Provide labels as args. Use ... for regions of zero or more undefined labels.", "Require.Len()": "Validate the length of a container. Args: len: The length to validate against. /", "Require.Name()": "Validate the name of a container. Args: name: The name to validate against. /", "Require.Shape()": "Validate the length of a container. Args: shape: A tuple of one or two values, where values are either an integer or an ..., specifying any value for that position. The size of the shape always species the dimensionality. /", "WWW.from_file()": "Given a URL, return a loadable component, either as an in-memory store (a StringIO or BytesIO) or a disk-based store (either to a provided file path or or managed temporary file that will be deleted after being read). Args: url: A URL string or a Request object from Python's standard library urllib. encoding: Specify the encoding of the resource to be delivered to the caller. If encoding is None, the resource is treated as binary. in_memory: Define if data should be written to disk (reducing RAM usage) or held in memory until loaded. buffer_size: When in_memory is False, the number of bytes to be written per network read fp: Optionally specify a file path to write to; cannot be specified if in_memory is True. When reading from archives (zip, gzip), only the extracted component will be written to this file path.", "WWW.from_gzip()": "Given a URL, return a loadable component, either as an in-memory store (a StringIO or BytesIO) or a disk-based store (either to a provided file path or or managed temporary file that will be deleted after being read). Args: url: A URL string or a Request object from Python's standard library urllib. encoding: Specify the encoding of the resource to be delivered to the caller. If encoding is None, the resource is treated as binary. in_memory: Define if data should be written to disk (reducing RAM usage) or held in memory until loaded. buffer_size: When in_memory is False, the number of bytes to be written per network read fp: Optionally specify a file path to write to; cannot be specified if in_memory is True. When reading from archives (zip, gzip), only the extracted component will be written to this file path.", "WWW.from_zip()": "Given a URL, return a loadable component, either as an in-memory store (a StringIO or BytesIO) or a disk-based store (either to a provided file path or or managed temporary file that will be deleted after being read). Args: url: A URL string or a Request object from Python's standard library urllib. encoding: Specify the encoding of the resource to be delivered to the caller. If encoding is None, the resource is treated as binary. in_memory: Define if data should be written to disk (reducing RAM usage) or held in memory until loaded. buffer_size: When in_memory is False, the number of bytes to be written per network read fp: Optionally specify a file path to write to; cannot be specified if in_memory is True. When reading from archives (zip, gzip), only the extracted component will be written to this file path. component: When reading from a ZIP, specify the name of the component to load; if not specified and only one component exists, that component will be used.", "FillValueAuto.__init__()": "Args: b: fill value for bool kind i: fill value for integer kind u: fill value for unsigned integer kind f: fill value for float kind c: fill value for complex kind m: fill value for timedelta64 kind M: fill value for datetime64 kind O: fill value for object kind S: fill value for bytes kind U: fill value for unicode kind V: fill value for void kind", "FillValueAuto.from_default()": "Create a FileValueAuto instance based on a default selected to prohibit type coercions. Args: b: fill value for bool kind i: fill value for integer kind u: fill value for unsigned integer kind f: fill value for float kind c: fill value for complex kind m: fill value for timedelta64 kind M: fill value for datetime64 kind O: fill value for object kind S: fill value for bytes kind U: fill value for unicode kind V: fill value for void kind", "FillValueAuto.M": "The base class of the class hierarchy. When called, it accepts no arguments and returns a new featureless instance that has no instance attributes and cannot be given any.", "FillValueAuto.O": "The base class of the class hierarchy. When called, it accepts no arguments and returns a new featureless instance that has no instance attributes and cannot be given any.", "FillValueAuto.S": "The base class of the class hierarchy. When called, it accepts no arguments and returns a new featureless instance that has no instance attributes and cannot be given any.", "FillValueAuto.U": "The base class of the class hierarchy. When called, it accepts no arguments and returns a new featureless instance that has no instance attributes and cannot be given any.", "FillValueAuto.V": "The base class of the class hierarchy. When called, it accepts no arguments and returns a new featureless instance that has no instance attributes and cannot be given any.", "FillValueAuto.b": "Built-in immutable sequence. If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items. If the argument is a tuple, the return value is the same object.", "FillValueAuto.c": "The base class of the class hierarchy. When called, it accepts no arguments and returns a new featureless instance that has no instance attributes and cannot be given any.", "FillValueAuto.f": "The base class of the class hierarchy. When called, it accepts no arguments and returns a new featureless instance that has no instance attributes and cannot be given any.", "FillValueAuto.i": "The base class of the class hierarchy. When called, it accepts no arguments and returns a new featureless instance that has no instance attributes and cannot be given any.", "FillValueAuto.m": "The base class of the class hierarchy. When called, it accepts no arguments and returns a new featureless instance that has no instance attributes and cannot be given any.", "FillValueAuto.u": "The base class of the class hierarchy. When called, it accepts no arguments and returns a new featureless instance that has no instance attributes and cannot be given any.", "FillValueAuto.__repr__()": "Return repr(self).", "FillValueAuto.__str__()": "Return str(self).", "FillValueAuto.[]": "", "DisplayActive.__init__()": "Initialize self. See help(type(self)) for accurate signature.", "DisplayActive.FILE_NAME": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.", "DisplayActive.read()": "", "DisplayActive.set()": "", "DisplayActive.update()": "", "DisplayActive.write()": "", "DisplayActive.get()": "", "DisplayActive.__repr__()": "Return repr(self).", "DisplayActive.__str__()": "Return str(self).", "DisplayConfig.__init__()": "", "DisplayConfig.from_default()": "", "DisplayConfig.from_file()": "", "DisplayConfig.from_json()": "", "DisplayConfig.to_dict()": "", "DisplayConfig.to_display_config()": "", "DisplayConfig.to_json()": "", "DisplayConfig.to_transpose()": "", "DisplayConfig.cell_align_left": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "DisplayConfig.cell_max_width": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.cell_max_width_leftmost": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.cell_placeholder": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.", "DisplayConfig.display_columns": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.display_format": "Define display output format.", "DisplayConfig.display_rows": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.include_columns": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "DisplayConfig.include_index": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "DisplayConfig.type_color": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "DisplayConfig.type_color_bool": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.type_color_bus": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.type_color_complex": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.type_color_datetime": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.type_color_default": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.type_color_float": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.type_color_frame": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.type_color_index": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.type_color_int": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.type_color_object": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.type_color_quilt": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.type_color_series": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.type_color_str": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.type_color_timedelta": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "DisplayConfig.type_delimiter_left": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.", "DisplayConfig.type_delimiter_right": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.", "DisplayConfig.type_show": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "DisplayConfig.value_format_complex_positional": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.", "DisplayConfig.value_format_complex_scientific": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.", "DisplayConfig.value_format_float_positional": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.", "DisplayConfig.value_format_float_scientific": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.", "DisplayConfig.write()": "Write a JSON file.", "DisplayConfig.interface": "A Frame documenting the interface of this class.", "DisplayConfig.__repr__()": "", "DisplayConfig.__str__()": "Return str(self).", "StoreConfig.__init__()": "", "StoreConfig.from_frame()": "Derive a config from a Frame.", "StoreConfig.to_store_config_he()": "Return a StoreConfigHE version of this StoreConfig.", "StoreConfig.columns_constructors": "", "StoreConfig.columns_depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "StoreConfig.columns_name_depth_level": "", "StoreConfig.columns_select": "", "StoreConfig.consolidate_blocks": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "StoreConfig.dtypes": "", "StoreConfig.include_columns": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "StoreConfig.include_columns_name": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "StoreConfig.include_index": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "StoreConfig.include_index_name": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "StoreConfig.index_constructors": "", "StoreConfig.index_depth": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "StoreConfig.index_name_depth_level": "", "StoreConfig.label_decoder": "", "StoreConfig.label_encoder": "", "StoreConfig.merge_hierarchical_labels": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "StoreConfig.mp_context": "", "StoreConfig.read_chunksize": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "StoreConfig.read_max_workers": "", "StoreConfig.skip_footer": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "StoreConfig.skip_header": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "StoreConfig.trim_nadir": "bool(x) -> bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.", "StoreConfig.write_chunksize": "int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4", "StoreConfig.write_max_workers": "", "StoreConfig.label_decode()": "", "StoreConfig.label_encode()": "", "StoreConfig.interface": "A Frame documenting the interface of this class.", "StoreConfig.__repr__()": "Return repr(self).", "StoreConfig.__str__()": "Return str(self).", "StoreFilter.__init__()": "", "StoreFilter.from_type_filter_array()": "Given an array, replace types with strings", "StoreFilter.from_type_filter_element()": "Filter single values to string.", "StoreFilter.to_type_filter_array()": "Given an array, replace strings with types.", "StoreFilter.to_type_filter_element()": "Given a value wich may be an encoded string, decode into a type.", "StoreFilter.from_nan": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.", "StoreFilter.from_nat": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.", "StoreFilter.from_neginf": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.", "StoreFilter.from_none": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.", "StoreFilter.from_posinf": "str(object='') -> str str(bytes_or_buffer[, encoding[, errors]]) -> str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.", "StoreFilter.to_nan": "frozenset() -> empty frozenset object frozenset(iterable) -> frozenset object Build an immutable unordered collection of unique elements.", "StoreFilter.to_nat": "frozenset() -> empty frozenset object frozenset(iterable) -> frozenset object Build an immutable unordered collection of unique elements.", "StoreFilter.to_neginf": "frozenset() -> empty frozenset object frozenset(iterable) -> frozenset object Build an immutable unordered collection of unique elements.", "StoreFilter.to_none": "frozenset() -> empty frozenset object frozenset(iterable) -> frozenset object Build an immutable unordered collection of unique elements.", "StoreFilter.to_posinf": "frozenset() -> empty frozenset object frozenset(iterable) -> frozenset object Build an immutable unordered collection of unique elements.", "StoreFilter.value_format_complex_positional": "", "StoreFilter.value_format_complex_scientific": "", "StoreFilter.value_format_float_positional": "", "StoreFilter.value_format_float_scientific": "", "StoreFilter.interface": "A Frame documenting the interface of this class.", "StoreFilter.__repr__()": "Return repr(self).", "StoreFilter.__str__()": "Return str(self).", "IndexAutoFactory.__init__()": "", "IndexAutoFactory.from_optional_constructor()": "", "IndexAutoFactory.to_index()": "Called by index_from_optional_constructor.", "IndexAutoFactory.__repr__()": "Return repr(self).", "IndexAutoFactory.__str__()": "Return str(self).", "IndexDefaultConstructorFactory.__init__()": "", "IndexDefaultConstructorFactory.__call__()": "Call the passed constructor with the name.", "IndexDefaultConstructorFactory.__repr__()": "Return repr(self).", "IndexDefaultConstructorFactory.__str__()": "Return str(self).", "IndexAutoConstructorFactory.__init__()": "", "IndexAutoConstructorFactory.to_index()": "Create and return the Index based on the array dtype", "IndexAutoConstructorFactory.__call__()": "Call the passeed constructor with the name.", "IndexAutoConstructorFactory.__repr__()": "Return repr(self).", "IndexAutoConstructorFactory.__str__()": "Return str(self).", "NPZ.__init__()": "", "NPZ.from_arrays()": "Given an iterable of arrays, write out an NPZ or NPY directly, without building up intermediary Frame. If axis 0, the arrays are vertically stacked; if axis 1, they are horizontally stacked. For both axis, if included, indices must be of appropriate length. Args: blocks: * index: An array, Index, or IndexHierarchy. columns: An array, Index, or IndexHierarchy. name: axis:", "NPZ.from_frames()": "Given an iterable of Frames, write out an NPZ or NPY directly, without building up an intermediary Frame. If axis 0, the Frames must be block compatible; if axis 1, the Frames must have the same number of rows. For both axis, if included, concatenated indices must be unique or aligned. Args: frames: * include_index: include_columns: axis: union: name: fill_value:", "NPZ.contents": "Return a Frame indicating name, dtype, shape, and bytes, of Archive components.", "NPZ.nbytes": "Return numer of bytes stored in this archive.", "NPZ.__enter__()": "When entering a context manager, a handle to this instance is returned.", "NPZ.__exit__()": "When exiting a context manager, resources are closed as necessary.", "NPZ.interface": "A Frame documenting the interface of this class.", "NPZ.__repr__()": "Return repr(self).", "NPZ.__str__()": "Return str(self).", "NPY.__init__()": "", "NPY.from_arrays()": "Given an iterable of arrays, write out an NPZ or NPY directly, without building up intermediary Frame. If axis 0, the arrays are vertically stacked; if axis 1, they are horizontally stacked. For both axis, if included, indices must be of appropriate length. Args: blocks: * index: An array, Index, or IndexHierarchy. columns: An array, Index, or IndexHierarchy. name: axis:", "NPY.from_frames()": "Given an iterable of Frames, write out an NPZ or NPY directly, without building up an intermediary Frame. If axis 0, the Frames must be block compatible; if axis 1, the Frames must have the same number of rows. For both axis, if included, concatenated indices must be unique or aligned. Args: frames: * include_index: include_columns: axis: union: name: fill_value:", "NPY.contents": "Return a Frame indicating name, dtype, shape, and bytes, of Archive components.", "NPY.nbytes": "Return numer of bytes stored in this archive.", "NPY.__enter__()": "When entering a context manager, a handle to this instance is returned.", "NPY.__exit__()": "When exiting a context manager, resources are closed as necessary.", "NPY.interface": "A Frame documenting the interface of this class.", "NPY.__repr__()": "Return repr(self).", "NPY.__str__()": "Return str(self).", "MemoryDisplay.__init__()": "Initialize an instance with a Frame of byte counts.", "MemoryDisplay.from_any()": "Given any slotted object, return a MemoryDisplay instance.", "MemoryDisplay.to_frame()": "Return a Frame of byte counts.", "MemoryDisplay.__repr__()": "", "MemoryDisplay.__str__()": "Return str(self).", "Platform.__init__()": "Initialize self. See help(type(self)) for accurate signature.", "Platform.to_series()": "", "Platform.__repr__()": "Return repr(self).", "Platform.__str__()": "Return str(self).", "Platform.display()": ""}